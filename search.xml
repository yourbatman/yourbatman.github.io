<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>8. 格式化器大一统 -- Spring的Formatter抽象</title>
    <url>/x2y/ff31c4c6.html</url>
    <content><![CDATA[<p><img data-src="https://img-blog.csdnimg.cn/20201227153201605.png#pic_center" alt=""></p>
<p>你好，我是A哥(YourBatman)。</p>
<p><a href="https://mp.weixin.qq.com/s/ENKwVqPE1cuOgE51ODJnnw" target="_blank" rel="noopener">上篇文章</a> 介绍了<code>java.text.Format</code>格式化体系，作为JDK 1.0就提供的格式化器，除了设计上存在一定缺陷，过于底层无法标准化对使用者不够友好，这都是对格式化器提出的更高要求。Spring作为Java开发的标准基建，本文就来看看它做了哪些补充。</p>
<h2 id="本文提纲"><a href="#本文提纲" class="headerlink" title="本文提纲"></a>本文提纲</h2><p><img data-src="https://img-blog.csdnimg.cn/20201227191140521.png#pic_center" alt=""></p>
<h2 id="版本约定"><a href="#版本约定" class="headerlink" title="版本约定"></a>版本约定</h2><ul>
<li>Spring Framework：5.3.x</li>
<li>Spring Boot：2.4.x</li>
</ul>
<h1 id="✍正文"><a href="#✍正文" class="headerlink" title="✍正文"></a>✍正文</h1><p>在应用中（特别是web应用），我们经常需要将前端/Client端传入的字符串转换成<strong>指定格式/指定数据类型</strong>，同样的服务端也希望能把指定类型的数据按照<strong>指定格式</strong> 返回给前端/Client端，这种情况下<code>Converter</code>已经无法满足我们的需求了。为此，Spring提供了格式化模块专门用于解决此类问题。</p>
<p>首先可以从宏观上先看看spring-context对format模块的目录结构安排：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201221054434297.png#pic_center" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Formatter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Printer</span>&lt;<span class="title">T</span>&gt;, <span class="title">Parser</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，该接口本身没有任何方法，而是聚合了另外两个接口Printer和Parser。</p>
<h2 id="Printer-amp-Parser"><a href="#Printer-amp-Parser" class="headerlink" title="Printer&amp;Parser"></a>Printer&amp;Parser</h2><p>这两个接口是相反功能的接口。</p>
<ul>
<li><code>Printer</code>：格式化显示（输出）接口。将T类型转为String形式，Locale用于控制国际化<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Printer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">// 将Object写为String类型</span></span><br><span class="line">	<span class="function">String <span class="title">print</span><span class="params">(T object, Locale locale)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>Parser</code>：解析接口。将String类型转到T类型，Locale用于控制国际化。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Parser</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function">T <span class="title">parse</span><span class="params">(String text, Locale locale)</span> <span class="keyword">throws</span> ParseException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Formatter"><a href="#Formatter" class="headerlink" title="Formatter"></a>Formatter</h2><p>格式化器接口，它的继承树如下：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201221062511589.png#pic_center" alt=""></p>
<p>由图可见，格式化动作只需关心到两个领域：</p>
<ul>
<li>时间日期领域</li>
<li>数字领域（其中包括货币）</li>
</ul>
<h3 id="时间日期格式化"><a href="#时间日期格式化" class="headerlink" title="时间日期格式化"></a>时间日期格式化</h3><p>Spring框架从4.0开始支持Java 8，针对<code>JSR 310</code>日期时间类型的格式化专门有个包<code>org.springframework.format.datetime.standard</code>：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201221060624967.png#pic_center" alt=""></p>
<p><strong>值得一提的是</strong>：在Java 8出来之前，Joda-Time是Java日期时间处理最好的解决方案，使用广泛，甚至得到了Spring内置的支持。现在Java 8已然成为主流，JSR 310日期时间API <strong>完全可以</strong> 代替Joda-Time（JSR 310的贡献者其实就是Joda-Time的作者们）。因此joda库也逐渐告别历史舞台，后续代码中不再推荐使用，本文也会选择性忽略。</p>
<p>除了Joda-Time外，Java中对时间日期的格式化还需分为这两大阵营来处理：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201222063045457.png#pic_center" alt=""></p>
<h4 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h4><p>虽然已经2020年了（Java 8于2014年发布），但谈到时间日期那必然还是得有<code>java.util.Date</code>，毕竟积重难返。所以呢，Spring提供了<code>DateFormatter</code>用于支持它的格式化。</p>
<blockquote>
<p>因为Date早就存在，所以DateFormatter是伴随着Formatter的出现而出现，@since 3.0</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @since 3.0</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateFormatter</span> <span class="keyword">implements</span> <span class="title">Formatter</span>&lt;<span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> TimeZone UTC = TimeZone.getTimeZone(<span class="string">"UTC"</span>);</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;ISO, String&gt; ISO_PATTERNS;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		Map&lt;ISO, String&gt; formats = <span class="keyword">new</span> EnumMap&lt;&gt;(ISO<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		formats.put(ISO.DATE, <span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">		formats.put(ISO.TIME, <span class="string">"HH:mm:ss.SSSXXX"</span>);</span><br><span class="line">		formats.put(ISO.DATE_TIME, <span class="string">"yyyy-MM-dd'T'HH:mm:ss.SSSXXX"</span>);</span><br><span class="line">		ISO_PATTERNS = Collections.unmodifiableMap(formats);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认使用的TimeZone是UTC标准时区，<code>ISO_PATTERNS</code>代表ISO标准模版，这和<code>@DateTimeFormat</code>注解的iso属性是<strong>一一对应</strong>的。也就是说如果你不想指定pattern，可以快速通过指定ISO来实现。</p>
<p>另外，对于格式化器来说有这些属性你都可以自由去定制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateFormatter：</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> String pattern;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> style = DateFormat.DEFAULT;</span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> String stylePattern;</span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> ISO iso;</span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> TimeZone timeZone;</span><br></pre></td></tr></table></figure>
<p>它对Formatter接口方法的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateFormatter：</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">print</span><span class="params">(Date date, Locale locale)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> getDateFormat(locale).format(date);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Date <span class="title">parse</span><span class="params">(String text, Locale locale)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> getDateFormat(locale).parse(text);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据pattern、ISO等等得到一个DateFormat实例</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> DateFormat <span class="title">getDateFormat</span><span class="params">(Locale locale)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到不管输入还是输出，底层依赖的都是JDK的<code>java.text.DateFormat</code>（实际为SimpleDateFormat），现在知道为毛<a href="https://mp.weixin.qq.com/s/ENKwVqPE1cuOgE51ODJnnw" target="_blank" rel="noopener">上篇文章</a>要先讲JDK的格式化体系做铺垫了吧，万变不离其宗。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201226210109260.png#pic_center" alt=""></p>
<p>因此可以认为，Spring为此做的事情的核心，只不过是写了个根据Locale、pattern、IOS等参数生成<code>DateFormat</code>实例的逻辑而已，属于应用层面的封装。也就是需要知晓<code>getDateFormat()</code>方法的逻辑，此部分逻辑绘制成图如下：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201222060840323.png#pic_center" alt=""></p>
<p>因此：pattern、iso、stylePattern它们的优先级谁先谁后，一看便知。</p>
<h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DateFormatter formatter = <span class="keyword">new</span> DateFormatter();</span><br><span class="line">    </span><br><span class="line">    Date currDate = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"默认输出格式："</span> + formatter.print(currDate, Locale.CHINA));</span><br><span class="line">    formatter.setIso(DateTimeFormat.ISO.DATE_TIME);</span><br><span class="line">    System.out.println(<span class="string">"指定ISO输出格式："</span> + formatter.print(currDate, Locale.CHINA));</span><br><span class="line">    formatter.setPattern(<span class="string">"yyyy-mm-dd HH:mm:ss"</span>);</span><br><span class="line">    System.out.println(<span class="string">"指定pattern输出格式："</span> + formatter.print(currDate, Locale.CHINA));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">默认输出格式：<span class="number">2020</span>-<span class="number">12</span>-<span class="number">26</span></span><br><span class="line">指定ISO输出格式：<span class="number">2020</span>-<span class="number">12</span>-<span class="number">26</span>T13:<span class="number">06</span>:<span class="number">52.921</span>Z</span><br><span class="line">指定pattern输出格式：<span class="number">2020</span>-<span class="number">06</span>-<span class="number">26</span> <span class="number">21</span>:<span class="number">06</span>:<span class="number">52</span></span><br></pre></td></tr></table></figure>
<p>注意：ISO格式输出的时间，是存在时差问题的，因为它使用的是UTC时间，请稍加注意。</p>
<p>还记得本系列前面介绍的<code>CustomDateEditor</code>这个属性编辑器吗？它也是用于对String -&gt; Date的转化，底层依赖也是JDK的<code>DateFormat</code>，但使用灵活度上没这个自由，已被抛弃/取代。</p>
<p>关于<code>java.util.Date</code>类型的格式化，在此，语重心长的号召一句：如果你是<strong>新</strong>项目，请全项目禁用Date类型吧；如果你是新代码，也请不要再使用Date类型，太拖后腿了。</p>
<h4 id="JSR-310类型"><a href="#JSR-310类型" class="headerlink" title="JSR 310类型"></a>JSR 310类型</h4><p><img data-src="https://img-blog.csdnimg.cn/20201226212041456.png#pic_center" alt=""></p>
<p>JSR 310日期时间类型是Java8引入的一套<strong>全新的</strong>时间日期API。新的时间及日期API位于java.time中，此包中的是类是不可变且线程安全的。下面是一些关键类</p>
<ul>
<li><strong>Instant</strong>——代表的是时间戳（另外可参考Clock类）</li>
<li><strong>LocalDate</strong>——不包含具体时间的日期，如2020-12-12。它可以用来存储生日，周年纪念日，入职日期等</li>
<li><strong>LocalTime</strong>——代表的是不含日期的时间，如18:00:00</li>
<li><strong>LocalDateTime</strong>——包含了日期及时间，不过没有偏移信息或者说时区</li>
<li><strong>ZonedDateTime</strong>——包含时区的<strong>完整的</strong>日期时间还有时区，偏移量是以UTC/格林威治时间为基准的</li>
<li><strong>Timezone</strong>——时区。在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到</li>
</ul>
<p>同时还有一些辅助类，如：Year、Month、YearMonth、MonthDay、Duration、Period等等。</p>
<p>从上图<code>Formatter</code>的继承树来看，Spring只提供了一些辅助类的格式化器实现，如MonthFormatter、PeriodFormatter、YearMonthFormatter等，且实现方式都是趋同的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonthFormatter</span> <span class="keyword">implements</span> <span class="title">Formatter</span>&lt;<span class="title">Month</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Month <span class="title">parse</span><span class="params">(String text, Locale locale)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Month.valueOf(text.toUpperCase());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">print</span><span class="params">(Month object, Locale locale)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> object.toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里以MonthFormatter为例，其它辅助类的格式化器实现其实基本一样：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201222064054953.png#pic_center" alt=""></p>
<p>那么问题来了：Spring为毛没有给<code>LocalDateTime、LocalDate、LocalTime</code>这种更为常用的类型提供Formatter格式化器呢？</p>
<p>其实是这样的：JDK 8提供的这套日期时间API是非常优秀的，自己就提供了非常好用的<code>java.time.format.DateTimeFormatter</code>格式化器，并且设计、功能上都已经非常完善了。既然如此，Spring并不需要再重复造轮子，而是仅需考虑如何<strong>整合</strong>此格式化器即可。</p>
<h5 id="整合DateTimeFormatter"><a href="#整合DateTimeFormatter" class="headerlink" title="整合DateTimeFormatter"></a>整合DateTimeFormatter</h5><p>为了完成“整合”，把DateTimeFormatter融入到Spring自己的Formatter体系内，Spring准备了多个API用于衔接。</p>
<ul>
<li><strong>DateTimeFormatterFactory</strong></li>
</ul>
<p><code>java.time.format.DateTimeFormatter</code>的工厂。和DateFormatter一样，它支持如下属性方便你直接定制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTimeFormatterFactory：</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> String pattern;</span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> ISO iso;</span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> FormatStyle dateStyle;</span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> FormatStyle timeStyle;</span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> TimeZone timeZone;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据定制的参数，生成一个DateTimeFormatter实例</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> DateTimeFormatter <span class="title">createDateTimeFormatter</span><span class="params">(DateTimeFormatter fallbackFormatter)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://img-blog.csdnimg.cn/20201223060640184.png#pic_center" alt=""></p>
<p>优先级关系二者是一致的：</p>
<ul>
<li>pattern</li>
<li>iso</li>
<li>dateStyle/timeStyle</li>
</ul>
<p>说明：一致的设计，可以给与开发者近乎一致的<strong>编程体验</strong>，毕竟JSR 310和Date表示的都是时间日期，尽量保持一致性是一种很人性化的设计考量。</p>
<ul>
<li><strong>DateTimeFormatterFactoryBean</strong></li>
</ul>
<p>顾名思义，DateTimeFormatterFactory用于生成一个DateTimeFormatter实例，而本类用于把生成的Bean放进IoC容器内，完成和Spring容器的整合。客气的是，它直接继承自DateTimeFormatterFactory，从而自己同时就具备这两项能力：</p>
<ol>
<li>生成DateTimeFormatter实例</li>
<li>将该实例放进IoC容器</li>
</ol>
<p>多说一句：虽然这个工厂Bean非常简单，但是它释放的信号可以作为<strong>编程指导</strong>：</p>
<ol>
<li>一个应用内，对日期、时间的格式化尽量只存在<strong>1种模版规范</strong>。比如我们可以向IoC容器里扔进去一个模版，需要时注入进来使用即可<ol>
<li>注意：这里指的应用<strong>内</strong>，一般不包含协议转换层使用的模版规范。如Http协议层可以使用自己单独的一套转换模版机制</li>
</ol>
</li>
<li>日期时间模版不要在每次使用时去临时创建，而是集中统一创建好管理起来（比如放IoC容器内），这样维护起来方便很多</li>
</ol>
<blockquote>
<p>说明：<code>DateTimeFormatterFactoryBean</code>这个API在Spring内部并未使用，这是Spring专门给使用者用的，因为Spring也希望你这么去做从而把日期时间格式化模版管理起来</p>
</blockquote>
<h5 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DateTimeFormatterFactory dateTimeFormatterFactory = new DateTimeFormatterFactory();</span></span><br><span class="line">    <span class="comment">// dateTimeFormatterFactory.setPattern("yyyy-MM-dd HH:mm:ss");</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行格式化动作</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> DateTimeFormatterFactory(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).createDateTimeFormatter().format(LocalDateTime.now()));</span><br><span class="line">    System.out.println(<span class="keyword">new</span> DateTimeFormatterFactory(<span class="string">"yyyy-MM-dd"</span>).createDateTimeFormatter().format(LocalDate.now()));</span><br><span class="line">    System.out.println(<span class="keyword">new</span> DateTimeFormatterFactory(<span class="string">"HH:mm:ss"</span>).createDateTimeFormatter().format(LocalTime.now()));</span><br><span class="line">    System.out.println(<span class="keyword">new</span> DateTimeFormatterFactory(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).createDateTimeFormatter().format(ZonedDateTime.now()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span>-<span class="number">12</span>-<span class="number">26</span> <span class="number">22</span>:<span class="number">44</span>:<span class="number">44</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">12</span>-<span class="number">26</span></span><br><span class="line"><span class="number">22</span>:<span class="number">44</span>:<span class="number">44</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">12</span>-<span class="number">26</span> <span class="number">22</span>:<span class="number">44</span>:<span class="number">44</span></span><br></pre></td></tr></table></figure>
<p>说明：虽然你也可以直接使用<code>DateTimeFormatter#ofPattern()</code>静态方法得到一个实例，<strong>但是</strong> 若在Spring环境下使用它我还是建议使用Spring提供的工厂类来创建，这样能保证统一的编程体验，B格也稍微高点。</p>
<p><strong>使用建议</strong>：以后对日期时间类型（包括JSR310类型）就不要自己去写原生的<code>SimpleDateFormat/DateTimeFormatter</code>了，建议可以用Spring包装过的<code>DateFormatter/DateTimeFormatterFactory</code>，使用体验更佳。</p>
<h3 id="数字格式化"><a href="#数字格式化" class="headerlink" title="数字格式化"></a>数字格式化</h3><p>通过了<a href="https://mp.weixin.qq.com/s/ENKwVqPE1cuOgE51ODJnnw" target="_blank" rel="noopener">上篇文章</a>的学习之后，对数字的格式化就一点也不陌生了，什么数字、百分数、钱币等都属于数字的范畴。Spring提供了<code>AbstractNumberFormatter</code>抽象来专门处理数字格式化议题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractNumberFormatter</span> <span class="keyword">implements</span> <span class="title">Formatter</span>&lt;<span class="title">Number</span>&gt; </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">print</span><span class="params">(Number number, Locale locale)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> getNumberFormat(locale).format(number);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Number <span class="title">parse</span><span class="params">(String text, Locale locale)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">		<span class="comment">// 伪代码，核心逻辑就这一句</span></span><br><span class="line">		<span class="keyword">return</span> getNumberFormat.parse(text, <span class="keyword">new</span> ParsePosition(<span class="number">0</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 得到一个NumberFormat实例</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> NumberFormat <span class="title">getNumberFormat</span><span class="params">(Locale locale)</span></span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这和<code>DateFormatter</code>的实现模式何其相似，简直一模一样：底层实现依赖于（委托给）<code>java.text.NumberFormat</code>去完成。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201227054222168.png#pic_center" alt=""></p>
<p>此抽象类共有三个具体实现：</p>
<ul>
<li>NumberStyleFormatter：数字格式化，如小数，分组等</li>
<li>PercentStyleFormatter：百分数格式化</li>
<li>CurrencyStyleFormatter：钱币格式化</li>
</ul>
<h4 id="数字格式化-1"><a href="#数字格式化-1" class="headerlink" title="数字格式化"></a>数字格式化</h4><p><code>NumberStyleFormatter</code>使用NumberFormat的<strong>数字样式</strong>的通用数字格式化程序。可定制化参数为：pattern。核心源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NumberStyleFormatter：</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> NumberFormat <span class="title">getNumberFormat</span><span class="params">(Locale locale)</span> </span>&#123;</span><br><span class="line">		NumberFormat format = NumberFormat.getInstance(locale);</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 解析时，永远返回BigDecimal类型</span></span><br><span class="line">		decimalFormat.setParseBigDecimal(<span class="keyword">true</span>);</span><br><span class="line">		<span class="comment">// 使用格式化模版</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.pattern != <span class="keyword">null</span>) &#123;</span><br><span class="line">			decimalFormat.applyPattern(<span class="keyword">this</span>.pattern);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> decimalFormat;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">    NumberStyleFormatter formatter = <span class="keyword">new</span> NumberStyleFormatter();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> myNum = <span class="number">1220.0455</span>;</span><br><span class="line">    System.out.println(formatter.print(myNum, Locale.getDefault()));</span><br><span class="line"></span><br><span class="line">    formatter.setPattern(<span class="string">"#.##"</span>);</span><br><span class="line">    System.out.println(formatter.print(myNum, Locale.getDefault()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换</span></span><br><span class="line">    <span class="comment">// Number parsedResult = formatter.parse("1,220.045", Locale.getDefault()); // java.text.ParseException: 1,220.045</span></span><br><span class="line">    Number parsedResult = formatter.parse(<span class="string">"1220.045"</span>, Locale.getDefault());</span><br><span class="line">    System.out.println(parsedResult.getClass() + <span class="string">"--&gt;"</span> + parsedResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">220.045</span></span><br><span class="line"><span class="number">1220.05</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">math</span>.<span class="title">BigDecimal</span>--&gt;1220.045</span></span><br></pre></td></tr></table></figure>
<ol>
<li>可通过setPattern()指定数字格式化的模版（一般建议显示指定）</li>
<li>parse()方法返回的是<code>BigDecimal</code>类型，从而保证了数字精度</li>
</ol>
<h4 id="百分数格式化"><a href="#百分数格式化" class="headerlink" title="百分数格式化"></a>百分数格式化</h4><p><code>PercentStyleFormatter</code>表示使用百分比样式去格式化数字。核心源码（其实是全部源码）如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PercentStyleFormatter：</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> NumberFormat <span class="title">getNumberFormat</span><span class="params">(Locale locale)</span> </span>&#123;</span><br><span class="line">		NumberFormat format = NumberFormat.getPercentInstance(locale);</span><br><span class="line">		<span class="keyword">if</span> (format <span class="keyword">instanceof</span> DecimalFormat) &#123;</span><br><span class="line">			((DecimalFormat) format).setParseBigDecimal(<span class="keyword">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> format;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这个就更简单啦，pattern模版都不需要指定。代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">    PercentStyleFormatter formatter = <span class="keyword">new</span> PercentStyleFormatter();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> myNum = <span class="number">1220.0455</span>;</span><br><span class="line">    System.out.println(formatter.print(myNum, Locale.getDefault()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换</span></span><br><span class="line">    <span class="comment">// Number parsedResult = formatter.parse("1,220.045", Locale.getDefault()); // java.text.ParseException: 1,220.045</span></span><br><span class="line">    Number parsedResult = formatter.parse(<span class="string">"122,005%"</span>, Locale.getDefault());</span><br><span class="line">    System.out.println(parsedResult.getClass() + <span class="string">"--&gt;"</span> + parsedResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">122</span>,<span class="number">005</span>%</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">math</span>.<span class="title">BigDecimal</span>--&gt;1220.05</span></span><br></pre></td></tr></table></figure>
<p>百分数的格式化不能指定pattern，差评。</p>
<h4 id="钱币格式化"><a href="#钱币格式化" class="headerlink" title="钱币格式化"></a>钱币格式化</h4><p>使用<strong>钱币样式</strong>格式化数字，使用<code>java.util.Currency</code>来描述货币。代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">    CurrencyStyleFormatter formatter = <span class="keyword">new</span> CurrencyStyleFormatter();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> myNum = <span class="number">1220.0455</span>;</span><br><span class="line">    System.out.println(formatter.print(myNum, Locale.getDefault()));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"--------------定制化--------------"</span>);</span><br><span class="line">    <span class="comment">// 指定货币种类（如果你知道的话）</span></span><br><span class="line">    <span class="comment">// formatter.setCurrency(Currency.getInstance(Locale.getDefault()));</span></span><br><span class="line">    <span class="comment">// 指定所需的分数位数。默认是2</span></span><br><span class="line">    formatter.setFractionDigits(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 舍入模式。默认是RoundingMode#UNNECESSARY</span></span><br><span class="line">    formatter.setRoundingMode(RoundingMode.CEILING);</span><br><span class="line">    <span class="comment">// 格式化数字的模版</span></span><br><span class="line">    formatter.setPattern(<span class="string">"#.#¤¤"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(formatter.print(myNum, Locale.getDefault()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换</span></span><br><span class="line">    <span class="comment">// Number parsedResult = formatter.parse("￥1220.05", Locale.getDefault());</span></span><br><span class="line">    Number parsedResult = formatter.parse(<span class="string">"1220.1CNY"</span>, Locale.getDefault());</span><br><span class="line">    System.out.println(parsedResult.getClass() + <span class="string">"--&gt;"</span> + parsedResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">￥<span class="number">1</span>,<span class="number">220.05</span></span><br><span class="line">--------------定制化--------------</span><br><span class="line"><span class="number">1220.1</span>CNY</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">math</span>.<span class="title">BigDecimal</span>--&gt;1220.1</span></span><br></pre></td></tr></table></figure>
<p>值得关注的是：这三个实现在Spring 4.2版本之前是“耦合”在一起。直到4.2才拆开，职责分离。</p>
<h1 id="✍总结"><a href="#✍总结" class="headerlink" title="✍总结"></a>✍总结</h1><p>本文介绍了Spring的Formatter抽象，让格式化器大一统。这就是Spring最强能力：API设计、抽象、大一统。</p>
<p>Converter可以从任意源类型，转换为任意目标类型。而Formatter则是从String类型转换为任务目标类型，有点类似PropertyEditor。可以感觉出Converter是Formater的<strong>超集</strong>，实际上在Spring中Formatter是被拆解成PrinterConverter和ParserConverter，然后再注册到ConverterRegistry，供后续使用。</p>
<p>关于格式化器的注册中心、注册员，这就是下篇文章内容喽，欢迎保持持续关注。</p>
<h2 id="♨本文思考题♨"><a href="#♨本文思考题♨" class="headerlink" title="♨本文思考题♨"></a>♨本文思考题♨</h2><p><strong>看完了不一定懂，看懂了不一定记住，记住了不一定掌握</strong>。来，文末3个思考题帮你复盘：</p>
<ol>
<li>Spring为何没有针对JSR310时间类型提供专用转换器实现？</li>
<li>Spring内建众多Formatter实现，如何管理？</li>
<li>格式化器Formatter和转换器Converter是如何整合到一起的？</li>
</ol>
<h2 id="♚声明♚"><a href="#♚声明♚" class="headerlink" title="♚声明♚"></a>♚声明♚</h2><p>本文所属专栏：<strong>Spring类型转换</strong>，公号后台回复专栏名即可获取全部内容。</p>
<blockquote>
<p>分享、成长，拒绝浅藏辄止。关注公众号【<strong>BAT的乌托邦</strong>】，回复关键字<code>专栏</code>有Spring技术栈、中间件等小而美的<strong>原创专栏</strong>供以免费学习。本文已被 <a href="https://www.yourbatman.cn">https://www.yourbatman.cn</a> 收录。</p>
</blockquote>
<p>本文是 <strong>A哥(YourBatman)</strong> 原创文章，未经作者允许不得转载，谢谢合作。</p>
<h2 id="☀推荐阅读☀"><a href="#☀推荐阅读☀" class="headerlink" title="☀推荐阅读☀"></a>☀推荐阅读☀</h2><ul>
<li>……</li>
<li><a href="https://mp.weixin.qq.com/s/wnuqbgnS-D-U48XrxHKIvg" target="_blank" rel="noopener"><strong>5. 穿过拥挤的人潮，Spring已为你制作好高级赛道</strong></a></li>
<li><a href="https://mp.weixin.qq.com/s/9MPkCSM9AbsgKAFQ1eXBNQ" target="_blank" rel="noopener"><strong>6. 抹平差异，统一类型转换服务ConversionService</strong></a></li>
<li><a href="https://mp.weixin.qq.com/s/ENKwVqPE1cuOgE51ODJnnw" target="_blank" rel="noopener"><strong>7. JDK拍了拍你：字符串拼接一定记得用MessageFormat#format</strong></a></li>
<li>……</li>
</ul>]]></content>
      <categories>
        <category>A哥学数据校验</category>
      </categories>
      <tags>
        <tag>Converter</tag>
        <tag>Formatter</tag>
      </tags>
  </entry>
  <entry>
    <title>YourBatman 2020年感悟关键词：科比、裁员、管理层、活着</title>
    <url>/x2y/9705b9e8.html</url>
    <content><![CDATA[<p><img data-src="https://img-blog.csdnimg.cn/20201228204803912.png#pic_center" alt=""></p>
<blockquote>
<p>分享、成长，拒绝浅藏辄止。关注公号【<strong>BAT的乌托邦</strong>】，回复<code>专栏</code>获取原创专栏：重学Spring、重学MyBatis、中间件、云计算…本文已被 <a href="https://www.yourbatman.cn">https://www.yourbatman.cn</a> 收录。</p>
</blockquote>
<h1 id="本文提纲"><a href="#本文提纲" class="headerlink" title="本文提纲"></a>本文提纲</h1><p><img data-src="https://img-blog.csdnimg.cn/20201230160558413.png#pic_center" alt=""></p>
<blockquote>
<p>Tips：文末加了个奖励，<strong>阳光普照奖</strong>祛除2020阴霾，大步向前跨入2021</p>
</blockquote>
<h1 id="✍前言"><a href="#✍前言" class="headerlink" title="✍前言"></a>✍前言</h1><p>你好，我是A哥(YourBatman)。</p>
<p>2020年，庚子年，注定会在历史的长河里被深深记住。历史将怎样记载2020年？这是震慑之年，这是突破之年，也是转折之年。疫情之下，见证了人类的坚忍与脆弱、团结与分裂、担当与推诿，无知与无助。</p>
<p>每到年末，朋友圈、公众号、各大社区网站都会成为“成功人士”的show场，盘点自己这一年的成就、挣了多少钱、完成多少个小目标，为来年再立Flag……逛着逛着，一个不小心就被凡尔赛(灬ꈍ ꈍ灬)</p>
<p>2020眨眼就快结束了，你的<strong>年终复盘</strong>写好了吗？复盘的重要性到底是什么？你是否总在表表面面的，像记流水账一样的回顾自己过去做过的事、踩过的坑、取得的成绩敷衍了事，明年又重复一样的过程？而复盘<strong>真正的意义</strong>是让我们更了解自己，自己的短板在哪？该怎么补？通过自己学习还是通过整合资源互补，自己的价值在哪？如何放大，怎样被更多的人看到？实现自我成长的同时影响更多人~</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201231052037921.png#pic_center" alt=""></p>
<p>按照我自行约定的惯例，每年年末定心回首这一年，然后在<strong>最后一天</strong>留下些笔墨。可能不同于晒成绩show自己的那种文章，我更多是倾向于记录下自己的感悟，与你分享，共勉。</p>
<h2 id="版本约定"><a href="#版本约定" class="headerlink" title="版本约定"></a>版本约定</h2><ul>
<li>年份：2020</li>
</ul>
<h1 id="✍正文"><a href="#✍正文" class="headerlink" title="✍正文"></a>✍正文</h1><p>作为一个IT从业人员，我的视角自然和本圈分不开，所以可能狭隘，可能有偏见，可能不深刻，也可能有错误“”。若你有不同感悟，强烈建（欢）议（迎）你在文末留下你的文字，组团思考。</p>
<blockquote>
<p>说明：本文感悟来自于自己以及结合了几位职场老兵一起畅聊的总结</p>
</blockquote>
<hr>
<h2 id="科比"><a href="#科比" class="headerlink" title="科比"></a>科比</h2><p>科比事件，堪称是2020年给我触动最大，感触最深的一次事件。</p>
<p>美国当地时间2020年1月26号上午10点（北京时间：2020年1月27号凌晨2点）左右，NBA传奇巨星<strong>科比·布莱恩特</strong>于加利福尼亚州洛杉矶县卡拉巴萨斯的一场直升机坠机事故中身亡，年仅41岁。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201229111332751.png#pic_center" alt=""></p>
<p>那天是中国农历春节的大年初三，早上6点多我就朦朦胧的醒来，像平常一样睁眼第一件事便是拿起手机，关注关注疫情动态。可没想到，满屏的手机通知（标题大致都是：科比疑似坠机身亡。）让我<strong>元神</strong>瞬间归位。</p>
<p>从看见通知，到确认通知，我的心里状态起起伏伏，大致是这样变化的：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201229123504186.png#pic_center" alt=""></p>
<p>那会不愿去相信这是真事，从国内的新闻频道、朋友圈、微博，到<strong>搭梯子</strong>去外网求证，发现此新闻霸占了美国各大媒体头条：科比坠机事件坐实了。</p>
<p>所以这个纪念性的朋友圈也就有了，逝去的青春😭：</p>
<p><img data-src="https://img-blog.csdnimg.cn/2020123012554619.jpg#pic_center" alt=""></p>
<p>一时间，科比坠机事件瞬间席卷整个网络、微博、朋友圈。眼瞅2020年就快结束了，事情过去也将近一年。百度在12月中旬发布了2020年<strong>百度沸点</strong>，即使在如此不平凡的一年里，科比二字在<strong>年度关键词</strong>榜单中“高居”前10，<strong>年度泪点</strong>榜单中更是“高居”第三，影响力可见一斑：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201230125648246.png#pic_center" alt=""></p>
<p>天妒英才，可谁知那一句“<strong>Manba out</strong>”在2020年1月27日成为了永恒。</p>
<p>故人已逝，但科比的那份执念，那份曼巴精神永存，奉他为斯台普斯永远的王。关于老大流传的佳话、佳句、故事、遗憾实在太多太多，为了节约篇幅我在这就不做重复的搜集工作了。我相信广大读者不乏也有老大的死忠粉，期待留言区见。</p>
<p>综合全网，我个人<strong>有且仅</strong>向你推荐这一个小视频，3分钟时长剪辑版。<strong>不管你懂不懂篮球</strong>，都呼吁你安静的把它看完：2013年常规赛最后阶段，科比为了兑现把湖人送进季后赛的承诺，使尽全力，最终拼到脚跟建断裂，职业生涯就此遭遇滑铁卢，那个不服输精神，不甘心的眼神，令人动容。</p>
<p><strong><code>答应我 安静的看完科比跟腱断裂一战</code></strong><br><strong><code>答应我 安静的看完科比跟腱断裂一战</code></strong><br><strong><code>答应我 安静的看完科比跟腱断裂一战</code></strong></p>
<ul>
<li><strong>抖音观看</strong>（推荐此观看方式）</li>
</ul>
<p><img data-src="https://img-blog.csdnimg.cn/20201230135844487.jpg#pic_center" alt=""></p>
<ul>
<li>PC观看：<a href="https://www.xiaohongshu.com/discovery/item/5fc0adbf0000000001003117" target="_blank" rel="noopener">https://www.xiaohongshu.com/discovery/item/5fc0adbf0000000001003117</a></li>
</ul>
<h2 id="裁员"><a href="#裁员" class="headerlink" title="裁员"></a>裁员</h2><p>画风一转，咱们继续聊聊职场那些事。</p>
<p>犹记得2019年下半年，中国整个互联网圈一片“哀鸿遍野”的景象：小到初创公司，大到互联网寡头几乎无一幸免的进行了裁员，更有甚者“暴力裁员”。那会的空气中弥漫的裁员气氛不仅让很多人中枪，更是让那些“幸免者”也忧郁匆匆，人心惶惶，不可为不“热闹”。</p>
<p>本以为2020年会有所好转，可谁知新冠疫情这个黑天鹅事件爆发，更是冰上加霜。“裁员年年有，今年特别多”，真是不知道意外和裁员，哪个会先到来。没有什么是亘古不变的，你喜欢岁月静好，现实却波涛汹涌！</p>
<p><img data-src="https://img-blog.csdnimg.cn/2020122913372945.png#pic_center" alt=""></p>
<p>也许此时，对于企业，2020年甚至成为了生死之年；对于个人，职场中的人也都需要认真思考这个问题：<strong>我会被裁吗？</strong></p>
<h3 id="如何避免被裁？"><a href="#如何避免被裁？" class="headerlink" title="如何避免被裁？"></a>如何避免被裁？</h3><p>首先需要明确，裁员是企业断臂求生的<strong>最有效</strong>手段，在经济下滑的趋势下不可避免。</p>
<p>在企业上班的多数人都背着房贷、车贷、教育、养老等压力，倘若被裁员，恰恰是把人推向了更加艰难窘迫的境地。即使没有被裁员，面对将下来<strong>越来越严峻的形势</strong>，也非常令人担忧和不安。虽然暂时安稳，但这并不是长久的，毕竟你的饭碗不是铁铸造。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201229135732555.png#pic_center" alt=""></p>
<p>公司裁员的对象，大体上遵循这个规律：<strong>裁掉“性价比”低的员工</strong>。那么，什么是性价比？</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201229140350982.png#pic_center" alt=""></p>
<p>在企业里，你产生的价值、你的人脉圈、你的不可替代性决定了你的“<strong>性</strong>”（分子，也称价值），你的工资薪酬、你的职位层级、你的权利决定了你的“<strong>价</strong>”（分母，也称成本）。想要提高自己的性价比有这两条路可走：</p>
<ul>
<li><strong>减小分母</strong>：降薪、降级、降权利</li>
<li><strong>加大分子</strong>：多付出、扩大圈子、提升自身综合能力</li>
</ul>
<p>虽说有两条路子可选，但很明显<strong>减小分母</strong>这条路具有不可实操性。你选择降薪？还是选择降级？还是会自愿放弃权利呢？成年人哪会做这种选择题，肯定一个都不会选的嘛。</p>
<p>可更为残酷的现实是，被裁员的大都是“底层员工”，是无职级、无权利、无降薪空间的“<strong>三无员工</strong>”，分母连减小的空间都不存在。所以说减小分母这条路理论上可行，但不具备实操性，充其量当做退无可退的无奈之举。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201229225313883.png#pic_center" alt=""></p>
<p>别无选择，想屹立于职场只能pick第二条路：<strong>加大分子</strong>。如果说分母的改变具有一定被动性，那么分子的变化一切都由你主观决定。你可以选择为公司多付出（如996、10107），你也可努力成为公司那个不可或缺人（如掌握核心技术专利）。总之你的“命脉”掌握在你自己手上，多一份付出、多一点思考、多一些不可替代性都是可努力的方向。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201229225824703.png#pic_center" alt=""></p>
<p>既然<strong>加大分子</strong>这条路子能通过主观能动性来解决，那么下面就来唠几句，有哪些理论可以参考学习，甚至当作行为规范来用。</p>
<h4 id="1、不要迷恋管理，一味追求“当官”"><a href="#1、不要迷恋管理，一味追求“当官”" class="headerlink" title="1、不要迷恋管理，一味追求“当官”"></a>1、不要迷恋管理，一味追求“当官”</h4><p><img data-src="https://img-blog.csdnimg.cn/20201229230837240.png#pic_center" alt=""></p>
<p>中国人自古以来都有“官本位”的思想：在职场上混迹几年，如果不混个一官半职，就感觉挺丢人（无言面对父老乡亲）。有这种想法是完全可以被理解，甚至被普遍接受的，<strong>衣锦还乡</strong>说的就是这个情况。但绝大多数人对此都少了一个概念上的区别：事业单位or企业单位，体制内or体制外：</p>
<ul>
<li><strong>事业单位</strong>：只要不违法乱纪，不犯大的错误，乌纱帽这辈子就稳了</li>
<li><strong>企业单位</strong>（非国企）：失去职位的“机会”太多了。且不说公司内部的激烈斗争这方面，就算你总是能<strong>不湿鞋</strong>且八面玲珑的能应对各种关系，但是，你也控制不了你所在的团队、事业部、或者是行业的衰退。比如公司战略调整裁掉整个事业部，你不能说是因为你领导架构设计得不好；比如二手车行业不景气了，你不能说是因为你总监的能力不行</li>
</ul>
<p>迷恋管理本身没有任何错，毕竟<strong>下命令</strong>的快感是顺应人性的每个人期望得到。但是身处职场的我们，应该看清自己所处的单位性质、环境，然后控制好这个<strong>度</strong>，才能能游刃有余。</p>
<h4 id="2、别以为裁员只裁一线，不裁管理层"><a href="#2、别以为裁员只裁一线，不裁管理层" class="headerlink" title="2、别以为裁员只裁一线，不裁管理层"></a>2、别以为裁员只裁一线，不裁管理层</h4><p><img data-src="https://img-blog.csdnimg.cn/20201229231500197.png#pic_center" alt=""></p>
<p>从裁员的新闻中总结出规律，各公司裁员的目标人群基本保持一致：主要裁<strong>基层员工、基层管理、中层管理</strong>。为何裁的是这三类职位呢？其实这蛮好理解，这三类职位一般占据公司80%的人员甚至更多，站在企业的角度来看在这里“动手术”是最见效且是<strong>最安全</strong>的（人数多就不存在单点风险）。</p>
<p>所以误以为裁员只裁一线员工，不裁领导(管理层)是非常错误的观点，毕竟员工都没了，要“领导”又有何用呢？难道让1个领导管1名员工，甚至光杆司令？这明显违背了公司的“<strong>金字塔结构</strong>”嘛。</p>
<h4 id="3、即使步入管理，建议不要脱离技术"><a href="#3、即使步入管理，建议不要脱离技术" class="headerlink" title="3、即使步入管理，建议不要脱离技术"></a>3、即使步入管理，建议不要脱离技术</h4><p><img data-src="https://img-blog.csdnimg.cn/20201229232606343.png#pic_center" alt=""></p>
<p>不乏有很多人把<strong>不用写代码</strong>当作步入管理层的一个标志，其实这个是有很大误导性的。</p>
<p>舞蹈领域流传这么一句话：一天不练，自己知道！两天不练，同行知道！三天不练，观众知道！程序员又何尝不是呢，本行业内也盛传这么一句话：<strong>脱离技术，最多只用3年。而一旦脱离，就像断了头，捡起来的难度非常之大</strong>。</p>
<p>因此，即使已经步入管理，也不要把这条路走成一条<strong>断头路</strong>，尤其是在一日千里的IT领域，唯一不变的就是变化，甚至瞬息万变，所以埋头管理的同时，也得经常抬头看路（埋头写代码的同时，也别忘了抬头望望O(∩_∩)O哈哈~）。</p>
<h4 id="4、平台高-≠-能力强"><a href="#4、平台高-≠-能力强" class="headerlink" title="4、平台高 ≠ 能力强"></a>4、平台高 ≠ 能力强</h4><p><img data-src="https://img-blog.csdnimg.cn/20201229235920887.png#pic_center" alt=""></p>
<p>把时钟往前拨5年，从<strong>BAT</strong>跳出来面试的人是自带光环的，面试官自然而然的会高看你一眼，甚至职级评定、薪资上也是给得非常慷慨。就因为如此，那些年出现了非常多的先去大公司“<strong>镀金</strong>”的现象。也正因为如此，伴随着中国互联网的快速发展，这种镀过金的人越来越多，市场上鱼龙混杂，然后浑水摸鱼的现象级越来越常见了。</p>
<blockquote>
<p>我猜测：你现在或者曾经肯定吐槽过身边的同事前BAT员工，然后“我靠”一句：这也太菜了吧</p>
</blockquote>
<p>那企业招聘怎么办？？？很简单：一刀切呗（talk is cheap, show me the code）。时代在变迁，镀金思维几年前好用，现在已经过时了。需要保持时俱进，随时纠正自己。只有自己真的是铁，才不怕面试的三位真火，保持自己的核心竞争力才是屹立于市场之王道。<strong>能者上，平者让，庸者下</strong>，这是亘古不变的道理。</p>
<h4 id="5、跳出舒适区，居安思危"><a href="#5、跳出舒适区，居安思危" class="headerlink" title="5、跳出舒适区，居安思危"></a>5、跳出舒适区，居安思危</h4><p><img data-src="https://img-blog.csdnimg.cn/20201230001155639.png#pic_center" alt=""></p>
<p>在企业里混，在职场上混，永远没有谁是<strong>真正安全</strong>的，无论是做技术，还是做管理。舒适区呆着固然舒服，但很容易就被温水煮青蛙，一煮就煮到你35岁，慌不慌？</p>
<p>人生已经这么艰难了，没想到越来越难。本着居安思危，如履薄冰的态度，才能让自己一直保持可靠的竞争力。常出来看看，跳出舒适区，挑战些之外的东西，保持激情和热泪盈眶。</p>
<blockquote>
<p>说明：出来看看并不是指的跳槽，也可以是和牛人交流、参与公开项目、做公开演讲、直播等</p>
</blockquote>
<h4 id="6、技术转产品，也请确保技术扎实"><a href="#6、技术转产品，也请确保技术扎实" class="headerlink" title="6、技术转产品，也请确保技术扎实"></a>6、技术转产品，也请确保技术扎实</h4><p><img data-src="https://img-blog.csdnimg.cn/20201230052953276.png#pic_center" alt=""></p>
<p>坊间传闻，寡头企业阿里巴巴、腾讯等现在招聘产品经理，倾向于从技术流里面转的这种。阿里腾讯作为中国互联网企业的<strong>翘楚和领军</strong>，不客气的说它们的某些行为就是标准，就是规范。通过观念的慢慢渗透，其它中小企业会慢慢效仿，这或许就是将来的一种趋势~</p>
<p>技术转产品并不新鲜，甚至是一个很有“前景”的方向。毕竟靠技术没法“改变”世界，但产品可以。比如大家都非常熟悉的业界名人(国内)：张小龙、雷军、周鸿祎、马化腾……他们均为技术出生转向产品从而“改变”世界。在IT领域里，<strong>产品经理</strong>是个很容易被羡慕的工种：门槛低、工资高；压力小，不背锅；有假期，加班少……这些标签被贴上，广大程序员看后还不哗啦啦的流口水麽？可世间哪有那么好的事，远远没有空想的那么简单，毕竟简单的事做起来一般都不具价值的，做难事才有所得。</p>
<p>也许表面上看，从“幸福生活”的角度去这么思考无可厚非，产品经理的职位很容易就让旁人心生羡慕。但永远相信：<strong>人的选择可能会错，但社会的选择永远不会有误，适者生存</strong>。技术人转产品岗其实是一个比较好的归宿，可以间接绕过<strong>35岁</strong>魔咒，从此对年龄不再那么敏感和恐惧。但是，在<strong>纯技术和纯产品</strong>都受到了前所未有的挑战的现在，倘若真要转产品路线，也请做一个有扎实技术基础的产品经理，而不是仅仅为了“逃”到舒适区，否则很容易就被温水煮青蛙甚至直接淘汰。</p>
<hr>
<h2 id="管理层"><a href="#管理层" class="headerlink" title="管理层"></a>管理层</h2><p>2020年，中国的大多数企业都有一个共同感受：增长乏力。其实这个现象在去年就已经比较明显了，其核心原因可能有二：</p>
<ol>
<li>中国网民数量（9.4亿）已经饱和，流量红利期已彻底结束</li>
<li>既然再无增量市场，那就只能深挖存量市场，但这条路上布满荆棘</li>
</ol>
<p>增长是企业经营情况的晴雨表，增长快证明公司向好，有些问题也就不是问题。增长放缓伴随着的一般都会是带来变革，涉及到最重要的就是公司的领导班子，他们的战略制定、规则调整时时刻刻都和公司命运相关联。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201230054555656.png#pic_center" alt=""></p>
<p>随着时间推移和经验的积累，我们职业生涯中或许很多人会步入到管理层岗位。但是在增长乏力、大环境向下的时局下，对管理层这个岗位我们可能需要有更多的思考、更深刻的认知。手握“宝典”，方能尽可能的保全自己。</p>
<h3 id="更大危机感"><a href="#更大危机感" class="headerlink" title="更大危机感"></a>更大危机感</h3><p><img data-src="https://img-blog.csdnimg.cn/20201230055459285.png#pic_center" alt=""></p>
<p>对于基层员工来说，基本不与公司形成命运共同体，大不了换个坑就行了。但对于管理岗位来说，有必要建立起更大的危机感：对绝大多数<strong>中级管理者</strong>来说，无论是个人的价值，还是地位，都<strong>严重依赖于</strong>当前所在的组织/公司，以及赋予的title。一旦离开这个公司，失去了光鲜的“外表”和对应的title后，这些管理者就会瞬间失去所有光环，“裸露”在水面，大潮退去，就能知道到底谁在裸泳。</p>
<p>管理者一般相对“<strong>务虚</strong>”，所依赖的、擅长的往往是大家津津乐道的“<strong>软实力</strong>”，如沟通、协调、推动、PPT工程师、画图工程师……这些能力里面其实本身都没有问题，问题就在于这个“<strong>软</strong>”字，因为它不好展现，尤其你在面试的时候，所以很难结果导向的评估面试结果，很是吃亏。</p>
<blockquote>
<p>当然喽，你可能会说，管理层咋可能还现场这样面试？都是走的人脉圈子，那另当别论</p>
</blockquote>
<p>另外，对于管理岗来讲，招聘的需求一般是较少的，运气好的话还行可以很快遇到伯乐扶一把。若运气不佳，中层管理者一旦离开当前公司，市场价值很可能会出现<strong>断崖式</strong>下跌。反观技术人员，只要社会还在发展，企业对生产力还有需求，那么专业技术人员就不会彻底失业，再就业的概率也是很大、很快的。</p>
<p>在失去工作岗位后管理层和普通员工的区别也是蛮大的：管理层往往比普通员工更加悲惨，因为在大环境向下的时候，<strong>脱了毛的凤凰还不如鸡</strong>。况且<strong>由俭入奢易，由奢入俭难</strong>的思维必然亦会阻碍领导层再就业时的选择。</p>
<h3 id="更深刻行业认知"><a href="#更深刻行业认知" class="headerlink" title="更深刻行业认知"></a>更深刻行业认知</h3><p><img data-src="https://img-blog.csdnimg.cn/20201230061035693.png#pic_center" alt=""></p>
<p>能步入管理层，肯定是你身上那些优秀品质得以发挥效用。对于管理层而言，深刻的行业认知必不可少，最好能一针见血。下面举几个例子</p>
<h4 id="1、没有技术驱动型公司"><a href="#1、没有技术驱动型公司" class="headerlink" title="1、没有技术驱动型公司"></a>1、没有技术驱动型公司</h4><p><strong>世界上没有技术驱动型公司</strong>。</p>
<p>哪怕强如google，微软，亦或是国内的阿里、腾讯，都不是技术驱动型公司。道理很简单：<strong>技术不是源头，需求才是</strong>。而技术只是为了更好的去服务需求的一种工具而已~</p>
<p>一切技术问题，都要服从产品交付和市场反馈，所以客观的说，任何公司都不可能以技术去驱动自身。<strong>人可以用技术驱动自身，但公司不行</strong>。</p>
<p>不过，在市场经济下，以技术为<strong>导向</strong>的组织还有一个神秘的地方：研究院。它的特点是：不需要自己挣钱，所以没有生存压力，国家用纳税人的钱养着就成。</p>
<h4 id="2、最重要的是经验，而不是聪明"><a href="#2、最重要的是经验，而不是聪明" class="headerlink" title="2、最重要的是经验，而不是聪明"></a>2、最重要的是经验，而不是聪明</h4><p>作为技术从业者，有两个概念需要加以区分：<strong>IT领域</strong> vs <strong>科研领域</strong>。本文所讨论的范畴，那必然是IT领域。</p>
<p>IT领域的平均薪资经常性霸榜，再加上计算机经常被辅以“神秘”、“高大上”的标签，所以有种表面光鲜感觉。你大概率也许可能被老家的大叔大妈这样夸过：做IT做计算机的人都好聪明，脑子好使，巴拉巴拉…… 这个时候你可千万<strong>记住了</strong>，保持清醒，别被这种“幻觉”带跑偏，迷之自信了，否则这可能对你就是一个<strong>捧杀</strong>。</p>
<p>之前看到过一句非常经典的话在这分享给你：你做得好不好，不取决于你是否聪明，而取决于你是否愿意不断读书不断学习和不断积累。经常给自己泼泼冷水，能让自己更加清醒。</p>
<blockquote>
<p>真正聪明的人大都去搞科研去了，做IT的自嘲其实就是民工一枚嘛</p>
</blockquote>
<h4 id="3、技术栈一旦确定，就改不了"><a href="#3、技术栈一旦确定，就改不了" class="headerlink" title="3、技术栈一旦确定，就改不了"></a>3、技术栈一旦确定，就改不了</h4><p>IT是工科，不是理科，和IT行业相似度最高的行业是盖楼房，相似度惊人。写代码和盖楼是一样的，一旦<strong>地基框架</strong>都打好了，只有可能重新建一栋而不可能去重构它。</p>
<blockquote>
<p>此小标题本来有几乎二字（就几乎改不了），但我决定话说狠一点就给拿掉了，任性</p>
</blockquote>
<h4 id="4、学会一门语言，其它语言都差不多"><a href="#4、学会一门语言，其它语言都差不多" class="headerlink" title="4、学会一门语言，其它语言都差不多"></a>4、学会一门语言，其它语言都差不多</h4><p><strong>这是错误认知</strong>。这个观点其实是一个看起来正确，实则错误的一个认知。</p>
<p>我觉得，产生这种认知的大都出现在工作还只有几年的年轻从业者身上，这种选手的特点一般是自负、迷之自信，也就是对自我认知还不太够，并不太能深刻了解“<strong>你知道的越多，不知道的更多</strong>”这句话的深层含义。</p>
<p>也许这是一个技术广度 vs 技术深度的较量。其实每一个技术栈的size都太深了，你几乎不太可能去精通多个。正所谓<strong>基础不牢，地动山摇</strong>，所以选型确定根基很重要。业界有个极端的二八原则：花80%的时间做代码设计、画UML图、画时序图，20%的时间写code和debug~</p>
<p>别妄想着去<strong>追新</strong>一会搞这一会搞那，对于大多数人来说能把一门语言搞得比较通透就已经很难了，毕竟我们并不“聪明”。</p>
<hr>
<h2 id="活着"><a href="#活着" class="headerlink" title="活着"></a>活着</h2><p>我是湖北人，我喜欢科比，我喜欢梅西(link:马拉多纳)……</p>
<blockquote>
<p>湖北通山县，援鄂医疗队是<strong>云南省</strong>第二人民医院和大理大学第一附属医院的白衣天使们，特别特别感谢援助</p>
</blockquote>
<p>2020年，对这两个字有感，没有哪一年比今年更对“活着”有着深刻理解。<strong>除了生死，都是小事；过往纠葛，都是故事</strong>。金钱，在健康面前，不值一提，名利，在平安面前，啥都不是。我们不知道，明天和意外究竟谁先来，好好珍惜眼前，善待身边挚爱，余生不长，活着最重要。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201229133929289.png#pic_center" alt=""></p>
<h1 id="✍总结"><a href="#✍总结" class="headerlink" title="✍总结"></a>✍总结</h1><p><strong>今年是近十年最差的一年，却是将来十年最好的一年</strong>。与其忧心忡忡，惴惴不安，倒不如多多思考、多多学习。</p>
<p>最后想说一句：滚蛋吧，2020。虽然这句话说得毫不客气，但who care？毕竟2020对也没对咱客气过，不是麽！</p>
<h1 id="阳光普照奖"><a href="#阳光普照奖" class="headerlink" title="阳光普照奖"></a>阳光普照奖</h1><h3 id="奖品内容"><a href="#奖品内容" class="headerlink" title="奖品内容"></a>奖品内容</h3><ul>
<li>阳光普照奖：参与进来的同学<strong>都能得将</strong>，沾份喜气，共聚力量</li>
<li>红包奖：最直接的中奖，且不用等<strong>即开即中</strong>，直接放入余额</li>
</ul>
<p><img data-src="https://img-blog.csdnimg.cn/20201231081841699.jpg#pic_center" alt=""></p>
<h3 id="参与方式"><a href="#参与方式" class="headerlink" title="参与方式"></a>参与方式</h3><p>关注【BAT的乌托邦】，后台回复关键词：<strong><code>2020</code></strong> 获取到你的<strong>专属</strong>抽奖链接即可参与。</p>
<p><img data-src="https://img-blog.csdnimg.cn/2020123108204748.jpg#pic_center" alt=""></p>
<p>祛除2020阴霾，大步向前跨入2021。坚定信念，一往无前，加油，打工人！</p>]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>2020</tag>
        <tag>裁员</tag>
        <tag>科比</tag>
        <tag>活着</tag>
      </tags>
  </entry>
  <entry>
    <title>7. JDK拍了拍你：字符串拼接一定记得用MessageFormat#format</title>
    <url>/x2y/b6588179.html</url>
    <content><![CDATA[<p><img data-src="https://img-blog.csdnimg.cn/20201226172156506.png#pic_center" alt=""></p>
<blockquote>
<p>分享、成长，拒绝浅藏辄止。关注公号【<strong>BAT的乌托邦</strong>】，回复<code>专栏</code>获取原创专栏：重学Spring、重学MyBatis、中间件、云计算…本文已被 <a href="https://www.yourbatman.cn">https://www.yourbatman.cn</a> 收录。</p>
</blockquote>
<h1 id="✍前言"><a href="#✍前言" class="headerlink" title="✍前言"></a>✍前言</h1><p>你好，我是A哥(YourBatman)。本文所属专栏：<strong>Spring类型转换</strong>，公号后台回复专栏名即可获取全部内容。</p>
<p>在日常开发中，我们经常会有<strong>格式化</strong>的需求，如日期格式化、数字格式化、钱币格式化等等。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201221061443288.png#pic_center" alt=""></p>
<p>格式化器的作用似乎跟转换器的作用类似，但是它们的关注点却不一样：</p>
<ul>
<li>转换器：将类型S转换为类型T，关注的是类型而非格式</li>
<li>格式化器： String <code>&lt;-&gt;</code> Java类型。这么一看它似乎和<code>PropertyEditor</code>类似，但是它的关注点是字符串的<strong>格式</strong></li>
</ul>
<p>Spring有自己的格式化器抽象<code>org.springframework.format.Formatter</code>，但是谈到格式化器，必然就会联想起来JDK自己的<code>java.text.Format</code>体系。为后文做好铺垫，本文就先介绍下JDK为我们提供了哪些格式化能力。</p>
<h2 id="版本约定"><a href="#版本约定" class="headerlink" title="版本约定"></a>版本约定</h2><ul>
<li>JDK：8</li>
</ul>
<p><img data-src="https://img-blog.csdnimg.cn/2020122617255122.png#pic_center" alt=""></p>
<h1 id="✍正文"><a href="#✍正文" class="headerlink" title="✍正文"></a>✍正文</h1><p>Java里从来都缺少不了字符串拼接的活，JDK也提供了多种“工具”供我们使用，如：StringBuffer、StringBuilder以及最直接的<code>+</code>号，相信这些大家都有用过。但这都不是本文的内容，本文将讲解格式化器，给你提供一个新的思路来拼接字符串，并且是推荐方案。</p>
<p>JDK内置有格式化器，便是<code>java.text.Format</code>体系。它是个抽象类，提供了两个抽象方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Format</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> StringBuffer <span class="title">format</span><span class="params">(Object obj, StringBuffer toAppendTo, FieldPosition pos)</span></span>;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">parseObject</span> <span class="params">(String source, ParsePosition pos)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>format</strong>：将Object格式化为String，并将此String放到toAppendTo里面</li>
<li><strong>parseObject</strong>：讲String转换为Object，是format方法的逆向操作</li>
</ul>
<p>Java SE针对于Format抽象类对于常见的应用场景分别提供了三个子类实现：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201225063338484.png#pic_center" alt=""></p>
<h2 id="DateFormat：日期时间格式化"><a href="#DateFormat：日期时间格式化" class="headerlink" title="DateFormat：日期时间格式化"></a>DateFormat：日期时间格式化</h2><p>抽象类。用于用于格式化日期/时间类型<code>java.util.Date</code>。虽然是抽象类，但它提供了几个静态方法用于获取它的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 格式化日期 + 时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getDateTimeInstance(SHORT, SHORT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title">getDateTimeInstance</span><span class="params">(<span class="keyword">int</span> dateStyle, <span class="keyword">int</span> timeStyle, Locale aLocale)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(timeStyle, dateStyle, <span class="number">3</span>, aLocale);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式化日期</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title">getDateInstance</span><span class="params">(<span class="keyword">int</span> style, Locale aLocale)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(<span class="number">0</span>, style, <span class="number">2</span>, aLocale);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 格式化时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title">getTimeInstance</span><span class="params">(<span class="keyword">int</span> style, Locale aLocale)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(style, <span class="number">0</span>, <span class="number">1</span>, aLocale);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://img-blog.csdnimg.cn/20201225063820907.png#pic_center" alt=""></p>
<p>有了这些静态方法，你可在<strong>不必关心</strong>具体实现的情况下直接使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> DateFormat&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Date curr = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 格式化日期 + 时间</span></span><br><span class="line">    System.out.println(DateFormat.getInstance().getClass() + <span class="string">"--&gt;"</span> + DateFormat.getInstance().format(curr));</span><br><span class="line">    System.out.println(DateFormat.getDateTimeInstance().getClass() + <span class="string">"--&gt;"</span> + DateFormat.getDateTimeInstance().format(curr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 格式化日期</span></span><br><span class="line">    System.out.println(DateFormat.getDateInstance().getClass() + <span class="string">"--&gt;"</span> + DateFormat.getDateInstance().format(curr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 格式化时间</span></span><br><span class="line">    System.out.println(DateFormat.getTimeInstance().getClass() + <span class="string">"--&gt;"</span> + DateFormat.getTimeInstance().format(curr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">class java.text.SimpleDateFormat--&gt;20-12-25 上午7:19</span><br><span class="line">class java.text.SimpleDateFormat--&gt;2020-12-25 7:19:30</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">text</span>.<span class="title">SimpleDateFormat</span>--&gt;2020-12-25</span></span><br><span class="line">class java.text.SimpleDateFormat--&gt;7:19:30</span><br></pre></td></tr></table></figure>
<p>嗯，可以看到底层实现其实是咱们熟悉的<code>SimpleDateFormat</code>。实话说，这种做法不常用，狠一点：基本不会用（框架开发者可能会用做兜底实现）。</p>
<h3 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h3><p>一般来说，我们会直接使用<code>SimpleDateFormat</code>来对Date进行格式化，它可以自己指定Pattern，个性化十足。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>); <span class="comment">// yyyy-MM-dd HH:mm:ss</span></span><br><span class="line">    System.out.println(dateFormat.format(<span class="keyword">new</span> Date()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span>-<span class="number">12</span>-<span class="number">25</span></span><br></pre></td></tr></table></figure>
<p>关于<code>SimpleDateFormat</code>的使用方式不再啰嗦，不会的就可走自行劝退手续了。此处只提醒一点：<strong>SimpleDateFormat线程不安全</strong>。</p>
<blockquote>
<p>说明：JDK 8以后不再建议使用Date类型，也就不会再使用到DateFormat。同时我个人建议：在项目中可<strong>强制</strong>严令禁用</p>
</blockquote>
<h2 id="NumberFormat：数字格式化"><a href="#NumberFormat：数字格式化" class="headerlink" title="NumberFormat：数字格式化"></a>NumberFormat：数字格式化</h2><p>抽象类。用于格式化数字，它可以对数字进行任意格式化，如小数、百分数、十进制数等等。它有两个实现类：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201226104107361.png#pic_center" alt=""></p>
<p>类结构和DateFormat类似，也提供了<code>getXXXInstance</code>静态方法给你直接使用，无需关心底层实现：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201225072829183.png#pic_center" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test41</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> myNum = <span class="number">1220.0455</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(NumberFormat.getInstance().getClass() + <span class="string">"--&gt;"</span> + NumberFormat.getInstance().format(myNum));</span><br><span class="line">    System.out.println(NumberFormat.getCurrencyInstance().getClass() + <span class="string">"--&gt;"</span> + NumberFormat.getCurrencyInstance().format(myNum));</span><br><span class="line">    System.out.println(NumberFormat.getIntegerInstance().getClass() + <span class="string">"--&gt;"</span> + NumberFormat.getIntegerInstance().format(myNum));</span><br><span class="line">    System.out.println(NumberFormat.getNumberInstance().getClass() + <span class="string">"--&gt;"</span> + NumberFormat.getNumberInstance().format(myNum));</span><br><span class="line">    System.out.println(NumberFormat.getPercentInstance().getClass() + <span class="string">"--&gt;"</span> + NumberFormat.getPercentInstance().format(myNum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">text</span>.<span class="title">DecimalFormat</span>--&gt;1,220.045</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">java</span>.<span class="title">text</span>.<span class="title">DecimalFormat</span>--&gt;￥1,220.05</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">java</span>.<span class="title">text</span>.<span class="title">DecimalFormat</span>--&gt;1,220</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">java</span>.<span class="title">text</span>.<span class="title">DecimalFormat</span>--&gt;1,220.045</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">java</span>.<span class="title">text</span>.<span class="title">DecimalFormat</span>--&gt;122,005%</span></span><br></pre></td></tr></table></figure>
<p>这一看就知道DecimalFormat是NumberFormat的主力了。</p>
<h3 id="DecimalFormat"><a href="#DecimalFormat" class="headerlink" title="DecimalFormat"></a>DecimalFormat</h3><p>Decimal：小数，小数的，十进位的。</p>
<p>用于格式化<strong>十进制数字</strong>。它具有各种特性，可以解析和格式化数字，包括：西方数字、<strong>阿拉伯数字</strong>和印度数字。它还支持不同种类的数字，包括：整数(123)、小数(123.4)、科学记数法(1.23E4)、百分数(12%)和<strong>货币</strong>金额($123)。所有这些都可以进行本地化。</p>
<p>下面是它的构造器：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201226104953453.png#pic_center" alt=""></p>
<p>其中最为重要的就是这个pattern（不带参数的构造器一般不会用），它表示格式化的模式/模版。一般来说我们对DateFormat的pattern比较熟悉，但对数字格式化的模版符号了解甚少。这里我就帮你整理出这个表格（信息源自JDK官网），记得搜藏哦：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>Localtion</th>
<th>是否本地化</th>
<th>释义</th>
</tr>
</thead>
<tbody><tr>
<td><code>0</code></td>
<td>Number</td>
<td>是</td>
<td>Digit</td>
</tr>
<tr>
<td><code>#</code></td>
<td>Number</td>
<td>是</td>
<td>Digit。若是0就显示为空</td>
</tr>
<tr>
<td><code>.</code></td>
<td>Number</td>
<td>是</td>
<td>小数/货币分隔符</td>
</tr>
<tr>
<td><code>-</code></td>
<td>Number</td>
<td>是</td>
<td>就代表减号</td>
</tr>
<tr>
<td><code>,</code></td>
<td>Number</td>
<td>是</td>
<td>分组分隔符</td>
</tr>
<tr>
<td><code>E</code></td>
<td>Number</td>
<td>是</td>
<td>科学计数法分隔符（位数和指数）</td>
</tr>
<tr>
<td><code>%</code></td>
<td>前/后缀</td>
<td>是</td>
<td>乘以100并显示为百分数</td>
</tr>
<tr>
<td><code>¤</code></td>
<td>前/后缀</td>
<td>否</td>
<td>货币记号。若连续出现两次就用国际货币符号代替</td>
</tr>
<tr>
<td><code>&#39;</code></td>
<td>前后缀</td>
<td>否</td>
<td>用于引用特殊字符。作用类似于转义字符</td>
</tr>
</tbody></table>
<blockquote>
<p>说明：Number和Digit的区别：</p>
<ul>
<li>Number是个抽象概念，其表达形式可以是数字、手势、声音等等。如1024就是个number</li>
<li>Digit是用来表达的<strong>单独符号</strong>。如0-9这是个digit就可以用来表示number，如1024就是由1、0、2、4这四个digit组成的</li>
</ul>
</blockquote>
<p>看了这个表格的符号规则，估计很多同学还是一脸懵逼。不啰嗦了，上干货</p>
<h4 id="一、0和-的使用（最常见使用场景）"><a href="#一、0和-的使用（最常见使用场景）" class="headerlink" title="一、0和#的使用（最常见使用场景）"></a>一、0和#的使用（最常见使用场景）</h4><p>这是<strong>最经典、最常见</strong>的使用场景，甚至来说你有可能职业生涯<strong>只</strong>会用到此场景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> DecimalFormat&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> myNum = <span class="number">1220.0455</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"===============0的使用==============="</span>);</span><br><span class="line">    System.out.println(<span class="string">"只保留整数部分："</span> + <span class="keyword">new</span> DecimalFormat(<span class="string">"0"</span>).format(myNum));</span><br><span class="line">    System.out.println(<span class="string">"保留3位小数："</span> + <span class="keyword">new</span> DecimalFormat(<span class="string">"0.000"</span>).format(myNum));</span><br><span class="line">    System.out.println(<span class="string">"整数部分、小数部分都5位。不够的都用0补位(整数高位部，小数低位补)："</span> + <span class="keyword">new</span> DecimalFormat(<span class="string">"00000.00000"</span>).format(myNum));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"===============#的使用==============="</span>);</span><br><span class="line">    System.out.println(<span class="string">"只保留整数部分："</span> + <span class="keyword">new</span> DecimalFormat(<span class="string">"#"</span>).format(myNum));</span><br><span class="line">    System.out.println(<span class="string">"保留2为小数并以百分比输出："</span> + <span class="keyword">new</span> DecimalFormat(<span class="string">"#.##%"</span>).format(myNum));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非标准数字（不建议这么用）</span></span><br><span class="line">    System.out.println(<span class="string">"===============非标准数字的使用==============="</span>);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> DecimalFormat(<span class="string">"666"</span>).format(myNum));</span><br><span class="line">    System.out.println(<span class="keyword">new</span> DecimalFormat(<span class="string">".6666"</span>).format(myNum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">===============<span class="number">0</span>的使用===============</span><br><span class="line">只保留整数部分：<span class="number">1220</span></span><br><span class="line">保留<span class="number">3</span>位小数：<span class="number">1220.045</span></span><br><span class="line">整数部分、小数部分都<span class="number">5</span>位。不够的都用<span class="number">0</span>补位(整数高位部，小数低位补)：<span class="number">01220.04550</span></span><br><span class="line">===============#的使用===============</span><br><span class="line">只保留整数部分：<span class="number">1220</span></span><br><span class="line">保留<span class="number">2</span>为小数并以百分比输出：<span class="number">122004.55</span>%</span><br><span class="line">===============非标准数字的使用===============</span><br><span class="line"><span class="number">661220</span></span><br><span class="line"><span class="number">1220.666</span></span><br></pre></td></tr></table></figure>
<p>通过此案例，大致可得出如下结论：</p>
<ul>
<li>整数部分：<ul>
<li>0和#都可用于取出全部整数部分</li>
<li>0的个数决定整数部分长度，不够高位补0；#则无此约束，N多个#是一样的效果</li>
</ul>
</li>
<li>小数部分：<ul>
<li>可保留小数点后N位(0和#效果一样)</li>
<li>若小数点后位数不够，若使用的0那就低位补0，若使用#就不补（该是几位就是几位）</li>
</ul>
</li>
<li>数字(1-9)：并不建议模版里直接写1-9这样的数字，了解下即可</li>
</ul>
<h4 id="二、科学计数法E"><a href="#二、科学计数法E" class="headerlink" title="二、科学计数法E"></a>二、科学计数法E</h4><p>如果你不是在证券/银行行业，这个大概率是用不着的（即使在，你估计也不会用它）。来几个例子感受一把就成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> myNum = <span class="number">1220.0455</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="keyword">new</span> DecimalFormat(<span class="string">"0E0"</span>).format(myNum));</span><br><span class="line">    System.out.println(<span class="keyword">new</span> DecimalFormat(<span class="string">"0E00"</span>).format(myNum));</span><br><span class="line">    System.out.println(<span class="keyword">new</span> DecimalFormat(<span class="string">"00000E00000"</span>).format(myNum));</span><br><span class="line">    System.out.println(<span class="keyword">new</span> DecimalFormat(<span class="string">"#E0"</span>).format(myNum));</span><br><span class="line">    System.out.println(<span class="keyword">new</span> DecimalFormat(<span class="string">"#E00"</span>).format(myNum));</span><br><span class="line">    System.out.println(<span class="keyword">new</span> DecimalFormat(<span class="string">"#####E00000"</span>).format(myNum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1E3</span></span><br><span class="line"><span class="number">1E03</span></span><br><span class="line"><span class="number">12200E-00001</span></span><br><span class="line">.<span class="number">1E4</span></span><br><span class="line">.<span class="number">1E04</span></span><br><span class="line"><span class="number">1220E00000</span></span><br></pre></td></tr></table></figure>

<h4 id="三、分组分隔符"><a href="#三、分组分隔符" class="headerlink" title="三、分组分隔符,"></a>三、分组分隔符,</h4><p>分组分隔符比较常用，它就是我们常看到的逗号<code>,</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> myNum = <span class="number">1220.0455</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="keyword">new</span> DecimalFormat(<span class="string">",###"</span>).format(myNum));</span><br><span class="line">    System.out.println(<span class="keyword">new</span> DecimalFormat(<span class="string">",##"</span>).format(myNum));</span><br><span class="line">    System.out.println(<span class="keyword">new</span> DecimalFormat(<span class="string">",##"</span>).format(<span class="number">123456789</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分隔符,左边是无效的</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> DecimalFormat(<span class="string">"###,##"</span>).format(myNum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">220</span></span><br><span class="line"><span class="number">12</span>,<span class="number">20</span></span><br><span class="line"><span class="number">1</span>,<span class="number">23</span>,<span class="number">45</span>,<span class="number">67</span>,<span class="number">89</span></span><br><span class="line"><span class="number">12</span>,<span class="number">20</span></span><br></pre></td></tr></table></figure>

<h4 id="四、百分号"><a href="#四、百分号" class="headerlink" title="四、百分号%"></a>四、百分号%</h4><p>在展示层面也比较常用，用于把一个数字用%形式表示出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test42</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> myNum = <span class="number">1220.0455</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"百分位表示："</span> + <span class="keyword">new</span> DecimalFormat(<span class="string">"#.##%"</span>).format(myNum));</span><br><span class="line">    System.out.println(<span class="string">"千分位表示："</span> + <span class="keyword">new</span> DecimalFormat(<span class="string">"#.##\u2030"</span>).format(myNum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">百分位表示：<span class="number">122004.55</span>%</span><br><span class="line">千分位表示：<span class="number">1220045.5</span>‰</span><br></pre></td></tr></table></figure>

<h4 id="五、本地货币符号¤"><a href="#五、本地货币符号¤" class="headerlink" title="五、本地货币符号¤"></a>五、本地货币符号¤</h4><p>嗯，这个符号<code>¤</code>，键盘竟无法直接输出，得使用软键盘（建议使用copy大法）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> myNum = <span class="number">1220.0455</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="keyword">new</span> DecimalFormat(<span class="string">",000.00¤"</span>).format(myNum));</span><br><span class="line">    System.out.println(<span class="keyword">new</span> DecimalFormat(<span class="string">",000.¤00"</span>).format(myNum));</span><br><span class="line">    System.out.println(<span class="keyword">new</span> DecimalFormat(<span class="string">"¤,000.00"</span>).format(myNum));</span><br><span class="line">    System.out.println(<span class="keyword">new</span> DecimalFormat(<span class="string">"¤,000.¤00"</span>).format(myNum));</span><br><span class="line">    <span class="comment">// 世界货币表达形式</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> DecimalFormat(<span class="string">",000.00¤¤"</span>).format(myNum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">220.05</span>￥</span><br><span class="line"><span class="number">1</span>,<span class="number">220.05</span>￥</span><br><span class="line">￥<span class="number">1</span>,<span class="number">220.05</span></span><br><span class="line"><span class="number">1</span>,<span class="number">220.05</span>￥￥</span><br><span class="line">￥<span class="number">1</span>,<span class="number">220.05</span>￥</span><br><span class="line"><span class="number">1</span>,<span class="number">220.05</span>CNY</span><br></pre></td></tr></table></figure>
<p>注意最后一条结果：如果连续出现两次，代表货币符号的国际代号。</p>
<blockquote>
<p>说明：结果默认都做了Locale本地化处理的，若你在其它国家就不会再是￥人名币符号喽</p>
</blockquote>
<p>DecimalFormat就先介绍到这了，其实掌握了它就基本等于掌握了NumberFormat。接下来再简要看看它另外一个“儿子”：ChoiceFormat。</p>
<h3 id="ChoiceFormat"><a href="#ChoiceFormat" class="headerlink" title="ChoiceFormat"></a>ChoiceFormat</h3><p>Choice：精选的，仔细推敲的。</p>
<p>这个格式化器非常有意思：<strong>相当于以数字为键，字符串为值的键值对</strong>。使用一组double类型的数组作为键，一组String类型的数组作为值，两数组相同（不一定必须是相同，见示例）索引值的元素作为一对。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span>[] limits = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    String[] formats = &#123;<span class="string">"周一"</span>, <span class="string">"周二"</span>, <span class="string">"周三"</span>, <span class="string">"周四"</span>, <span class="string">"周五"</span>, <span class="string">"周六"</span>, <span class="string">"周天"</span>&#125;;</span><br><span class="line">    NumberFormat numberFormat = <span class="keyword">new</span> ChoiceFormat(limits, formats);</span><br><span class="line"></span><br><span class="line">    System.out.println(numberFormat.format(<span class="number">1</span>));</span><br><span class="line">    System.out.println(numberFormat.format(<span class="number">4.3</span>));</span><br><span class="line">    System.out.println(numberFormat.format(<span class="number">5.8</span>));</span><br><span class="line">    System.out.println(numberFormat.format(<span class="number">9.1</span>));</span><br><span class="line">    System.out.println(numberFormat.format(<span class="number">11</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">周一</span><br><span class="line">周四</span><br><span class="line">周五</span><br><span class="line">周天</span><br><span class="line">周天</span><br></pre></td></tr></table></figure>
<p>结果解释：</p>
<ol>
<li>4.3位于4和5之间，取值4；5.8位于5和6之间，取值5</li>
<li>9.1和11均超过了数组最大值（或者说找不到匹配的），则取值<strong>最后一对键值对</strong>。</li>
</ol>
<p>可能你会想这有什么使用场景？？？是的，不得不承认它的使用场景较少，本文下面会介绍下它和<code>MessageFormat</code>的一个使用场景。</p>
<p>如果说<code>DateFormat</code>和<code>NumberFormat</code>都用没什么花样，主要记住它的pattern语法格式就成，那么就下来这个格式化器就是本文的主菜了，使用场景非常的广泛，它就是<code>MessageFormat</code>。</p>
<h2 id="MessageFormat：字符串格式化"><a href="#MessageFormat：字符串格式化" class="headerlink" title="MessageFormat：字符串格式化"></a>MessageFormat：字符串格式化</h2><p>MessageFormat提供了一种<strong>与语言无关</strong>（不管你在中国还是其它国家，效果一样）的方式生成<strong>拼接消息/拼接字符串</strong>的方法。使用它来构造显示给最终用户的消息。MessageFormat接受一组对象，对它们进行格式化，然后在模式的适当位置<strong>插入</strong>格式化的字符串。</p>
<p>先来个最简单的使用示例体验一把：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> MessageFormat&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String sourceStrPattern = <span class="string">"Hello &#123;0&#125;,my name is &#123;1&#125;"</span>;</span><br><span class="line">    Object[] args = <span class="keyword">new</span> Object[]&#123;<span class="string">"girl"</span>, <span class="string">"YourBatman"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    String formatedStr = MessageFormat.format(sourceStrPattern, args);</span><br><span class="line">    System.out.println(formatedStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hello girl,my name is YourBatman</span><br></pre></td></tr></table></figure>
<p>有没有中似曾相似的感觉，是不是和<code>String.format()</code>的作用特别像？是的，它俩的用法区别，到底使用税文下也会讨论。</p>
<p>要熟悉MessageFormat的使用，主要是要熟悉它的参数模式（你也可以理解为pattern）。</p>
<h3 id="参数模式"><a href="#参数模式" class="headerlink" title="参数模式"></a>参数模式</h3><p>MessageFormat采用<code>{}</code>来标记需要被<strong>替换/插入</strong>的部分，其中<code>{}</code>里面的参数结构具有一定模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArgumentIndex[,FormatType[,FormatStyle]]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ArgumentIndex</code>：<strong>非必须</strong>。从<code>0</code>开始的索引值</li>
<li><code>FormatType</code>：<strong>非必须</strong>。使用不同的<code>java.text.Format</code>实现类对入参进行格式化处理。它能有如下值：<ul>
<li>number：调用NumberFormat进行格式化</li>
<li>date：调用DateFormat进行格式化</li>
<li>time：调用DateFormat进行格式化</li>
<li><strong>choice</strong>：调用ChoiceFormat进行格式化</li>
</ul>
</li>
<li><code>FormatStyle</code>：<strong>非必须</strong>。设置FormatType使用的样式。它能有如下值：<ul>
<li>short、medium、long、full、integer、currency、percent、<strong>SubformPattern（如日期格式、数字格式#.##等）</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>说明：FormatType和FormatStyle只有在传入值为日期时间、数字、百分比等类型时才有可能需要设置，使用得并不多。毕竟：我在外部格式化好后再放进去不香吗？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MessageFormat messageFormat = <span class="keyword">new</span> MessageFormat(<span class="string">"Hello, my name is &#123;0&#125;. I’am &#123;1,number,#.##&#125; years old. Today is &#123;2,date,yyyy-MM-dd HH:mm:ss&#125;"</span>);</span><br><span class="line">    <span class="comment">// 亦可通过编程式 显示指定某个位置要使用的格式化器</span></span><br><span class="line">    <span class="comment">// messageFormat.setFormatByArgumentIndex(1, new DecimalFormat("#.###"));</span></span><br><span class="line"></span><br><span class="line">    System.out.println(messageFormat.format(<span class="keyword">new</span> Object[]&#123;<span class="string">"YourBatman"</span>, <span class="number">24.123456</span>, <span class="keyword">new</span> Date()&#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hello, my name is YourBatman. I’am <span class="number">24.12</span> years old. Today is <span class="number">2020</span>-<span class="number">12</span>-<span class="number">26</span> <span class="number">15</span>:<span class="number">24</span>:<span class="number">28</span></span><br></pre></td></tr></table></figure>
<p>它既可以直接在模版里指定格式化模式类型，也可以通过API方法set指定格式化器，当然你也可以再外部格式化好后再放进去，三种方式均可，任君选择。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>下面基于此示例，对MessageFormat的使用注意事项作出几点强调。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test11</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(MessageFormat.format(<span class="string">"&#123;1&#125; - &#123;1&#125;"</span>, <span class="keyword">new</span> Object[]&#123;<span class="number">1</span>&#125;)); <span class="comment">// &#123;1&#125; - &#123;1&#125;</span></span><br><span class="line">    System.out.println(MessageFormat.format(<span class="string">"&#123;0&#125; - &#123;1&#125;"</span>, <span class="keyword">new</span> Object[]&#123;<span class="number">1</span>&#125;)); <span class="comment">// 输出：1 - &#123;1&#125;</span></span><br><span class="line">    System.out.println(MessageFormat.format(<span class="string">"&#123;0&#125; - &#123;1&#125;"</span>, <span class="keyword">new</span> Object[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)); <span class="comment">// 输出：1 - 2</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"---------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(MessageFormat.format(<span class="string">"'&#123;0&#125; - &#123;1&#125;"</span>, <span class="keyword">new</span> Object[]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;)); <span class="comment">// 输出：&#123;0&#125; - &#123;1&#125;</span></span><br><span class="line">    System.out.println(MessageFormat.format(<span class="string">"''&#123;0&#125; - &#123;1&#125;"</span>, <span class="keyword">new</span> Object[]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;)); <span class="comment">// 输出：'1 - 2</span></span><br><span class="line">    System.out.println(MessageFormat.format(<span class="string">"'&#123;0&#125;' - &#123;1&#125;"</span>, <span class="keyword">new</span> Object[]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;)); <span class="comment">// &#123;0&#125; - 2</span></span><br><span class="line">    <span class="comment">// 若你数据库值两边都需要''包起来，请你这么写</span></span><br><span class="line">    System.out.println(MessageFormat.format(<span class="string">"''&#123;0&#125;'' - &#123;1&#125;"</span>, <span class="keyword">new</span> Object[]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;)); <span class="comment">// '1' - 2</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"---------------------------------"</span>);</span><br><span class="line">    System.out.println(MessageFormat.format(<span class="string">"0&#125; - &#123;1&#125;"</span>, <span class="keyword">new</span> Object[]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;)); <span class="comment">// 0&#125; - 2</span></span><br><span class="line">    System.out.println(MessageFormat.format(<span class="string">"&#123;0 - &#123;1&#125;"</span>, <span class="keyword">new</span> Object[]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;)); <span class="comment">// java.lang.IllegalArgumentException: Unmatched braces in the pattern.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>参数模式的索引值<strong>必须</strong>从0开始，否则所有索引值无效</li>
<li>实际传入的参数个数可以和索引个数不匹配，不报错（能匹配上几个算几个）</li>
<li>两个单引号<code>&#39;&#39;</code>才算作一个<code>&#39;</code>，若只写一个将被忽略甚至影响整个表达式<ol>
<li>谨慎使用单引号<code>&#39;</code></li>
<li>关注<code>&#39;</code>的匹配关系</li>
</ol>
</li>
<li><code>{}</code>只写左边报错，只写右边正常输出（注意参数的对应关系）</li>
</ol>
<h3 id="static方法的性能问题"><a href="#static方法的性能问题" class="headerlink" title="static方法的性能问题"></a>static方法的性能问题</h3><p>我们知道<code>MessageFormat</code>提供有一个static静态方法，非常方便的的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">format</span><span class="params">(String pattern, Object ... arguments)</span> </span>&#123;</span><br><span class="line">    MessageFormat temp = <span class="keyword">new</span> MessageFormat(pattern);</span><br><span class="line">    <span class="keyword">return</span> temp.format(arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以清晰看到，该静态方法<strong>本质上</strong>还是构造了一个<code>MessageFormat</code>实例去做格式化的。因此：若你要多次（如高并发场景）格式化<strong>同一个模版</strong>（参数可不一样）的话，那么提前创建好一个<strong>全局的</strong>（非static） MessageFormat实例再执行格式化是最好的，而非一直调用其静态方法。</p>
<blockquote>
<p>说明：若你的系统非高并发场景，此性能损耗基本无需考虑哈，怎么方便怎么来。毕竟<strong>朝生夕死</strong>的对象对JVM来说没啥压力</p>
</blockquote>
<h3 id="和String-format选谁？"><a href="#和String-format选谁？" class="headerlink" title="和String.format选谁？"></a>和String.format选谁？</h3><p>二者都能用于字符串拼接（格式化）上，撇开MessageFormat支持各种模式不说，我们只需要考虑它俩的性能上差异。</p>
<ul>
<li><strong>MeesageFormat</strong>：先分析（模版可提前分析，且可以只分析一次），再在指定位置上插入相应的值<ul>
<li>分析：遍历字符串，维护一个<code>{}</code>数组并记录位置</li>
<li>填值</li>
</ul>
</li>
<li><strong>String.format</strong>：该静态方法是采用运行时用<strong>正则表达式</strong> 匹配到占位符，然后执行替换的<ul>
<li>正则表达式为<code>&quot;%(\\d+\\$)?([-#+ 0,(\\&lt;]*)?(\\d+)?(\\.\\d+)?([tT])?([a-zA-Z%])&quot;</code></li>
<li>根据正则匹配到占位符列表和位置，然后填值</li>
</ul>
</li>
</ul>
<p>一说到正则表达式，我心里就发触，因为它对性能是<strong>不友好</strong>的，所以孰优孰劣，高下立判。</p>
<blockquote>
<p>说明：还是那句话，没有绝对的谁好谁坏，如果你的系统对性能不敏感，那就是方便第一</p>
</blockquote>
<h3 id="经典使用场景"><a href="#经典使用场景" class="headerlink" title="经典使用场景"></a>经典使用场景</h3><p>这个就很多啦，最常见的有：HTML拼接、SQL拼接、异常信息拼接等等。</p>
<p>比如下面这个SQL拼接：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder sb =<span class="keyword">new</span> StringBuilder();</span><br><span class="line">sb.append(<span class="string">"insert into user ("</span>);</span><br><span class="line">sb.append(<span class="string">"		name,"</span>);</span><br><span class="line">sb.append(<span class="string">"		accountId,"</span>);</span><br><span class="line">sb.append(<span class="string">"		zhName,"</span>);</span><br><span class="line">sb.append(<span class="string">"		enname,"</span>);</span><br><span class="line">sb.append(<span class="string">"		status"</span>);</span><br><span class="line">sb.append(<span class="string">") values ("</span>);</span><br><span class="line">sb.append(<span class="string">"		''&#123;0&#125;'',"</span>);</span><br><span class="line">sb.append(<span class="string">"		&#123;1&#125;,"</span>);</span><br><span class="line">sb.append(<span class="string">"		''&#123;2&#125;'',"</span>);</span><br><span class="line">sb.append(<span class="string">"		''&#123;3&#125;'',"</span>);</span><br><span class="line">sb.append(<span class="string">"		&#123;4&#125;,"</span>);</span><br><span class="line">sb.append(<span class="string">")"</span>);</span><br><span class="line"></span><br><span class="line">Object[] args = &#123;name, accountId, zhName, enname, status&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终SQL</span></span><br><span class="line">String sql = MessageFormat.format(sb.toString(), arr);</span><br></pre></td></tr></table></figure>
<p>你看，多工整。</p>
<blockquote>
<p>说明：如果值是字符串需要<code>&#39;</code>包起来，那么请使用两边各两个包起来</p>
</blockquote>
<h1 id="✍总结"><a href="#✍总结" class="headerlink" title="✍总结"></a>✍总结</h1><p>本文内容介绍了JDK原生的格式化器知识点，主要作用在这三个方面：</p>
<ul>
<li><strong>DateFormat</strong>：日期时间格式化</li>
<li><strong>NumberFormat</strong>：数字格式化</li>
<li><strong>MessageFormat</strong>：字符串格式化</li>
</ul>
<p>Spring是直接面向使用者的框架产品，很显然这些是不够用的，并且JDK的格式化器在设计上存在一些弊端。比如经常被吐槽的：日期/时间类型格式化器<code>SimpleDateFormat</code>为毛在java.text包里，而它格式化的类型Date却在java.util包内，这实为不合适。</p>
<p>有了JDK格式化器作为基础，下篇我们就可以浩浩荡荡的走进Spring格式化器的大门了，看看它是如何优于JDK进行设计和抽象的。</p>
<hr>
<h3 id="✔✔✔推荐阅读✔✔✔"><a href="#✔✔✔推荐阅读✔✔✔" class="headerlink" title="✔✔✔推荐阅读✔✔✔"></a>✔✔✔推荐阅读✔✔✔</h3><p>【Spring类型转换】系列：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/5daOOdhIFqrGbpgtnuQMNw" target="_blank" rel="noopener">1. 揭秘Spring类型转换 - 框架设计的基石</a></li>
<li><a href="https://mp.weixin.qq.com/s/Afu8YYyREoynAXS6YrJe7g" target="_blank" rel="noopener">2. Spring早期类型转换，基于PropertyEditor实现</a></li>
<li><a href="https://mp.weixin.qq.com/s/--UO3pH1nxTW3f5nQvEnkg" target="_blank" rel="noopener">3. 搞定收工，PropertyEditor就到这</a></li>
<li><a href="https://mp.weixin.qq.com/s/SMKs3fYoJm1Dfpy-6m_9ZQ" target="_blank" rel="noopener">4. 上新了Spring，全新一代类型转换机制</a></li>
<li><a href="https://mp.weixin.qq.com/s/wnuqbgnS-D-U48XrxHKIvg" target="_blank" rel="noopener">5. 穿过拥挤的人潮，Spring已为你制作好高级赛道</a></li>
<li><a href="https://mp.weixin.qq.com/s/9MPkCSM9AbsgKAFQ1eXBNQ" target="_blank" rel="noopener">6. 抹平差异，统一类型转换服务ConversionService</a></li>
</ul>
<p>【Jackson】系列：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/iqSN4HUoIdX0kGcSdnD7EA" target="_blank" rel="noopener">1. 初识Jackson – 世界上最好的JSON库</a></li>
<li><a href="https://mp.weixin.qq.com/s/p6cwP2BVrC8VxkN-T3uAxg" target="_blank" rel="noopener">2. 妈呀，Jackson原来是这样写JSON的</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZHb3P06IC4xElHwJqDepxw" target="_blank" rel="noopener">3. 懂了这些，方敢在简历上说会用Jackson写JSON</a></li>
<li><a href="https://mp.weixin.qq.com/s/syAOETfEawiGItaQO35mLA" target="_blank" rel="noopener">4. JSON字符串是如何被解析的？JsonParser了解一下</a></li>
<li><a href="https://mp.weixin.qq.com/s/0ZaDYb_ueFLbvOf3FbetfQ" target="_blank" rel="noopener">5. JsonFactory工厂而已，还蛮有料，这是我没想到的</a></li>
<li><a href="https://mp.weixin.qq.com/s/VYy1QVeFLRkciymFHueb5w" target="_blank" rel="noopener">6. 二十不惑，ObjectMapper使用也不再迷惑</a></li>
<li><a href="https://mp.weixin.qq.com/s/hPRdt-6sHt4rZaW2_jhdWQ" target="_blank" rel="noopener">7. Jackson用树模型处理JSON是必备技能，不信你看</a></li>
</ul>
<p>【数据校验Bean Validation】系列：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/g04HMhrjbvbPn1Mb9JYa5g" target="_blank" rel="noopener">1. 不吹不擂，第一篇就能提升你对Bean Validation数据校验的认知</a></li>
<li><a href="https://mp.weixin.qq.com/s/-KeOCq2rsXCvrqD8HYHSpQ" target="_blank" rel="noopener">2. Bean Validation声明式校验方法的参数、返回值</a></li>
<li><a href="https://mp.weixin.qq.com/s/MQjXG0cg8domRtwf3ArvHw" target="_blank" rel="noopener">3. 站在使用层面，Bean Validation这些标准接口你需要烂熟于胸</a></li>
<li><a href="https://mp.weixin.qq.com/s/jzOv67ZTSx2rByj0aeUTgw" target="_blank" rel="noopener">4. Validator校验器的五大核心组件，一个都不能少</a></li>
<li><a href="https://mp.weixin.qq.com/s/6_7gZ9jmQcDSRiARO6D-yw" target="_blank" rel="noopener">5. Bean Validation声明式验证四大级别：字段、属性、容器元素、类</a></li>
<li><a href="https://mp.weixin.qq.com/s/MN-_JCGnsEWpPJs9xQ_qZA" target="_blank" rel="noopener">6. 自定义容器类型元素验证，类级别验证（多字段联合验证）</a></li>
</ul>
<p>【新特性】系列：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/FnNJEVa5n-TioifE2mcqIw" target="_blank" rel="noopener">Spring Cloud 2020.0.0正式发布，再见了Netflix</a></li>
<li><a href="https://mp.weixin.qq.com/s/vNnfKEGRm7R3PN_lCtXJDA" target="_blank" rel="noopener">IntelliJ IDEA 2020.3正式发布，年度最后一个版本很讲武德</a></li>
<li><a href="https://mp.weixin.qq.com/s/8voJSbmcBbdfNUCUBIcKcA" target="_blank" rel="noopener">IntelliJ IDEA 2020.2正式发布，诸多亮点总有几款能助你提效</a></li>
<li><a href="">IntelliJ IDEA 2020.1正式发布，你要的Almost都在这！</a></li>
<li><a href="https://mp.weixin.qq.com/s/Sw6EqAY0DmF-p2qPoaetUg" target="_blank" rel="noopener">Spring Framework 5.3.0正式发布，在云原生路上继续发力</a></li>
<li><a href="https://mp.weixin.qq.com/s/KywpJkLDHZbZTxUf4WFxhw" target="_blank" rel="noopener">Spring Boot 2.4.0正式发布，全新的配置文件加载机制（不向下兼容）</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZoUG9h1TndW2QpnPyGeIQA" target="_blank" rel="noopener">Spring改变版本号命名规则：此举对非英语国家很友好</a></li>
<li><a href="https://mp.weixin.qq.com/s/3QaiUGzj5nW2N4Aipm47PQ" target="_blank" rel="noopener">JDK15正式发布，划时代的ZGC同时宣布转正</a></li>
</ul>
<p>【程序人生】系列：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/oEShE0fiHSGG8D89NRQYGw" target="_blank" rel="noopener">蚂蚁金服上市了，我不想努力了</a></li>
<li><a href="https://mp.weixin.qq.com/s/SZUJ0sy4vM7UH10pk6NM3g" target="_blank" rel="noopener">如果程序员和产品经理都用凡尔赛文学对话……</a></li>
<li><a href="https://mp.weixin.qq.com/s/PGIFtpI7aZaxY7es0F6C6Q" target="_blank" rel="noopener">程序人生 | 春风得意马蹄疾，一日看尽长安花</a></li>
</ul>
<p>还有诸如【Spring配置类】【Spring-static关键字】【Spring数据绑定】【Spring Cloud Netflix】【Feign】【Ribbon】【Hystrix】…更多原创专栏，关注<code>BAT的乌托邦</code>回复<code>专栏</code>二字即可全部获取，也可加我<code>fsx1056342982</code>，交个朋友。</p>
<blockquote>
<p>有些<strong>已完结</strong>，有些<strong>连载中</strong>。我是A哥(YourBatman)，咱们下期见</p>
</blockquote>]]></content>
      <categories>
        <category>A哥学数据校验</category>
      </categories>
      <tags>
        <tag>MessageFormat</tag>
        <tag>Format</tag>
        <tag>DateFormat</tag>
        <tag>SimpleDateFormat</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud 2020.0.0正式发布，再见了Netflix</title>
    <url>/x2y/f38ef4b0.html</url>
    <content><![CDATA[<p><img data-src="https://img-blog.csdnimg.cn/20201223221110542.png#pic_center" alt=""></p>
<blockquote>
<p>分享、成长，拒绝浅藏辄止。关注公众号【<strong>BAT的乌托邦</strong>】，回复关键字<code>专栏</code>有Spring技术栈、中间件等小而美的<strong>原创专栏</strong>供以免费学习。本文已被 <a href="https://www.yourbatman.cn">https://www.yourbatman.cn</a> 收录。</p>
</blockquote>
<h1 id="✍前言"><a href="#✍前言" class="headerlink" title="✍前言"></a>✍前言</h1><p>你好，我是YourBatman。</p>
<p>北京时间2020-12-22深夜，<code>Spring Cloud 2020.0.0</code>版本正式发布。2020.0.0是第一个使用新版本方案的Spring Cloud发行版本。</p>
<p>关于版本号这里啰嗦几句：在这之前，Spring Cloud的Release Train名称采用的是伦敦地铁站命名方式，如：Hoxton、Greenwich等。</p>
<blockquote>
<p>说明：2020.0.0版本又名<code>Ilford</code>（地铁站名），因为此项目3月后才按照新规更名，估计是为了团队内沟通方便吧，你也可以理解为它仅是一个内部代号而已，方便沟通</p>
</blockquote>
<p>虽按照字母表顺序排列，但仍存在两个致命问题：</p>
<ul>
<li>对非英语<strong>母语</strong>国家（比如天朝）非常不友好，无法快速理清版本号关系</li>
<li>A-Z，倘若版本号到Z了呢？如何继续发展？你品，你细品</li>
</ul>
<p><img data-src="https://img-blog.csdnimg.cn/20201223185627672.png#pic_center" alt=""></p>
<p>Spring团队意识到了这的确是个问题，因此在今年3月份作出了<strong>改变</strong>。详情参考我前面写的一篇文章（<strong>强烈建议</strong>每个进来的你都了解下这次规则变更）：<a href="https://mp.weixin.qq.com/s/ZoUG9h1TndW2QpnPyGeIQA" target="_blank" rel="noopener">Spring改变版本号命名规则：此举对非英语国家很友好</a></p>
<blockquote>
<p>说明：版本号规则变更适用于所有Spring技术栈，包含Spring Framework、Spring Boot、Spring Cloud、Spring Data…</p>
</blockquote>
<p>文归正传。Spring Cloud早在年初就启动了该版本的研发工作，并在今年4月份就已经发布了其2020.0.0-M1版本（第一个里程碑版本），直到离2020年结束不到10天了才“憋出”大招，正式RELEASE。</p>
<p>Spring Cloud作为构建在Spring Boot之上的云计算框架，我觉得本次难产的原因主要有二：</p>
<ol>
<li>Spring Boot 2.4.0版本2020-11-12才正式RELEASE（Spirng Framework 5.3.0版本2020-10-27才RELEASE）<ol>
<li><a href="https://mp.weixin.qq.com/s/Sw6EqAY0DmF-p2qPoaetUg" target="_blank" rel="noopener">Spring Framework 5.3.0正式发布，在云原生路上继续发力</a></li>
<li><a href="https://mp.weixin.qq.com/s/KywpJkLDHZbZTxUf4WFxhw" target="_blank" rel="noopener">Spring Boot 2.4.0正式发布，全新的配置文件加载机制（不向下兼容）</a></li>
</ol>
</li>
<li>改动确实太大，研发、测试、文档编写工作量都是巨大的</li>
</ol>
<p>从Spring Framework、Spring Boot、Spring Cloud三者的发版线路图再一次验证了我的那句话：<strong>你对Spring Cloud多了解源自于你对Spring Boot有多了解，你对Spring Boot多了解源自于你对Spring Framework有多了解</strong>。这就是为何我文章花大量笔墨在Spring Framework上而非Spring Boot上的根本原因，底层通透了，上层运用自如。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201223213749175.png#pic_center" alt=""></p>
<h2 id="版本约定"><a href="#版本约定" class="headerlink" title="版本约定"></a>版本约定</h2><ul>
<li>Spring Framework：5.3.2</li>
<li>Spring Boot：2.4.1</li>
<li>Spring Cloud：2020.0.0<ul>
<li>以上版本为SC“携带”的版本</li>
</ul>
</li>
</ul>
<p><img data-src="https://img-blog.csdnimg.cn/2020122406543886.png#pic_center" alt=""></p>
<h1 id="✍正文"><a href="#✍正文" class="headerlink" title="✍正文"></a>✍正文</h1><p>有个有趣的现象，截止稿前（2020-12-23 22:00:00）<strong>官网</strong>还并未同步标注好当前最新版本为2020.0.0版（如图）：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201223214028434.png#pic_center" alt=""></p>
<p>其实早在24h之前官方博客就做出了发版宣告：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201223214714540.png#pic_center" alt=""></p>
<p>并且Maven中央仓库也已存在最新Jar包（证明你正常引包、使用是没问题的了）：</p>
<p><img data-src="https://img-blog.csdnimg.cn/2020122321485778.png#pic_center" alt=""></p>
<p>其实，文档层面不止官网这一处没有sync最新版本，我就不一一例举，毕竟不太重要。针对此现象我yy一下，是不是Spring Cloud团队缺人人手不够用呢？请问社招吗？O(∩_∩)O哈哈~</p>
<h2 id="Spring-Cloud版本管理"><a href="#Spring-Cloud版本管理" class="headerlink" title="Spring Cloud版本管理"></a>Spring Cloud版本管理</h2><p>版本管理对于软件开发来说太重要，在Spring Boot出现之前依赖关系、版本管理让人着实头大（即使有Spring BOM存在），特别是当出现版本<strong>不适配</strong>时很容易就偷走你一下午甚至一整天的时间。</p>
<p>Spring Cloud作为上层应用框架，底层版本匹配了才能正常work，其中最主要就是和Spring Boot的版本号要对齐。</p>
<h3 id="与Spring-Boot版本对应关系"><a href="#与Spring-Boot版本对应关系" class="headerlink" title="与Spring Boot版本对应关系"></a>与Spring Boot版本对应关系</h3><p>Spring Boot的出现和流行大大缓解了上述些情况，但使用起Spring Cloud时它和Spring Boot的版本对应关系依旧是需要<strong>特别关注</strong>的。为此我帮你总结出了这个表格：</p>
<table>
<thead>
<tr>
<th>Release Train</th>
<th>发布时间</th>
<th>Spring Boot版本</th>
<th>SC Commons版本</th>
</tr>
</thead>
<tbody><tr>
<td><strong>2020.0.x</strong></td>
<td><strong>2020-12</strong></td>
<td><strong>2.4.x</strong></td>
<td><strong>3.0.0</strong></td>
</tr>
<tr>
<td>Hoxton</td>
<td>2019-07</td>
<td>2.2.x, 2.3.x (从SR5起)</td>
<td>2.2.x</td>
</tr>
<tr>
<td>Greenwich</td>
<td>2018-11</td>
<td>2.1.x</td>
<td>2.1.x</td>
</tr>
<tr>
<td>Finchley</td>
<td>2017-10</td>
<td><strong>2.0.x</strong></td>
<td>2.0.x</td>
</tr>
<tr>
<td>Edgware</td>
<td>2017-08</td>
<td>1.5.x</td>
<td>1.3.x</td>
</tr>
<tr>
<td>Dalston</td>
<td>2017-05</td>
<td>1.5.x</td>
<td>1.2.x</td>
</tr>
<tr>
<td>Brixton</td>
<td>2016-09</td>
<td>1.3.x</td>
<td>1.1.x</td>
</tr>
<tr>
<td>Angel</td>
<td>2016-05</td>
<td>1.2.x</td>
<td>1.0.x</td>
</tr>
</tbody></table>
<blockquote>
<p>说明：对于Spring Cloud内部组件、Spring Boot、Spirng Framework、Security等这个庞大体系的版本对照关系，文章已整理好，下篇发出，请记得搜藏哦</p>
</blockquote>
<p>特别提醒：<code>spring-cloud-starter-loadbalancer</code>是伴随着Spring Cloud Commons 2.2.0版本才开始商用的（Hoxton版本），这个版本节点请稍微关注下，因为它替代了Ribbon。</p>
<h3 id="当前支持的版本"><a href="#当前支持的版本" class="headerlink" title="当前支持的版本"></a>当前支持的版本</h3><p>Spring Cloud遵循<strong>Pivotal OSS support policy</strong> 协议对<strong>主要版本</strong>提供3年的支持。此外，在Spring Cloud的主要或次要版本发布后，若存在严重的bug和安全问题，就会再维护一段时间（6-12个月不等）。</p>
<blockquote>
<p>特别注意：这里指的<strong>主要版本</strong>才是3年，主要版本可不常有的哦</p>
</blockquote>
<p>现在2020.0.0版本已发布，又到了淘汰的时候。现在Spring Cloud官方还会支持的版本有：</p>
<ul>
<li><strong>2020.0版本</strong>：（支持Spring Boot 2.4.x）它是<strong>主要版本</strong>，按计划会支持到2023年12月份<ul>
<li>它是自Finchley后的又一主要版本</li>
</ul>
</li>
<li><strong>Hoxton版本</strong>：（支持Spring Boot 2.2.x和2.3.x）作为Finchley发行系列的一个次要版本，它的常规维护将持续到2021年6月底。从2020-07开始进入到特殊维护期（不加新功能，只改紧急bug），2021-12月底就只会发布重大错误/安全补丁了</li>
<li><strong>Greenwich版本</strong>：（支持Spring Boot 2.1.x）2020-01就停止维护了，2020-12-31号也将终结它的特殊维护期</li>
<li><strong>Finchley版本</strong>：（支持Spring Boot 2.0.x）它是一个<strong>主要版本</strong>的开始，2018年发布</li>
<li><strong>更老版本</strong>：嗯，忘了吧</li>
</ul>
<p><img data-src="https://img-blog.csdnimg.cn/20201223233224440.png#pic_center" alt=""></p>
<p>Spring官方<strong>建议</strong>：尽量使用最新版本。不过建议归建议，作为只使用<strong>晚期大众</strong>技术的我们，坐在第二排甚至第三排看戏才有安全感。但历史的巨浪总归会把前排淘汰，因此早点做足准备总是好的，不至于时至被推至前排时只能<strong>裸泳</strong>。</p>
<p>Spring Cloud 2020.0作为一个<strong>主要版本</strong>，带来了众多显著的变化，其中进行了一些阻断式更新（不向下兼容）是本文最大看点，来吧上菜。</p>
<h2 id="阻断式升级（不向下兼容）"><a href="#阻断式升级（不向下兼容）" class="headerlink" title="阻断式升级（不向下兼容）"></a>阻断式升级（不向下兼容）</h2><p>差不多在去年（2019年）的这个时候，Spring Cloud在其Roadmap（之前文章有介绍过）里就宣布将要<strong>终结</strong>的一些库/版本，其中最重要的就是指<strong>Spring Cloud Netflix项目进入维护模式</strong>，然后计划在2020年完全移除。</p>
<p>Spring Cloud做出这样的决定其实也是“被迫的”。我们知道Spring Cloud一直以来把<code>Netflix OSS</code>套件作为其官方默认的一站式解决方案，那时的Netflix OSS套件恨不得可以跟Spring Cloud划等号。奈何呀，Netflix公司在2018年前后宣布其核心组件Hystrix、Ribbon、Zuul、Archaius等均进入<strong>维护状态</strong>。</p>
<blockquote>
<p>虽然有Zuul 2.x，Archaius 2.x，但它们均不能向下兼容，无法平滑升级，因此几乎等于无法使用</p>
</blockquote>
<p>从2018年至今处于维护状态的模块有（包括其对应的starter，此处并未列出）：</p>
<ol>
<li>spring-cloud-netflix-archaius</li>
<li>spring-cloud-netflix-hystrix-contract</li>
<li>spring-cloud-netflix-hystrix-dashboard</li>
<li>spring-cloud-netflix-hystrix-stream</li>
<li>spring-cloud-netflix-hystrix</li>
<li>spring-cloud-netflix-ribbon</li>
<li>spring-cloud-netflix-turbine-stream</li>
<li>spring-cloud-netflix-turbine</li>
<li>spring-cloud-netflix-zuul</li>
</ol>
<h3 id="1、再见了，Netflix"><a href="#1、再见了，Netflix" class="headerlink" title="1、再见了，Netflix"></a>1、再见了，Netflix</h3><p>时至今日，Spring Cloud 2020.0正式发布，在这个主要版本里，按既定计划终于对<code>spring-cloud-netflix</code>动刀了。我帮你画了幅<code>spring-cloud-netflix-dependencies</code>的xml文件前后版本主要差异的对比图，一目了然：</p>
<p><img data-src="https://img-blog.csdnimg.cn/2020122400165972.png#pic_center" alt=""></p>
<ul>
<li><code>spring-cloud-netflix-dependencies</code>没有消失哦，它依旧存在，版本号跟随大部队升级为3.0.x版本</li>
<li>旧版本的<code>spring-cloud-netflix-dependencies</code>管理着Netflix所有组件，包括Hystrix、Ribbon、Zuul、Eureka等。而自2020.0版本起，<strong>它有且只管理Eureka（包括Server和Client）</strong></li>
</ul>
<blockquote>
<p>解释说明：Feign虽然最初属Netflix公司，但从9.x版本开始就移交给OpenFeign组织管理了，因此不再划入Netflix管辖范畴</p>
</blockquote>
<p>简单一句话概括：Spring Cloud 2020.0.0版本<strong>彻底删除</strong>掉了Netflix除Eureka外的<strong>所有</strong>组件。至此，我们怀着感恩的心可以对Netflix OSS套件道一声谢谢，并可以对它说再见了。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201224000042869.png#pic_center" alt=""></p>
<blockquote>
<p>说明：Netflix的Eureka项目仍旧是活跃状态，这个注册中心设计上还是蛮优秀的，综合表现尚可，市场上竞争力依旧可圈可点，因此Spring Cloud暂还未放弃它</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Netflix组件替代方案"><a href="#Netflix组件替代方案" class="headerlink" title="Netflix组件替代方案"></a>Netflix组件替代方案</h4><p>Spring Cloud既然把Netflix OSS套件大刀阔斧的砍掉了，那总归得有替代方案吧。那是必然的，Spring Cloud团队给我们推荐了用于替代的产品：</p>
<table>
<thead>
<tr>
<th>Netflix</th>
<th>推荐替代品</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Hystrix</td>
<td>Resilience4j</td>
<td>Hystrix自己也推荐你使用它代替自己</td>
</tr>
<tr>
<td>Hystrix Dashboard / Turbine</td>
<td>Micrometer + Monitoring System</td>
<td>说白了，监控这件事交给更专业的组件去做</td>
</tr>
<tr>
<td>Ribbon</td>
<td>Spring Cloud Loadbalancer</td>
<td>忍不住了，Spring终究亲自出手</td>
</tr>
<tr>
<td>Zuul 1</td>
<td>Spring Cloud Gateway</td>
<td>忍不住了，Spring终究亲自出手</td>
</tr>
<tr>
<td>Archaius 1</td>
<td>Spring Boot外部化配置 + Spring Cloud配置</td>
<td>比Netflix实现的更好、更强大</td>
</tr>
</tbody></table>
<h5 id="Spring-Cloud-LoadBalancer是什么？"><a href="#Spring-Cloud-LoadBalancer是什么？" class="headerlink" title="Spring Cloud LoadBalancer是什么？"></a>Spring Cloud LoadBalancer是什么？</h5><p>以上替代品中，你可能最陌生、最好奇的是<code>Spring Cloud Loadbalancer</code>，它一度只是Spring Cloud <strong>孵化器</strong>里的一个小项目，并且一度搁浅。后再经过重启，发展，现行使其伟大使命，正式用于<strong>完全替换</strong> Ribbon，成为Spring Cloud负载均衡器<strong>唯一实现</strong>。</p>
<p>值得注意的是：Spring Cloud LoadBalancer首次引入是在Spring Cloud Commons 2.2.0时，也就是Hoxton发布时就引入了，只不过那会还只是备胎/备选，默认依旧是Ribbon挑大梁。下截图是在Hoxton版本的情况：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201224004316321.png#pic_center" alt=""></p>
<p>如图，负载均衡抽象<code>LoadBalancerClient</code>接口有两个实现，而到了Spring Cloud 2020.0版本后，<code>BlockingLoadBalancerClient</code>就是唯一实现了。</p>
<blockquote>
<p>关于spring-cloud-loadbalancer负载均衡器的使用，官方有个极其建议教程：<a href="https://spring.io/guides/gs/spring-cloud-loadbalancer。有兴趣可自己玩玩，若没兴趣，那就关注我后面文章分析吧，我会专程介绍它的" target="_blank" rel="noopener">https://spring.io/guides/gs/spring-cloud-loadbalancer。有兴趣可自己玩玩，若没兴趣，那就关注我后面文章分析吧，我会专程介绍它的</a></p>
</blockquote>
<h4 id="Spring-Cloud-Alibaba是否可作为替代方案？"><a href="#Spring-Cloud-Alibaba是否可作为替代方案？" class="headerlink" title="Spring Cloud Alibaba是否可作为替代方案？"></a>Spring Cloud Alibaba是否可作为替代方案？</h4><p>嗯，也可以。</p>
<p>不过它目前来说并不是Spring Cloud官方的推荐的默认方案。期待国人一起努力，能早日送Spring Cloud Alibaba上去，让歪果仁用上咱天朝的框架，提issue必须用中文O(∩_∩)O哈哈~。</p>
<h4 id="显示导入Netflix包还能否正常work？"><a href="#显示导入Netflix包还能否正常work？" class="headerlink" title="显示导入Netflix包还能否正常work？"></a>显示导入Netflix包还能否正常work？</h4><p>既想升级到最新版本的Spring Cloud，又想保持向下兼容使用Netflix的技术。虽说spring-cloud-netflix-dependencies里不再包含netflix的核心组件，那我手动导包并指定版本号行不行？能否正常work呢？</p>
<p><strong>答</strong>：我拍脑袋就给你个答案，<strong>不行</strong>。既然我没论证过，但这么使用太畸形了，此方案应被枪毙在萌芽中，不应该有。</p>
<p>另外，从此事也告诉我们：使用Spring Cloud时尽量面向它的<strong>抽象</strong>编程，这样即使Spirng Cloud换底层组件（如换熔断器、负载均衡器）等等，理论上对我们业务是无影响或者影响很小的，这都得益于它的Spring Cloud Commons抽象，那里是精华。</p>
<h3 id="2、Bootstrap上下文默认不再启动"><a href="#2、Bootstrap上下文默认不再启动" class="headerlink" title="2、Bootstrap上下文默认不再启动"></a>2、Bootstrap上下文默认不再启动</h3><p>知晓原理的同学知道，Spring Cloud容器是靠<code>Bootstrap Context</code>引导上下文来启动的，对应的类是<code>BootstrapApplicationListener</code>。</p>
<p>这在2020.0版本发生了改变，<strong>新版本的Spring Cloud不再依赖于此上下文而启动</strong>。因此默认情况下，将不再启动Bootstrap上下文。代码层面的改变发生在这里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BootstrapApplicationListener：</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEnvironmentPreparedEvent event)</span> </span>&#123;</span><br><span class="line">		ConfigurableEnvironment environment = event.getEnvironment();</span><br><span class="line">		<span class="comment">// 在方法开头加了这麽个判断</span></span><br><span class="line">		<span class="keyword">if</span> (!bootstrapEnabled(environment) &amp;&amp; !useLegacyProcessing(environment)) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">PropertyUtils：</span><br><span class="line"></span><br><span class="line">	<span class="comment">// BOOTSTRAP_ENABLED_PROPERTY = spring.cloud.bootstrap.enabled</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">bootstrapEnabled</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> environment.getProperty(BOOTSTRAP_ENABLED_PROPERTY, Boolean<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>) || <span class="title">MARKER_CLASS_EXISTS</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// USE_LEGACY_PROCESSING_PROPERTY = spring.config.use-legacy-processing</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">useLegacyProcessing</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> environment.getProperty(USE_LEGACY_PROCESSING_PROPERTY, Boolean<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>)</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="开启方式"><a href="#开启方式" class="headerlink" title="开启方式"></a>开启方式</h4><p>若你需要开启Bootstrap上下文，有两种办法可以实现：</p>
<ol>
<li>设置值<code>spring.cloud.bootstrap.enabled=true</code>或者 <code>spring.config.use-legacy-processing=true</code>即可。注意：这些个属性值必须确保其能放进环境里才能生效。比如靠谱的方式是：系统属性、环境变量、命令行等</li>
<li>引入一个Jar：<code>org.springframework.cloud:spring-cloud-starter-bootstrap</code>，然后什么都不用做了<ol>
<li>说明：这个jar里面有且仅有一个<code>Marker</code>类，作用你懂的，此处不做过多解释</li>
</ol>
</li>
</ol>
<blockquote>
<p>说明：手动开启Bootstrap上下文，证明你fallback到老的方式去加载SC，那么一切请按照老方式做即可</p>
</blockquote>
<h3 id="3、全新的配置方式"><a href="#3、全新的配置方式" class="headerlink" title="3、全新的配置方式"></a>3、全新的配置方式</h3><p>得益于Spring Boot 2.4.x支持全新的配置文件书写方式，自此可以使用<code>spring.config.import</code>俩导入其它组建的配置。如：</p>
<ul>
<li>spring.config.import=configserver:xxx</li>
<li>spring.config.import=zookeeper:</li>
<li>…</li>
</ul>
<p>这么做更具模块化，更符合云原生环境的要求。</p>
<h3 id="4、其它"><a href="#4、其它" class="headerlink" title="4、其它"></a>4、其它</h3><ul>
<li>之前若要禁用Spring Cloud Config Client端的健康指示用的是<code>health.config.enabled=false</code>，现改为<code>management.health.config.enabled=false</code>。保持了和Spring Boot控制端点风格一致</li>
<li>带有无效字符(破折号)的端点id已经改为符合标准的了，自此启动时再也没有讨厌的警告了，拯救洁癖者。<ul>
<li>bus-env -&gt; busenv</li>
<li>bus-refresh -&gt; busrefresh</li>
<li>service-registry -&gt; serviceregistry</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// old</span></span><br><span class="line"><span class="meta">@Endpoint</span>(id = <span class="string">"service-registry"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceRegistryEndpoint</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new</span></span><br><span class="line"><span class="meta">@Endpoint</span>(id = <span class="string">"serviceregistry"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceRegistryEndpoint</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<h2 id="常规式升级"><a href="#常规式升级" class="headerlink" title="常规式升级"></a>常规式升级</h2><p>常规升级这块关注点就没那么多了，主要对其组件如<code>Spring Cloud Commons、Spring Cloud Kubernetes、Spring Cloud Openfeign...</code>等做些常规升级，乏善可陈。</p>
<p>值得关注的一点：Spirng Cloud所有的Module版本号均升级到了<code>3.0.0</code>（大版本号的升级），除Spring Cloud Circuitbreaker/Spring Cloud Kubernetes（2.0.0）和Spring Cloud Task（2.3.0）之外。</p>
<h2 id="仍旧存在的问题"><a href="#仍旧存在的问题" class="headerlink" title="仍旧存在的问题"></a>仍旧存在的问题</h2><p>虽然2020.0已经RELEASE了，但是仍存在着未解决的问题，例举几个此版本<strong>现存</strong>的问题：</p>
<ul>
<li>若使用<code>spring.config.import=configserver:</code>来配置配置中心，此版本漏掉了支持retry参数<ul>
<li>解决方案：若你要使用的话，你只得fallback到传统方式喽（写在bootstrap.yaml里）</li>
</ul>
</li>
<li><code>spring-cloud-config-dependencies</code>里出现了一个非release版本的jar（具体看下截图）<ul>
<li>解决方案：手动指定该jar的版本号</li>
</ul>
</li>
</ul>
<p><img data-src="https://img-blog.csdnimg.cn/20201224012523158.png#pic_center" alt=""></p>
<blockquote>
<p>说明：M1属于里程碑版本，还属于较为早起阶段，可能存在bug，建议你使用时手动指定版本号替换掉这个jar</p>
</blockquote>
<p>看来即使强如Spring团队，也会出现各种各样的纰漏呀。这么一想的话，我又敢放心大胆的回去写bug去喽。</p>
<h1 id="✍总结"><a href="#✍总结" class="headerlink" title="✍总结"></a>✍总结</h1><p>Spring Cloud 2020.0.0是Spring Cloud的<strong>主要版本</strong>，是非常重要的存在，升级、改变也是巨大的。特别体现在Netflix模块的全部移除、Spring Cloud启动方式变了等等。伴随着Spring Boot 2.4.x以及Spirng Cloud 2020.0的发布，并且弃用Netflix OSS套件后，必将走入一个新的<strong>深度编程</strong>体验，满怀惊喜，很是期待。</p>
<blockquote>
<p>说明：因为此版本完全摈弃掉了Netflix的一套东西，为了跟上时代，我会使用一段时间后，尽快写出最新版本的系列教程，助你少踩坑</p>
</blockquote>
<p>文末有提到2020.0版本虽已发布，但仍旧存在些问题。不过话说回来，那些都属于很小的问题，可能在下个小版本里就得到修复。但尴尬的是，距离2020年结束只有不到10天了，倘若进入到了2021年，按照版本号命名新规，彼时发出的版本将不能再叫2020.x.x而只能是2021.x.x，显然这就属于大版本号的迭代了，需要谨慎啊。</p>
<p><strong>你觉得Spring Cloud团队在2020年还会发版吗？欢迎在评论区留下你的看法。</strong></p>]]></content>
      <categories>
        <category>新特性</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Netflix</tag>
        <tag>Spring Cloud Loadbalancer</tag>
      </tags>
  </entry>
  <entry>
    <title>6. 抹平差异，统一类型转换服务ConversionService</title>
    <url>/x2y/79583e2f.html</url>
    <content><![CDATA[<p><img data-src="https://img-blog.csdnimg.cn/20201220074003122.png#pic_center" alt=""></p>
<blockquote>
<p>分享、成长，拒绝浅藏辄止。关注公众号【<strong>BAT的乌托邦</strong>】，回复关键字<code>专栏</code>有Spring技术栈、中间件等小而美的<strong>原创专栏</strong>供以免费学习。本文已被 <a href="https://www.yourbatman.cn">https://www.yourbatman.cn</a> 收录。</p>
</blockquote>
<h1 id="✍前言"><a href="#✍前言" class="headerlink" title="✍前言"></a>✍前言</h1><p>你好，我是YourBatman。</p>
<p>通过前两篇文章的介绍已经非常熟悉Spirng 3.0全新一代的类型转换机制了，它提供的三种类型转换器(Converter、ConverterFactory、GenericConverter)，分别可处理1:1、1:N、N:N的类型转换。按照Spring的设计习惯，必有一个注册中心来统一管理，负责它们的注册、删除等，它就是<code>ConverterRegistry</code>。</p>
<blockquote>
<p> 对于<code>ConverterRegistry</code>在文首多说一句：我翻阅了很多博客文章介绍它时几乎无一例外的提到有<strong>查找</strong>的功能，但实际上是<strong>没有的</strong>。Spring设计此API接口并没有暴露其查找功能，选择把最为复杂的查找匹配逻辑私有化，目的是让开发者使可无需关心，细节之处充分体现了Spring团队API设计的卓越能力。</p>
</blockquote>
<p>另外，内建的绝大多数转换器访问权限都是default/private，那么如何使用它们，以及屏蔽各种转换器的<strong>差异化</strong>呢？为此，Spring提供了一个<strong>统一类型转换服务</strong>，它就是<code>ConversionService</code>。</p>
<h2 id="版本约定"><a href="#版本约定" class="headerlink" title="版本约定"></a>版本约定</h2><ul>
<li>Spring Framework：5.3.1</li>
<li>Spring Boot：2.4.0</li>
</ul>
<p><img data-src="https://img-blog.csdnimg.cn/20201224070630350.png#pic_center" alt=""></p>
<h1 id="✍正文"><a href="#✍正文" class="headerlink" title="✍正文"></a>✍正文</h1><p>ConverterRegistry和ConversionService的关系密不可分，前者为后者提供转换器管理支撑，后者面向使用者提供服务。本文涉及到的接口/类有：</p>
<ul>
<li><code>ConverterRegistry</code>：转换器注册中心。负责转换器的注册、删除</li>
<li><code>ConversionService</code>：<strong>统一的</strong>类型转换服务。属于面向开发者使用的门面接口</li>
<li><code>ConfigurableConversionService</code>：上两个接口的组合接口</li>
<li><code>GenericConversionService</code>：上个接口的实现，实现了注册管理、转换服务的几乎<strong>所有功能</strong>，是个实现类而非抽象类</li>
<li><code>DefaultConversionService</code>：继承自<code>GenericConversionService</code>，在其基础上注册了一批默认转换器（Spring内建），从而具备基础转换能力，能解决日常绝大部分场景</li>
</ul>
<p><img data-src="https://img-blog.csdnimg.cn/20201219220041102.png#pic_center" alt=""></p>
<h2 id="ConverterRegistry"><a href="#ConverterRegistry" class="headerlink" title="ConverterRegistry"></a>ConverterRegistry</h2><p>Spring 3.0引入的转换器注册中心，用于管理新一套的转换器们。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConverterRegistry</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addConverter</span><span class="params">(Converter&lt;?, ?&gt; converter)</span></span>;</span><br><span class="line">	&lt;S, T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addConverter</span><span class="params">(Class&lt;S&gt; sourceType, Class&lt;T&gt; targetType, Converter&lt;? <span class="keyword">super</span> S, ? extends T&gt; converter)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addConverter</span><span class="params">(GenericConverter converter)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addConverterFactory</span><span class="params">(ConverterFactory&lt;?, ?&gt; factory)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 唯一移除方法：按照转换pair对来移除</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">removeConvertible</span><span class="params">(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的继承树如下：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201220155358172.png#pic_center" alt=""></p>
<p>ConverterRegistry有子接口FormatterRegistry，它属于格式化器的范畴，故不放在本文讨论。但<strong>仍旧属于本系列专题</strong>内容，会在接下来的几篇内容里介入，敬请关注。</p>
<h2 id="ConversionService"><a href="#ConversionService" class="headerlink" title="ConversionService"></a>ConversionService</h2><p>面向使用者的统一类型转换服务。换句话说：站在使用层面，你只需要知道<code>ConversionService</code>接口API的使用方式即可，并不需要关心其内部实现机制，可谓对使用者非常友好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConversionService</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</span><br><span class="line">	</span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">convert</span><span class="params">(Object source, Class&lt;T&gt; targetType)</span></span>;</span><br><span class="line">	<span class="function">Object <span class="title">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的继承树如下：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201220155730772.png#pic_center" alt=""></p>
<p>可以看到ConversionService和ConverterRegistry的继承树殊途同归，都直接指向了<code>ConfigurableConversionService</code>这个分支，下面就对它进行介绍。</p>
<h3 id="ConfigurableConversionService"><a href="#ConfigurableConversionService" class="headerlink" title="ConfigurableConversionService"></a>ConfigurableConversionService</h3><p><code>ConversionService</code>和<code>ConverterRegistry</code>的组合接口，自己并未新增任何接口方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurableConversionService</span> <span class="keyword">extends</span> <span class="title">ConversionService</span>, <span class="title">ConverterRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的继承树可参考上图。接下来就来到此接口的直接实现类GenericConversionService。</p>
<h3 id="GenericConversionService"><a href="#GenericConversionService" class="headerlink" title="GenericConversionService"></a>GenericConversionService</h3><p>对<code>ConfigurableConversionService</code>接口提供了完整实现的实现类。换句话说：ConversionService和ConverterRegistry接口的功能均通过此类得到了实现，所以它是本文重点。</p>
<p>该类很有些值得学习的地方，可以细品，在我们自己设计程序时加以借鉴。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericConversionService</span> <span class="keyword">implements</span> <span class="title">ConfigurableConversionService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Converters converters = <span class="keyword">new</span> Converters();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ConverterCacheKey, GenericConverter&gt; converterCache = <span class="keyword">new</span> ConcurrentReferenceHashMap&lt;ConverterCacheKey, GenericConverter&gt;(<span class="number">64</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它用两个成员变量来<strong>管理</strong>转换器们，其中converterCache是缓存用于加速查找，因此更为重要的便是Converters喽。</p>
<p>Converters是<code>GenericConversionService</code>的内部类，用于管理（添加、删除、查找）转换器们。也就说对<code>ConverterRegistry</code>接口的实现最终是委托给它去完成的，它是整个<strong>转换服务</strong>正常work的内核，下面我们对它展开详细叙述。</p>
<h4 id="1、内部类Converters"><a href="#1、内部类Converters" class="headerlink" title="1、内部类Converters"></a>1、内部类Converters</h4><p>它管理<strong>所有</strong>转换器，包括添加、删除、查找。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GenericConversionService：</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 内部类</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Converters</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> Set&lt;GenericConverter&gt; globalConverters = <span class="keyword">new</span> LinkedHashSet&lt;GenericConverter&gt;();</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ConvertiblePair, ConvertersForPair&gt; converters = <span class="keyword">new</span> LinkedHashMap&lt;ConvertiblePair, ConvertersForPair&gt;(<span class="number">36</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：这里使用的集合/Map均为<code>LinkedHashXXX</code>，都是有序的（存入顺序和遍历取出顺序保持一致）</p>
</blockquote>
<p>用这两个集合/Map存储着注册进来的转换器们，他们的作用分别是：</p>
<ul>
<li><code>globalConverters</code>：存取<strong>通用的</strong>转换器，并不限定转换类型，一般用于兜底</li>
<li><code>converters</code>：指定了类型对，对应的转换器<strong>们</strong>的映射关系。<ul>
<li>ConvertiblePair：表示一对，包含sourceType和targetType</li>
<li>ConvertersForPair：这一对对应的转换器<strong>们</strong>（因为能处理一对的可能存在多个转换器），内部使用一个双端队列Deque来存储，保证顺序<ul>
<li>小细节：Spring 5之前使用LinkedList，之后使用Deque（实际为ArrayDeque）存储<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertiblePair</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; sourceType;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; targetType;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertersForPair</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;GenericConverter&gt; converters = <span class="keyword">new</span> ArrayDeque&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="添加add"><a href="#添加add" class="headerlink" title="添加add"></a>添加add</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(GenericConverter converter)</span> </span>&#123;</span><br><span class="line">	Set&lt;ConvertiblePair&gt; convertibleTypes = converter.getConvertibleTypes();</span><br><span class="line">	<span class="keyword">if</span> (convertibleTypes == <span class="keyword">null</span>) &#123;</span><br><span class="line">		... <span class="comment">// 放进globalConverters里</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		... <span class="comment">// 放进converters里（若支持多组pair就放多个key）</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此之前需要了解个前提：对于三种转换器<code>Converter、ConverterFactory、GenericConverter</code>在添加到Converters之前都<strong>统一</strong>被适配为了<code>GenericConverter</code>，这样做的目的是方便统一管理。对应的两个适配器是ConverterAdapter和ConverterFactoryAdapter，它俩都是ConditionalGenericConverter的内部类。</p>
<p>添加的逻辑被我用伪代码简化后其实非常简单，无非就是一个非此即彼的关系而已：</p>
<ul>
<li>若转换器没有指定处理的类型对，就放进全局转换器列表里，用于兜底</li>
<li>若转换器有指定处理的类型对（可能还是多个），就放进converters里，后面查找时使用</li>
</ul>
<h5 id="删除remove"><a href="#删除remove" class="headerlink" title="删除remove"></a>删除remove</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.converters.remove(<span class="keyword">new</span> ConvertiblePair(sourceType, targetType));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>移除逻辑非常非常的简单，这得益于添加时候做了<strong>统一适配的抽象</strong>。</p>
<h5 id="查找find"><a href="#查找find" class="headerlink" title="查找find"></a>查找find</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> GenericConverter <span class="title">find</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 找到该类型的类层次接口（父类 + 接口），注意：结果是有序列表</span></span><br><span class="line">	List&lt;Class&lt;?&gt;&gt; sourceCandidates = getClassHierarchy(sourceType.getType());</span><br><span class="line">	List&lt;Class&lt;?&gt;&gt; targetCandidates = getClassHierarchy(targetType.getType());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 双重遍历</span></span><br><span class="line">	<span class="keyword">for</span> (Class&lt;?&gt; sourceCandidate : sourceCandidates) &#123;</span><br><span class="line">		<span class="keyword">for</span> (Class&lt;?&gt; targetCandidate : targetCandidates) &#123;</span><br><span class="line">			ConvertiblePair convertiblePair = <span class="keyword">new</span> ConvertiblePair(sourceCandidate, targetCandidate);</span><br><span class="line">			... <span class="comment">// 从converters、globalConverters里匹配到一个合适转换器后立马返回</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找逻辑也并不复杂，有两个关键点需要关注：</p>
<ul>
<li><code>getClassHierarchy(class)</code>：获取该类型的类层次（父类 + 接口），注意：结果List是有序的List<ul>
<li>也就是说转换器支持的类型若是父类/接口，那么也能够处理器子类</li>
</ul>
</li>
<li>根据convertiblePair匹配转换器：优先匹配专用的converters，然后才是globalConverters。若都没匹配上返回null</li>
</ul>
<h4 id="2、管理转换器-ConverterRegistry"><a href="#2、管理转换器-ConverterRegistry" class="headerlink" title="2、管理转换器(ConverterRegistry)"></a>2、管理转换器(ConverterRegistry)</h4><p>了解了<code>Converters</code>之后再来看<code>GenericConversionService</code>是如何管理转换器，就如鱼得水，一目了然了。</p>
<h5 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h5><p>为了<strong>方便</strong>使用者调用，ConverterRegistry接口提供了三个添加方法，这里一一给与实现。</p>
<blockquote>
<p>说明：暴露给调用者使用的API接口使用起来应尽量的方便，重载多个是个有效途径。内部做适配、归口即可，用户至上</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addConverter</span><span class="params">(Converter&lt;?, ?&gt; converter)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 获取泛型类型 -&gt; 转为ConvertiblePair</span></span><br><span class="line">	ResolvableType[] typeInfo = getRequiredTypeInfo(converter.getClass(), Converter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	... </span><br><span class="line">	<span class="comment">// converter适配为GenericConverter添加</span></span><br><span class="line">	addConverter(<span class="keyword">new</span> ConverterAdapter(converter, typeInfo[<span class="number">0</span>], typeInfo[<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;S, T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addConverter</span><span class="params">(Class&lt;S&gt; sourceType, Class&lt;T&gt; targetType, Converter&lt;? <span class="keyword">super</span> S, ? extends T&gt; converter)</span> </span>&#123;</span><br><span class="line">	addConverter(<span class="keyword">new</span> ConverterAdapter(converter, ResolvableType.forClass(sourceType), ResolvableType.forClass(targetType)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addConverter</span><span class="params">(GenericConverter converter)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.converters.add(converter);</span><br><span class="line">	invalidateCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前两个方法都会调用到第三个方法上，每调用一次<code>addConverter()</code>方法都会清空缓存，也就是<code>converterCache.clear()</code>。所以动态添加转换器对性能是<strong>有损</strong>的，因此使用时候需稍加注意一些。</p>
<h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><p>ConverterRegistry接口并未直接提供查找方法，而只是在实现类内部做了实现。提供一个钩子方法用于查找给定sourceType/targetType对的转换器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> GenericConverter <span class="title">getConverter</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">	ConverterCacheKey key = <span class="keyword">new</span> ConverterCacheKey(sourceType, targetType);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 1、查缓存</span></span><br><span class="line">	GenericConverter converter = <span class="keyword">this</span>.converterCache.get(key);</span><br><span class="line">	<span class="keyword">if</span> (converter != <span class="keyword">null</span>) &#123;</span><br><span class="line">		... <span class="comment">// 返回结果</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2、去converters里查找</span></span><br><span class="line">	converter = <span class="keyword">this</span>.converters.find(sourceType, targetType);</span><br><span class="line">	<span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 若还没有匹配的，就返回默认结果</span></span><br><span class="line">		<span class="comment">// 默认结果是NoOpConverter -&gt; 什么都不做</span></span><br><span class="line">		converter = getDefaultConverter(sourceType, targetType);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	... <span class="comment">// 把结果装进缓存converterCache里</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了对Converters查找逻辑的分析，这个步骤就很简单了。绘制成图如下：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201220065638293.png#pic_center" alt=""></p>
<h4 id="3、转换功能-ConversionService"><a href="#3、转换功能-ConversionService" class="headerlink" title="3、转换功能(ConversionService)"></a>3、转换功能(ConversionService)</h4><p>上半部分介绍完<code>GenericConversionService</code>对转换器管理部分的实现（对ConverterRegistry接口的实现），接下来就看看它是如何实现转换功能的（对ConversionService接口的实现）。</p>
<h5 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(@Nullable Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> canConvert((sourceType != <span class="keyword">null</span> ? TypeDescriptor.valueOf(sourceType) : <span class="keyword">null</span>), TypeDescriptor.valueOf(targetType));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (sourceType == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 查找/匹配对应的转换器</span></span><br><span class="line">	GenericConverter converter = getConverter(sourceType, targetType);</span><br><span class="line">	<span class="keyword">return</span> (converter != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能否执行转换判断的唯一标准：<strong>能否匹配到可用于转换的转换器</strong>。而这个查找匹配逻辑，稍稍抬头往上就能看到。</p>
<h5 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">convert</span><span class="params">(@Nullable Object source, Class&lt;T&gt; targetType)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (T) convert(source, TypeDescriptor.forObject(source), TypeDescriptor.valueOf(targetType));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">convert</span><span class="params">(@Nullable Object source, @Nullable TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (sourceType == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> handleResult(<span class="keyword">null</span>, targetType, convertNullSource(<span class="keyword">null</span>, targetType));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 校验：source必须是sourceType的实例</span></span><br><span class="line">	<span class="keyword">if</span> (source != <span class="keyword">null</span> &amp;&amp; !sourceType.getObjectType().isInstance(source)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Source to convert from must be an instance of ["</span> + sourceType + <span class="string">"]; instead it was a ["</span> + source.getClass().getName() + <span class="string">"]"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ============拿到转换器，执行转换============</span></span><br><span class="line">	GenericConverter converter = getConverter(sourceType, targetType);</span><br><span class="line">	<span class="keyword">if</span> (converter != <span class="keyword">null</span>) &#123;</span><br><span class="line">		Object result = ConversionUtils.invokeConverter(converter, source, sourceType, targetType);</span><br><span class="line">		<span class="keyword">return</span> handleResult(sourceType, targetType, result);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 若没进行canConvert的判断直接调动，可能出现此种状况：一般抛出ConverterNotFoundException异常</span></span><br><span class="line">	<span class="keyword">return</span> handleConverterNotFound(source, sourceType, targetType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，执行转换的逻辑很简单，非常好理解的两个步骤：</p>
<ol>
<li>查找匹配到一个合适的转换器（查找匹配的逻辑同上）</li>
<li>拿到此转换器执行转换<code>converter.convert(...)</code></li>
</ol>
<blockquote>
<p>说明：其余代码均为一些判断、校验、容错，并非核心，本文给与适当忽略。</p>
</blockquote>
<p>GenericConversionService实现了转换器管理、转换服务的<strong>所有功能</strong>，是可以直接面向开发者使用的。但是开发者使用时可能并不知道需要注册哪些转换器来保证程序正常运转，Spring并不能要求开发者知晓其内建实现。基于此，Spring在3.1又提供了一个默认实现DefaultConversionService，它对使用者更友好。</p>
<h3 id="DefaultConversionService"><a href="#DefaultConversionService" class="headerlink" title="DefaultConversionService"></a>DefaultConversionService</h3><p>Spirng容器默认使用的转换服务实现，继承自<code>GenericConversionService</code>，在其基础行只做了<strong>一件事</strong>：构造时添加内建的默认转换器<strong>们</strong>。从而天然具备有了基本的类型转换能力，适用于不同的环境。如：xml解析、@Value解析、http协议参数自动转换等等。</p>
<blockquote>
<p>小细节：它并非Spring 3.0就有，而是Spring 3.1新推出的API</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @since 3.1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultConversionService</span> <span class="keyword">extends</span> <span class="title">GenericConversionService</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 唯一构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DefaultConversionService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		addDefaultConverters(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本类核心代码就这一个构造器，构造器内就这一句代码：<code>addDefaultConverters(this)</code>。接下来需要关注Spring默认情况下给我们“安装”了哪些转换器呢？也就是了解下<code>addDefaultConverters(this)</code>这个静态方法</p>
<h4 id="默认注册的转换器们"><a href="#默认注册的转换器们" class="headerlink" title="默认注册的转换器们"></a>默认注册的转换器们</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// public的静态方法，注意是public的访问权限</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addDefaultConverters</span><span class="params">(ConverterRegistry converterRegistry)</span> </span>&#123;</span><br><span class="line">	addScalarConverters(converterRegistry);</span><br><span class="line">	addCollectionConverters(converterRegistry);</span><br><span class="line"></span><br><span class="line">	converterRegistry.addConverter(<span class="keyword">new</span> ByteBufferConverter((ConversionService) converterRegistry));</span><br><span class="line">	converterRegistry.addConverter(<span class="keyword">new</span> StringToTimeZoneConverter());</span><br><span class="line">	converterRegistry.addConverter(<span class="keyword">new</span> ZoneIdToTimeZoneConverter());</span><br><span class="line">	converterRegistry.addConverter(<span class="keyword">new</span> ZonedDateTimeToCalendarConverter());</span><br><span class="line"></span><br><span class="line">	converterRegistry.addConverter(<span class="keyword">new</span> ObjectToObjectConverter());</span><br><span class="line">	converterRegistry.addConverter(<span class="keyword">new</span> IdToEntityConverter((ConversionService) converterRegistry));</span><br><span class="line">	converterRegistry.addConverter(<span class="keyword">new</span> FallbackObjectToStringConverter());</span><br><span class="line">	converterRegistry.addConverter(<span class="keyword">new</span> ObjectToOptionalConverter((ConversionService) converterRegistry));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该静态方法用于注册全局的、<strong>默认的</strong>转换器们，从而让Spring有了基础的转换能力，进而完成绝大部分转换工作。为了方便记忆这个注册流程，我把它绘制成图供以你保存：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201219110117341.png#pic_center" alt=""></p>
<p><strong>特别强调：转换器的注册顺序非常重要，这决定了通用转换器的匹配结果（谁在前，优先匹配谁，first win）。</strong></p>
<p>针对这幅图，你可能还会有如下疑问：</p>
<ol>
<li>JSR310转换器只看到TimeZone、ZoneId等转换，怎么没看见更为常用的LocalDate、LocalDateTime等这些类型转换呢？难道Spring默认是不支持的？<ol>
<li>答：<strong>当然不是</strong>。 这么常见的场景Spring怎能会不支持呢？不过与其说这是类型转换，倒不如说是<strong>格式化</strong>更合适。所以放在该系列后几篇关于格式化章节中再做讲述</li>
</ol>
</li>
<li>一般的Converter都见名之意，但StreamConverter有何作用呢？什么场景下会生效<ol>
<li>答：上文已讲述</li>
</ol>
</li>
<li>对于兜底的转换器，有何含义？这种极具通用性的转换器作用为何<ol>
<li>答：上文已讲述</li>
</ol>
</li>
</ol>
<p>最后，需要特别强调的是：它是一个静态方法，并且还是public的访问权限，且不仅仅只有本类调用。实际上，<code>DefaultConversionService</code>仅仅只做了这一件事，所以任何地方只要调用了该静态方法都能达到前者<strong>相同的效果</strong>，使用上可谓给与了较大的灵活性。比如Spring Boot环境下不是使用<code>DefaultConversionService</code>而是<code>ApplicationConversionService</code>，后者是对FormattingConversionService扩展，这个话题放在后面详解。</p>
<blockquote>
<p>Spring Boot在web环境默认向容易注册了一个WebConversionService，因此你有需要可直接@Autowired使用</p>
</blockquote>
<h2 id="ConversionServiceFactoryBean"><a href="#ConversionServiceFactoryBean" class="headerlink" title="ConversionServiceFactoryBean"></a>ConversionServiceFactoryBean</h2><p>顾名思义，它是用于产生<code>ConversionService</code>类型转换服务的工厂Bean，为了方便和Spring容器整合而使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConversionServiceFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">ConversionService</span>&gt;, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> Set&lt;?&gt; converters;</span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> GenericConversionService conversionService;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConverters</span><span class="params">(Set&lt;?&gt; converters)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.converters = converters;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 使用的是默认实现哦</span></span><br><span class="line">		<span class="keyword">this</span>.conversionService = <span class="keyword">new</span> DefaultConversionService();</span><br><span class="line">		ConversionServiceFactory.registerConverters(<span class="keyword">this</span>.converters, <span class="keyword">this</span>.conversionService);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ConversionService <span class="title">getObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.conversionService;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只有两个信息量需要关注：</p>
<ol>
<li>使用的是DefaultConversionService，因此那一大串的内建转换器们都会被添加进来的</li>
<li>自定义转换器可以通过<code>setConverters()</code>方法添加进来<ol>
<li>值得注意的是方法入参是<code>Set&lt;?&gt;</code>并没有明确泛型类型，因此那三种转换器(1:1/1:N/N:N)你是都可以添加.</li>
</ol>
</li>
</ol>
<h1 id="✍总结"><a href="#✍总结" class="headerlink" title="✍总结"></a>✍总结</h1><p>通读本文过后，相信能够给与你这个感觉：曾经望而却步的Spring类型转换服务<code>ConversionService</code>，其实也不过如此嘛。通篇我用了多个简单字眼来说明，因为<strong>拆开之后</strong>，无一高复杂度知识点。</p>
<p>迎难而上是积攒涨薪底气和勇气的途径，况且某些知识点其实并不难，所以我觉得从性价比角度来看这类内容是非常划算的，你pick到了麽？</p>
<p>正所谓类型转换和格式化属于两组近义词，在Spring体系中也经常交织在一起使用，有种傻傻分不清楚之感。从下篇文章起进入到本系列关于Formatter格式化器知识的梳理，什么日期格式化、@DateTimeFormat、@NumberFormat都将帮你捋清楚喽，有兴趣者可保持持续关注。</p>
<hr>
<h3 id="✔✔✔推荐阅读✔✔✔"><a href="#✔✔✔推荐阅读✔✔✔" class="headerlink" title="✔✔✔推荐阅读✔✔✔"></a>✔✔✔推荐阅读✔✔✔</h3><p>【Spring类型转换】系列：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/5daOOdhIFqrGbpgtnuQMNw" target="_blank" rel="noopener">1. 揭秘Spring类型转换 - 框架设计的基石</a></li>
<li><a href="https://mp.weixin.qq.com/s/Afu8YYyREoynAXS6YrJe7g" target="_blank" rel="noopener">2. Spring早期类型转换，基于PropertyEditor实现</a></li>
<li><a href="https://mp.weixin.qq.com/s/--UO3pH1nxTW3f5nQvEnkg" target="_blank" rel="noopener">3. 搞定收工，PropertyEditor就到这</a></li>
<li><a href="https://mp.weixin.qq.com/s/SMKs3fYoJm1Dfpy-6m_9ZQ" target="_blank" rel="noopener">4. 上新了Spring，全新一代类型转换机制</a></li>
<li><a href="https://mp.weixin.qq.com/s/wnuqbgnS-D-U48XrxHKIvg" target="_blank" rel="noopener">5. 穿过拥挤的人潮，Spring已为你制作好高级赛道</a></li>
</ul>
<p>【Jackson】系列：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/iqSN4HUoIdX0kGcSdnD7EA" target="_blank" rel="noopener">1. 初识Jackson – 世界上最好的JSON库</a></li>
<li><a href="https://mp.weixin.qq.com/s/p6cwP2BVrC8VxkN-T3uAxg" target="_blank" rel="noopener">2. 妈呀，Jackson原来是这样写JSON的</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZHb3P06IC4xElHwJqDepxw" target="_blank" rel="noopener">3. 懂了这些，方敢在简历上说会用Jackson写JSON</a></li>
<li><a href="https://mp.weixin.qq.com/s/syAOETfEawiGItaQO35mLA" target="_blank" rel="noopener">4. JSON字符串是如何被解析的？JsonParser了解一下</a></li>
<li><a href="https://mp.weixin.qq.com/s/0ZaDYb_ueFLbvOf3FbetfQ" target="_blank" rel="noopener">5. JsonFactory工厂而已，还蛮有料，这是我没想到的</a></li>
<li><a href="https://mp.weixin.qq.com/s/VYy1QVeFLRkciymFHueb5w" target="_blank" rel="noopener">6. 二十不惑，ObjectMapper使用也不再迷惑</a></li>
<li><a href="https://mp.weixin.qq.com/s/hPRdt-6sHt4rZaW2_jhdWQ" target="_blank" rel="noopener">7. Jackson用树模型处理JSON是必备技能，不信你看</a></li>
</ul>
<p>【数据校验Bean Validation】系列：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/g04HMhrjbvbPn1Mb9JYa5g" target="_blank" rel="noopener">1. 不吹不擂，第一篇就能提升你对Bean Validation数据校验的认知</a></li>
<li><a href="https://mp.weixin.qq.com/s/-KeOCq2rsXCvrqD8HYHSpQ" target="_blank" rel="noopener">2. Bean Validation声明式校验方法的参数、返回值</a></li>
<li><a href="https://mp.weixin.qq.com/s/MQjXG0cg8domRtwf3ArvHw" target="_blank" rel="noopener">3. 站在使用层面，Bean Validation这些标准接口你需要烂熟于胸</a></li>
<li><a href="https://mp.weixin.qq.com/s/jzOv67ZTSx2rByj0aeUTgw" target="_blank" rel="noopener">4. Validator校验器的五大核心组件，一个都不能少</a></li>
<li><a href="https://mp.weixin.qq.com/s/6_7gZ9jmQcDSRiARO6D-yw" target="_blank" rel="noopener">5. Bean Validation声明式验证四大级别：字段、属性、容器元素、类</a></li>
<li><a href="https://mp.weixin.qq.com/s/MN-_JCGnsEWpPJs9xQ_qZA" target="_blank" rel="noopener">6. 自定义容器类型元素验证，类级别验证（多字段联合验证）</a></li>
</ul>
<p>【新特性】系列：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/vNnfKEGRm7R3PN_lCtXJDA" target="_blank" rel="noopener">IntelliJ IDEA 2020.3正式发布，年度最后一个版本很讲武德</a></li>
<li><a href="https://mp.weixin.qq.com/s/8voJSbmcBbdfNUCUBIcKcA" target="_blank" rel="noopener">IntelliJ IDEA 2020.2正式发布，诸多亮点总有几款能助你提效</a></li>
<li><a href="">IntelliJ IDEA 2020.1正式发布，你要的Almost都在这！</a></li>
<li><a href="https://mp.weixin.qq.com/s/Sw6EqAY0DmF-p2qPoaetUg" target="_blank" rel="noopener">Spring Framework 5.3.0正式发布，在云原生路上继续发力</a></li>
<li><a href="https://mp.weixin.qq.com/s/KywpJkLDHZbZTxUf4WFxhw" target="_blank" rel="noopener">Spring Boot 2.4.0正式发布，全新的配置文件加载机制（不向下兼容）</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZoUG9h1TndW2QpnPyGeIQA" target="_blank" rel="noopener">Spring改变版本号命名规则：此举对非英语国家很友好</a></li>
<li><a href="https://mp.weixin.qq.com/s/3QaiUGzj5nW2N4Aipm47PQ" target="_blank" rel="noopener">JDK15正式发布，划时代的ZGC同时宣布转正</a></li>
</ul>
<p>【程序人生】系列：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/oEShE0fiHSGG8D89NRQYGw" target="_blank" rel="noopener">蚂蚁金服上市了，我不想努力了</a></li>
<li><a href="https://mp.weixin.qq.com/s/SZUJ0sy4vM7UH10pk6NM3g" target="_blank" rel="noopener">如果程序员和产品经理都用凡尔赛文学对话……</a></li>
<li><a href="https://mp.weixin.qq.com/s/PGIFtpI7aZaxY7es0F6C6Q" target="_blank" rel="noopener">程序人生 | 春风得意马蹄疾，一日看尽长安花</a></li>
</ul>
<p>还有诸如【Spring配置类】【Spring-static】【Spring数据绑定】【Spring Cloud Netflix】【Feign】【Ribbon】【Hystrix】…更多原创专栏，关注<code>BAT的乌托邦</code>回复<code>专栏</code>二字即可全部获取，也可加我<code>fsx1056342982</code>，交个朋友。</p>
<blockquote>
<p>有些<strong>已完结</strong>，有些<strong>连载中</strong>。我是A哥(YourBatman)，咱们下期见</p>
</blockquote>]]></content>
      <categories>
        <category>A哥学类型转换</category>
      </categories>
      <tags>
        <tag>类型转换</tag>
        <tag>ConversionService</tag>
      </tags>
  </entry>
  <entry>
    <title>5. 穿过拥挤的人潮，Spring已为你制作好高级赛道</title>
    <url>/x2y/63fb4a54.html</url>
    <content><![CDATA[<p><img data-src="https://img-blog.csdnimg.cn/20201219170756501.png#pic_center" alt=""></p>
<blockquote>
<p>分享、成长，拒绝浅藏辄止。关注公众号【<strong>BAT的乌托邦</strong>】，回复关键字<code>专栏</code>有Spring技术栈、中间件等小而美的<strong>原创专栏</strong>供以免费学习。本文已被 <a href="https://www.yourbatman.cn">https://www.yourbatman.cn</a> 收录。</p>
</blockquote>
<h1 id="✍前言"><a href="#✍前言" class="headerlink" title="✍前言"></a>✍前言</h1><p>你好，我是YourBatman。</p>
<p><a href="https://mp.weixin.qq.com/s/SMKs3fYoJm1Dfpy-6m_9ZQ" target="_blank" rel="noopener">上篇文章</a> 大篇幅把Spring全新一代类型转换器介绍完了，已经至少能够考个及格分。在介绍Spring众多内建的转换器里，我故意留下一个尾巴，放在本文专门撰文讲解。</p>
<p>为了让自己能在“拥挤的人潮中”显得不（更）一（突）样（出），A哥特意准备了这几个特殊的转换器助你破局，穿越拥挤的人潮，踏上Spring已为你制作好的高级赛道。</p>
<h2 id="版本约定"><a href="#版本约定" class="headerlink" title="版本约定"></a>版本约定</h2><ul>
<li>Spring Framework：5.3.1</li>
<li>Spring Boot：2.4.0</li>
</ul>
<p><img data-src="https://img-blog.csdnimg.cn/20201219171542857.png#pic_center" alt=""></p>
<h1 id="✍正文"><a href="#✍正文" class="headerlink" title="✍正文"></a>✍正文</h1><p>本文的焦点将集中在上文留下的4个类型转换器上。</p>
<ul>
<li>StreamConverter：将Stream流与集合/数组之间的转换，必要时转换元素类型</li>
</ul>
<p>这三个比较特殊，属于“最后的”“兜底类”类型转换器：</p>
<ul>
<li>ObjectToObjectConverter：通用的将原对象转换为目标对象（通过工厂方法or构造器）</li>
<li><code>IdToEntityConverter</code>：<strong>本文重点</strong>。给个ID自动帮你兑换成一个Entity对象</li>
<li>FallbackObjectToStringConverter：将任何对象调用<code>toString()</code>转化为String类型。当匹配不到任何转换器时，它用于兜底</li>
</ul>
<h2 id="默认转换器注册情况"><a href="#默认转换器注册情况" class="headerlink" title="默认转换器注册情况"></a>默认转换器注册情况</h2><p>Spring新一代类型转换内建了非常多的实现，这些在初始化阶段大都被默认注册进去。注册点在<code>DefaultConversionService</code>提供的一个static静态工具方法里：</p>
<blockquote>
<p>static静态方法具有与<strong>实例无关性</strong>，我个人觉得把该static方法放在一个xxxUtils里统一管理会更好，放在具体某个组件类里反倒容易产生语义上的误导性</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultConversionService：</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addDefaultConverters</span><span class="params">(ConverterRegistry converterRegistry)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 1、添加标量转换器(和数字相关)</span></span><br><span class="line">		addScalarConverters(converterRegistry);</span><br><span class="line">		<span class="comment">// 2、添加处理集合的转换器</span></span><br><span class="line">		addCollectionConverters(converterRegistry);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3、添加对JSR310时间类型支持的转换器</span></span><br><span class="line">		converterRegistry.addConverter(<span class="keyword">new</span> ByteBufferConverter((ConversionService) converterRegistry));</span><br><span class="line">		converterRegistry.addConverter(<span class="keyword">new</span> StringToTimeZoneConverter());</span><br><span class="line">		converterRegistry.addConverter(<span class="keyword">new</span> ZoneIdToTimeZoneConverter());</span><br><span class="line">		converterRegistry.addConverter(<span class="keyword">new</span> ZonedDateTimeToCalendarConverter());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 4、添加兜底转换器（上面处理不了的全交给这几个哥们处理）</span></span><br><span class="line">		converterRegistry.addConverter(<span class="keyword">new</span> ObjectToObjectConverter());</span><br><span class="line">		converterRegistry.addConverter(<span class="keyword">new</span> IdToEntityConverter((ConversionService) converterRegistry));</span><br><span class="line">		converterRegistry.addConverter(<span class="keyword">new</span> FallbackObjectToStringConverter());</span><br><span class="line">		converterRegistry.addConverter(<span class="keyword">new</span> ObjectToOptionalConverter((ConversionService) converterRegistry));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>该静态方法用于注册全局的、<strong>默认的</strong>转换器们，从而让Spring有了基础的转换能力，进而完成绝大部分转换工作。为了方便记忆这个注册流程，我把它绘制成图供以你保存：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201219110117341.png#pic_center" alt=""></p>
<p><strong>特别强调：转换器的注册顺序非常重要，这决定了通用转换器的匹配结果（谁在前，优先匹配谁）。</strong></p>
<p>针对这幅图，你可能还会有疑问：</p>
<ol>
<li>JSR310转换器只看到TimeZone、ZoneId等转换，怎么没看见更为常用的LocalDate、LocalDateTime等这些类型转换呢？难道Spring默认是不支持的？<ol>
<li>答：<strong>当然不是</strong>。 这么常见的场景Spring怎能会不支持呢？不过与其说这是类型转换，倒不如说是<strong>格式化</strong>更合适。所以会在后3篇文章格式化章节在作为重中之重讲述</li>
</ol>
</li>
<li>一般的Converter都见名之意，但StreamConverter有何作用呢？什么场景下会生效<ol>
<li>答：本文讲述</li>
</ol>
</li>
<li>对于兜底的转换器，有何含义？这种极具通用性的转换器作用为何<ol>
<li>答：本文讲述</li>
</ol>
</li>
</ol>
<h2 id="StreamConverter"><a href="#StreamConverter" class="headerlink" title="StreamConverter"></a>StreamConverter</h2><p>用于实现集合/数组类型到Stream类型的<strong>互转</strong>，这从它支持的<code>Set&lt;ConvertiblePair&gt;</code> 集合也能看出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;ConvertiblePair&gt; <span class="title">getConvertibleTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Set&lt;ConvertiblePair&gt; convertiblePairs = <span class="keyword">new</span> HashSet&lt;ConvertiblePair&gt;();</span><br><span class="line">	convertiblePairs.add(<span class="keyword">new</span> ConvertiblePair(Stream<span class="class">.<span class="keyword">class</span>, <span class="title">Collection</span>.<span class="title">class</span>))</span>;</span><br><span class="line">	convertiblePairs.add(new ConvertiblePair(Stream.class, Object[].class));</span><br><span class="line">	convertiblePairs.add(<span class="keyword">new</span> ConvertiblePair(Collection<span class="class">.<span class="keyword">class</span>, <span class="title">Stream</span>.<span class="title">class</span>))</span>;</span><br><span class="line">	convertiblePairs.add(<span class="keyword">new</span> ConvertiblePair(Object[]<span class="class">.<span class="keyword">class</span>, <span class="title">Stream</span>.<span class="title">class</span>))</span>;</span><br><span class="line">	<span class="keyword">return</span> convertiblePairs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它支持的是双向的匹配规则：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201214071848843.png#pic_center" alt=""></p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> StreamConverter&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"----------------StreamConverter---------------"</span>);</span><br><span class="line">    ConditionalGenericConverter converter = <span class="keyword">new</span> StreamConverter(<span class="keyword">new</span> DefaultConversionService());</span><br><span class="line"></span><br><span class="line">    TypeDescriptor sourceTypeDesp = TypeDescriptor.valueOf(Set<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    TypeDescriptor targetTypeDesp = TypeDescriptor.valueOf(Stream<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">boolean</span> matches = converter.matches(sourceTypeDesp, targetTypeDesp);</span><br><span class="line">    System.out.println(<span class="string">"是否能够转换："</span> + matches);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行转换</span></span><br><span class="line">    Object convert = converter.convert(Collections.singleton(<span class="number">1</span>), sourceTypeDesp, targetTypeDesp);</span><br><span class="line">    System.out.println(convert);</span><br><span class="line">    System.out.println(Stream<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">convert</span>.<span class="title">getClass</span>()))</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">----------------StreamConverter---------------</span><br><span class="line">是否能够转换：<span class="keyword">true</span></span><br><span class="line">java.util.stream.ReferencePipeline$Head@<span class="number">5</span>a01ccaa</span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p>关注点：底层依旧依赖<code>DefaultConversionService</code>完成元素与元素之间的转换。譬如本例Set -&gt; Stream的实际步骤为：</p>
<p><img data-src="https://img-blog.csdnimg.cn/2020121911403784.png#pic_center" alt=""></p>
<p>也就是说任何集合/数组类型是先转换为<strong>中间状态</strong>的List，最终调用<code>list.stream()</code>转换为Stream流的；若是逆向转换先调用<code>source.collect(Collectors.&lt;Object&gt;toList())</code>把Stream转为List后，再转为具体的集合or数组类型。</p>
<blockquote>
<p>说明：若source是数组类型，那底层实际使用的就是ArrayToCollectionConverter，注意举一反三</p>
</blockquote>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>StreamConverter它的访问权限是default，我们并不能<strong>直接</strong>使用到它。通过上面介绍可知Spring默认把它注册进了注册中心里，因此面向使用者我们直接使用转换服务接口ConversionService便可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"----------------StreamConverter使用场景---------------"</span>);</span><br><span class="line">    ConversionService conversionService = <span class="keyword">new</span> DefaultConversionService();</span><br><span class="line">    Stream&lt;Integer&gt; result = conversionService.convert(Collections.singleton(<span class="number">1</span>), Stream<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费</span></span><br><span class="line">    result.forEach(System.out::println);</span><br><span class="line">    <span class="comment">// result.forEach(System.out::println); //stream has already been operated upon or closed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">----------------StreamConverter使用场景---------------</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>再次特别强调：<strong>流只能被读（消费）一次</strong>。</p>
<p>因为有了<code>ConversionService</code>提供的强大能力，我们就可以在基于Spring/Spring Boot做二次开发时使用它，提高系统的通用性和容错性。如：当方法入参是Stream类型时，你既可以传入Stream类型，也可以是Collection类型、数组类型，是不是瞬间逼格高了起来。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201219122106697.png#pic_center" alt=""></p>
<h2 id="兜底转换器"><a href="#兜底转换器" class="headerlink" title="兜底转换器"></a>兜底转换器</h2><p>按照添加转换器的顺序，Spring在<strong>最后</strong>添加了4个通用的转换器用于兜底，你可能平时并不关注它，但它实时就在发挥着它的作用。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201219130238292.png#pic_center" alt=""></p>
<h3 id="ObjectToObjectConverter"><a href="#ObjectToObjectConverter" class="headerlink" title="ObjectToObjectConverter"></a>ObjectToObjectConverter</h3><p>将源对象转换为目标类型，非常的通用：Object -&gt; Object：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;ConvertiblePair&gt; <span class="title">getConvertibleTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> ConvertiblePair(Object<span class="class">.<span class="keyword">class</span>, <span class="title">Object</span>.<span class="title">class</span>))</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然它支持的是Object -&gt; Object，看似没有限制但其实是有约定条件的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (sourceType.getType() != targetType.getType() &amp;&amp;</span><br><span class="line">			hasConversionMethodOrConstructor(targetType.getType(), sourceType.getType()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是否能够处理的判断逻辑在于<code>hasConversionMethodOrConstructor</code>方法，直译为：是否有转换方法或者构造器。代码详细处理逻辑如下截图：</p>
<p><img data-src="https://img-blog.csdnimg.cn/2020121913140319.png#pic_center" alt=""></p>
<p>此部分逻辑可分为两个part来看：</p>
<ul>
<li>part1：从缓存中拿到Member，直接判断Member的可用性，可用的话<strong>迅速返回</strong></li>
<li>part2：若part1没有返回，就执行三部曲，尝试找到一个合适的Member，然后放进缓存内（若没有就返回null）</li>
</ul>
<h4 id="part1：快速返回流程"><a href="#part1：快速返回流程" class="headerlink" title="part1：快速返回流程"></a>part1：快速返回流程</h4><p>当不是首次进入处理时，会走快速返回流程。也就是第0步<code>isApplicable</code>判断逻辑，有这几个关注点：</p>
<ol>
<li>Member包括Method或者Constructor</li>
<li>Method：若是static静态方法，要求方法的第1个入参类型必须是源类型sourceType；若不是static方法，则要求源类型sourceType必须是<code>method.getDeclaringClass()</code>的子类型/相同类型</li>
<li>Constructor：要求构造器的第1个入参类型必须是源类型sourceType</li>
</ol>
<p><img data-src="https://img-blog.csdnimg.cn/20201219134016234.png#pic_center" alt=""></p>
<p>创建目标对象的实例，此转换器支持两种方式：</p>
<ol>
<li>通过工厂方法/实例方法创建实例（<code>method.invoke(source)</code>） </li>
<li>通过构造器创建实例（<code>ctor.newInstance(source)</code>）</li>
</ol>
<p>以上case，在下面均会给出代码示例。</p>
<h4 id="part2：三部曲流程"><a href="#part2：三部曲流程" class="headerlink" title="part2：三部曲流程"></a>part2：三部曲流程</h4><p>对于首次处理的转换，就会进入到<strong>详细</strong>的三部曲逻辑：通过反射尝试找到合适的Member用于创建目标实例，也就是上图的1、2、3步。</p>
<p><strong>step1：determineToMethod</strong>，从<code>sourceClass</code>里找实例方法，对方法有如下要求：</p>
<ul>
<li>方法名必须叫<code>&quot;to&quot; + targetClass.getSimpleName()</code>，如<code>toPerson()</code></li>
<li>方法的访问权限必须是public</li>
<li>该方法的返回值必须是目标类型或其子类型</li>
</ul>
<p><strong>step2：determineFactoryMethod</strong>，找静态工厂方法，对方法有如下要求：</p>
<ul>
<li>方法名必须为<code>valueOf(sourceClass)</code> 或者 <code>of(sourceClass)</code> 或者<code>from(sourceClass)</code></li>
<li>方法的访问权限必须是public</li>
</ul>
<p><strong>step3：determineFactoryConstructor</strong>，找构造器，对构造器有如下要求：</p>
<ul>
<li>存在一个参数，且参数类型是sourceClass类型的构造器</li>
<li>构造器的访问权限必须是public</li>
</ul>
<p>特别值得注意的是：此转换器<strong>不</strong>支持Object.toString()方法将sourceType转换为java.lang.String。对于toString()支持，请使用下面介绍的更为兜底的<code>FallbackObjectToStringConverter</code>。</p>
<h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><ul>
<li>实例方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sourceClass</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">toPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.setId(getId());</span><br><span class="line">        person.setName(<span class="string">"YourBatman-"</span>.concat(getAddress()));</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tartgetClass</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>书写测试用例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"----------------ObjectToObjectConverter---------------"</span>);</span><br><span class="line">    ConditionalGenericConverter converter = <span class="keyword">new</span> ObjectToObjectConverter();</span><br><span class="line"></span><br><span class="line">    Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">    customer.setId(<span class="number">1L</span>);</span><br><span class="line">    customer.setAddress(<span class="string">"Peking"</span>);</span><br><span class="line"></span><br><span class="line">    Object convert = converter.convert(customer, TypeDescriptor.forObject(customer), TypeDescriptor.valueOf(Person<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    System.out.println(convert);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ConversionService方式（实际使用方式）</span></span><br><span class="line">    ConversionService conversionService = <span class="keyword">new</span> DefaultConversionService();</span><br><span class="line">    Person person = conversionService.convert(customer, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">----------------ObjectToObjectConverter---------------</span><br><span class="line">Person(id=<span class="number">1</span>, name=YourBatman-Peking)</span><br><span class="line">Person(id=<span class="number">1</span>, name=YourBatman-Peking)</span><br></pre></td></tr></table></figure>

<ul>
<li>静态工厂方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sourceClass</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// targetClass</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法名称可以是：valueOf、of、from</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title">valueOf</span><span class="params">(Customer customer)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.setId(customer.getId());</span><br><span class="line">        person.setName(<span class="string">"YourBatman-"</span>.concat(customer.getAddress()));</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例完全同上，再次运行输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">----------------ObjectToObjectConverter---------------</span><br><span class="line">Person(id=<span class="number">1</span>, name=YourBatman-Peking)</span><br><span class="line">Person(id=<span class="number">1</span>, name=YourBatman-Peking)</span><br></pre></td></tr></table></figure>
<p>方法名可以为<code>valueOf、of、from</code>任意一种，这种命名方式几乎是业界不成文的规矩，所以遵守起来也会比较容易。但是：建议还是注释写好，防止别人重命名而导致转换生效。</p>
<ul>
<li>构造器</li>
</ul>
<p>基本同静态工厂方法示例，略</p>
<h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>基于本转换器可以完成任意对象 -&gt; 任意对象的转换，只需要遵循方法名/构造器默认的一切约定即可，在我们平时开发书写转换层时是非常有帮助的，借助<code>ConversionService</code>可以解决这一类问题。</p>
<blockquote>
<p>对于Object -&gt; Object的转换，另外一种方式是自定义<code>Converter&lt;S,T&gt;</code>，然后注册到注册中心。至于到底选哪种合适，这就看具体应用场景喽，本文只是多给你一种选择</p>
</blockquote>
<h3 id="IdToEntityConverter"><a href="#IdToEntityConverter" class="headerlink" title="IdToEntityConverter"></a>IdToEntityConverter</h3><p>Id(S) –&gt; Entity(T)。通过调用<strong>静态查找方法</strong>将实体ID兑换为实体对象。Entity里的该查找方法需要满足如下条件<code>find[EntityName]([IdType])</code>：</p>
<ol>
<li>必须是static静态方法</li>
<li>方法名必须为<code>find + entityName</code>。如Person类的话，那么方法名叫<code>findPerson</code></li>
<li>方法参数列表必须为1个</li>
<li>返回值类型必须是Entity类型</li>
</ol>
<blockquote>
<p>说明：此方法可以不必是public，但建议用public。这样即使JVM的Security安全级别开启也能够正常访问</p>
</blockquote>
<p>支持的转换Pair如下：ID和Entity都可以是<strong>任意类型</strong>，能转换就成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;ConvertiblePair&gt; <span class="title">getConvertibleTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> ConvertiblePair(Object<span class="class">.<span class="keyword">class</span>, <span class="title">Object</span>.<span class="title">class</span>))</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断是否能执行准换的条件是：存在符合条件的find方法，且<strong>source可以转换为ID类型</strong>（注意source能转换成id类型就成，并非目标类型哦）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">	Method finder = getFinder(targetType.getType());</span><br><span class="line">	<span class="keyword">return</span> (finder != <span class="keyword">null</span> </span><br><span class="line">		&amp;&amp; <span class="keyword">this</span>.conversionService.canConvert(sourceType, TypeDescriptor.valueOf(finder.getParameterTypes()[<span class="number">0</span>])));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据ID定位到Entity实体对象简直太太太常用了，运用好此转换器的提供的能力，或许能让你事半功倍，<strong>大大减少</strong>重复代码，写出更优雅、更简洁、更易于维护的代码。</p>
<h4 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h4><p>Entity实体：准备好符合条件的findXXX方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据ID定位一个Person实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title">findPerson</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一般根据id从数据库查，本处通过new来模拟</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.setId(id);</span><br><span class="line">        person.setName(<span class="string">"YourBatman-byFindPerson"</span>);</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用IdToEntityConverter，书写示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"----------------IdToEntityConverter---------------"</span>);</span><br><span class="line">    ConditionalGenericConverter converter = <span class="keyword">new</span> IdToEntityConverter(<span class="keyword">new</span> DefaultConversionService());</span><br><span class="line"></span><br><span class="line">    TypeDescriptor sourceTypeDesp = TypeDescriptor.valueOf(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    TypeDescriptor targetTypeDesp = TypeDescriptor.valueOf(Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">boolean</span> matches = converter.matches(sourceTypeDesp, targetTypeDesp);</span><br><span class="line">    System.out.println(<span class="string">"是否能够转换："</span> + matches);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行转换</span></span><br><span class="line">    Object convert = converter.convert(<span class="string">"1"</span>, sourceTypeDesp, targetTypeDesp);</span><br><span class="line">    System.out.println(convert);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，正常输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">----------------IdToEntityConverter---------------</span><br><span class="line">是否能够转换：<span class="keyword">true</span></span><br><span class="line">Person(id=<span class="number">1</span>, name=YourBatman-byFindPerson)</span><br></pre></td></tr></table></figure>
<p>示例效果为：传入字符串类型的“1”，就能返回得到一个Person实例。可以看到，我们传入的是字符串类型的的1，而方法入参id类型实际为Long类型，但因为它们能完成String -&gt; Long转换，因此最终还是能够得到一个Entity实例的。</p>
<h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><p>这个使用场景就比较多了，需要使用到<code>findById()</code>的地方都可以通过它来代替掉。如：</p>
<p>Controller层：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/ids/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getById</span><span class="params">(@PathVariable Person id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/ids"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getById</span><span class="params">(@RequestParam Person id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Tips：在Controller层这么写我并不建议，因为<strong>语义上</strong>没有对齐，势必在代码书写过程中带来一定的麻烦。</p>
<p>Service层：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ConversionService conversionService;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">findById</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">    Person person = conversionService.convert(id, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Tips：在Service层这么写，我个人觉得还是OK的。用类型转换的领域设计思想代替了自上而下的过程编程思想。</p>
<h3 id="FallbackObjectToStringConverter"><a href="#FallbackObjectToStringConverter" class="headerlink" title="FallbackObjectToStringConverter"></a>FallbackObjectToStringConverter</h3><p>通过简单的调用<code>Object#toString()</code>方法将任何支持的类型转换为String类型，它作为底层兜底。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;ConvertiblePair&gt; <span class="title">getConvertibleTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> ConvertiblePair(Object<span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>))</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该转换器支持CharSequence/StringWriter等类型，以及所有<code>ObjectToObjectConverter.hasConversionMethodOrConstructor(sourceClass, String.class)</code>的类型。</p>
<blockquote>
<p>说明：ObjectToObjectConverter不处理任何String类型的转换，原来都是交给它了</p>
</blockquote>
<h4 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h4><p>略。</p>
<h3 id="ObjectToOptionalConverter"><a href="#ObjectToOptionalConverter" class="headerlink" title="ObjectToOptionalConverter"></a>ObjectToOptionalConverter</h3><p>将任意类型转换为一个<code>Optional&lt;T&gt;</code>类型，它作为<strong>最最最最最</strong>底部的兜底，稍微了解下即可。</p>
<h4 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"----------------ObjectToOptionalConverter---------------"</span>);</span><br><span class="line">    ConversionService conversionService = <span class="keyword">new</span> DefaultConversionService();</span><br><span class="line">    Optional&lt;Integer&gt; result = conversionService.convert(Arrays.asList(<span class="number">2</span>), Optional<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">----------------ObjectToOptionalConverter---------------</span><br><span class="line">Optional[[<span class="number">2</span>]]</span><br></pre></td></tr></table></figure>

<h4 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h4><p>一个典型的应用场景：在Controller中可传可不传的参数中，我们不仅可以通过<code>@RequestParam(required = false) Long id</code>来做，还是可以这么写：<code>@RequestParam Optional&lt;Long&gt; id</code>。</p>
<h1 id="✍总结"><a href="#✍总结" class="headerlink" title="✍总结"></a>✍总结</h1><p>本文是对上文介绍Spring全新一代类型转换机制的补充，因为关注得人较少，所以才有机会突破。</p>
<p>针对于Spring注册转换器，需要特别注意如下几点：</p>
<ol>
<li>注册顺序很重要。先注册，先服务（若支持的话）</li>
<li>默认情况下，Spring会注册大量的内建转换器，从而支持String/数字类型转换、集合类型转换，这能解决协议层面的大部分转换问题。<ol>
<li>如Controller层，输入的是JSON字符串，可用自动被封装为数字类型、集合类型等等</li>
<li>如@Value注入的是String类型，但也可以用数字、集合类型接收 </li>
</ol>
</li>
</ol>
<p>对于复杂的对象 -&gt; 对象类型的转换，一般需要你自定义转换器，或者参照本文的标准写法完成转换。总之：Spring提供的<code>ConversionService</code>专注于类型转换服务，是一个非常非常实用的API，特别是你正在做基于Spring二次开发的情况下。</p>
<p>当然喽，关于<code>ConversionService</code>这套机制还并未详细介绍，如何使用？如何运行？如何扩展？带着这三个问题，咱们下篇见。</p>
<hr>
<h3 id="✔✔✔推荐阅读✔✔✔"><a href="#✔✔✔推荐阅读✔✔✔" class="headerlink" title="✔✔✔推荐阅读✔✔✔"></a>✔✔✔推荐阅读✔✔✔</h3><p>【Spring类型转换】系列：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/5daOOdhIFqrGbpgtnuQMNw" target="_blank" rel="noopener">1. 揭秘Spring类型转换 - 框架设计的基石</a></li>
<li><a href="https://mp.weixin.qq.com/s/Afu8YYyREoynAXS6YrJe7g" target="_blank" rel="noopener">2. Spring早期类型转换，基于PropertyEditor实现</a></li>
<li><a href="https://mp.weixin.qq.com/s/--UO3pH1nxTW3f5nQvEnkg" target="_blank" rel="noopener">3. 搞定收工，PropertyEditor就到这</a></li>
<li><a href="https://mp.weixin.qq.com/s/SMKs3fYoJm1Dfpy-6m_9ZQ" target="_blank" rel="noopener">4. 上新了Spring，全新一代类型转换机制</a></li>
</ul>
<p>【Jackson】系列：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/iqSN4HUoIdX0kGcSdnD7EA" target="_blank" rel="noopener">1. 初识Jackson – 世界上最好的JSON库</a></li>
<li><a href="https://mp.weixin.qq.com/s/p6cwP2BVrC8VxkN-T3uAxg" target="_blank" rel="noopener">2. 妈呀，Jackson原来是这样写JSON的</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZHb3P06IC4xElHwJqDepxw" target="_blank" rel="noopener">3. 懂了这些，方敢在简历上说会用Jackson写JSON</a></li>
<li><a href="https://mp.weixin.qq.com/s/syAOETfEawiGItaQO35mLA" target="_blank" rel="noopener">4. JSON字符串是如何被解析的？JsonParser了解一下</a></li>
<li><a href="https://mp.weixin.qq.com/s/0ZaDYb_ueFLbvOf3FbetfQ" target="_blank" rel="noopener">5. JsonFactory工厂而已，还蛮有料，这是我没想到的</a></li>
<li><a href="https://mp.weixin.qq.com/s/VYy1QVeFLRkciymFHueb5w" target="_blank" rel="noopener">6. 二十不惑，ObjectMapper使用也不再迷惑</a></li>
<li><a href="https://mp.weixin.qq.com/s/hPRdt-6sHt4rZaW2_jhdWQ" target="_blank" rel="noopener">7. Jackson用树模型处理JSON是必备技能，不信你看</a></li>
</ul>
<p>【数据校验Bean Validation】系列：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/g04HMhrjbvbPn1Mb9JYa5g" target="_blank" rel="noopener">1. 不吹不擂，第一篇就能提升你对Bean Validation数据校验的认知</a></li>
<li><a href="https://mp.weixin.qq.com/s/-KeOCq2rsXCvrqD8HYHSpQ" target="_blank" rel="noopener">2. Bean Validation声明式校验方法的参数、返回值</a></li>
<li><a href="https://mp.weixin.qq.com/s/MQjXG0cg8domRtwf3ArvHw" target="_blank" rel="noopener">3. 站在使用层面，Bean Validation这些标准接口你需要烂熟于胸</a></li>
<li><a href="https://mp.weixin.qq.com/s/jzOv67ZTSx2rByj0aeUTgw" target="_blank" rel="noopener">4. Validator校验器的五大核心组件，一个都不能少</a></li>
<li><a href="https://mp.weixin.qq.com/s/6_7gZ9jmQcDSRiARO6D-yw" target="_blank" rel="noopener">5. Bean Validation声明式验证四大级别：字段、属性、容器元素、类</a></li>
<li><a href="https://mp.weixin.qq.com/s/MN-_JCGnsEWpPJs9xQ_qZA" target="_blank" rel="noopener">6. 自定义容器类型元素验证，类级别验证（多字段联合验证）</a></li>
</ul>
<p>【新特性】系列：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/vNnfKEGRm7R3PN_lCtXJDA" target="_blank" rel="noopener">IntelliJ IDEA 2020.3正式发布，年度最后一个版本很讲武德</a></li>
<li><a href="https://mp.weixin.qq.com/s/8voJSbmcBbdfNUCUBIcKcA" target="_blank" rel="noopener">IntelliJ IDEA 2020.2正式发布，诸多亮点总有几款能助你提效</a></li>
<li><a href="">IntelliJ IDEA 2020.1正式发布，你要的Almost都在这！</a></li>
<li><a href="https://mp.weixin.qq.com/s/Sw6EqAY0DmF-p2qPoaetUg" target="_blank" rel="noopener">Spring Framework 5.3.0正式发布，在云原生路上继续发力</a></li>
<li><a href="https://mp.weixin.qq.com/s/KywpJkLDHZbZTxUf4WFxhw" target="_blank" rel="noopener">Spring Boot 2.4.0正式发布，全新的配置文件加载机制（不向下兼容）</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZoUG9h1TndW2QpnPyGeIQA" target="_blank" rel="noopener">Spring改变版本号命名规则：此举对非英语国家很友好</a></li>
<li><a href="https://mp.weixin.qq.com/s/3QaiUGzj5nW2N4Aipm47PQ" target="_blank" rel="noopener">JDK15正式发布，划时代的ZGC同时宣布转正</a></li>
</ul>
<p>【程序人生】系列：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/oEShE0fiHSGG8D89NRQYGw" target="_blank" rel="noopener">蚂蚁金服上市了，我不想努力了</a></li>
<li><a href="https://mp.weixin.qq.com/s/SZUJ0sy4vM7UH10pk6NM3g" target="_blank" rel="noopener">如果程序员和产品经理都用凡尔赛文学对话……</a></li>
<li><a href="https://mp.weixin.qq.com/s/PGIFtpI7aZaxY7es0F6C6Q" target="_blank" rel="noopener">程序人生 | 春风得意马蹄疾，一日看尽长安花</a></li>
</ul>
<p>还有诸如【Spring配置类】【Spring-static】【Spring数据绑定】【Spring Cloud Netflix】【Feign】【Ribbon】【Hystrix】…更多原创专栏，关注<code>BAT的乌托邦</code>回复<code>专栏</code>二字即可全部获取，也可加我<code>fsx1056342982</code>，交个朋友。</p>
<blockquote>
<p>有些<strong>已完结</strong>，有些<strong>连载中</strong>。我是A哥(YourBatman)，咱们下期再见</p>
</blockquote>]]></content>
      <categories>
        <category>A哥学类型转换</category>
      </categories>
      <tags>
        <tag>Converter</tag>
        <tag>ConverterFactory</tag>
        <tag>GenericConverter</tag>
      </tags>
  </entry>
  <entry>
    <title>4. 上新了Spring，全新一代类型转换机制</title>
    <url>/x2y/fdb22f4c.html</url>
    <content><![CDATA[<p><img data-src="https://img-blog.csdnimg.cn/2020121707475621.png#pic_center" alt=""></p>
<blockquote>
<p>分享、成长，拒绝浅藏辄止。关注公众号【<strong>BAT的乌托邦</strong>】，回复关键字<code>专栏</code>有Spring技术栈、中间件等小而美的<strong>原创专栏</strong>供以免费学习。本文已被 <a href="https://www.yourbatman.cn">https://www.yourbatman.cn</a> 收录。</p>
</blockquote>
<h1 id="✍前言"><a href="#✍前言" class="headerlink" title="✍前言"></a>✍前言</h1><p>你好，我是YourBatman。</p>
<p><a href="https://mp.weixin.qq.com/s/--UO3pH1nxTW3f5nQvEnkg" target="_blank" rel="noopener">上篇文章</a> 介绍完了Spring类型转换早期使用的PropertyEditor详细介绍，关于PropertyEditor现存的资料其实还蛮少的，希望这几篇文章能弥补这块空白，贡献一份微薄之力。</p>
<p>如果你也吐槽过PropertyEditor不好用，那么本文将对会有帮助。Spring自<strong>3.0版本</strong>开始自建了一套全新类型转换接口，这就是本文的主要内容，接下来逐步展开。</p>
<blockquote>
<p>说明：Spring自3.0后笑傲群雄，进入大一统。Java从此步入Spring的时代</p>
</blockquote>
<h2 id="版本约定"><a href="#版本约定" class="headerlink" title="版本约定"></a>版本约定</h2><ul>
<li>Spring Framework：5.3.1</li>
<li>Spring Boot：2.4.0</li>
</ul>
<p><img data-src="https://img-blog.csdnimg.cn/20201217074252478.png#pic_center" alt=""></p>
<h1 id="✍正文"><a href="#✍正文" class="headerlink" title="✍正文"></a>✍正文</h1><p>在了解新一代的转换接口之前，先思考一个问题：<strong>Spring为何要自己造一套轮子呢？</strong>  一向秉承不重复造轮子原则的Spring，不是迫不得已的话是不会去动他人奶酪的，毕竟互利共生才能长久。类型转换，作为Spring框架的基石，扮演着异常重要的角色，因此对其可扩展性、可维护性、高效性均有很高要求。</p>
<p>基于此，我们先来了解下PropertyEditor设计上到底有哪些缺陷/不足（不能满足现代化需求），让Spring“被迫”走上了自建道路。</p>
<h2 id="PropertyEditor设计缺陷"><a href="#PropertyEditor设计缺陷" class="headerlink" title="PropertyEditor设计缺陷"></a>PropertyEditor设计缺陷</h2><p>前提说明：本文指出它的设计缺陷，只讨论把它当做类型转换器在转换场景下存在的一些缺陷。</p>
<ol>
<li>职责不单一：该接口有非常多的方法，但只用到2个而已</li>
<li>类型不安全：setValue()方法入参是Object，getValue()返回值是Object，依赖于约定好的类型<strong>强转</strong>，不安全</li>
<li>线程不安全：依赖于setValue()后getValue()，实例是线程不安全的</li>
<li>语义不清晰：从语义上根本不能知道它是用于类型转换的组件</li>
<li><strong>只能用于String类型</strong>：它只能进行<strong>String &lt;-&gt; 其它类型</strong>的转换，而非更灵活的<strong>Object &lt;-&gt; Object</strong></li>
</ol>
<p>PropertyEditor存在这五宗“罪”，让Spring决定自己设计一套全新API用于专门服务于类型转换，这就是本文标题所述：新一代类型转换Converter、ConverterFactory、GenericConverter。</p>
<blockquote>
<p>关于PropertyEditor在Spring中的详情介绍，请参见文章：<a href="https://mp.weixin.qq.com/s/--UO3pH1nxTW3f5nQvEnkg" target="_blank" rel="noopener">3. 搞定收工，PropertyEditor就到这</a></p>
</blockquote>
<h2 id="新一代类型转换"><a href="#新一代类型转换" class="headerlink" title="新一代类型转换"></a>新一代类型转换</h2><p>为了解决PropertyEditor作为类型转换方式的设计缺陷，Spring 3.0版本重新设计了一套类型转换接口，有3个核心接口：</p>
<ol>
<li><code>Converter&lt;S, T&gt;</code>：Source -&gt; Target类型转换接口，适用于1:1转换</li>
<li><code>ConverterFactory&lt;S, R&gt;</code>：Source -&gt; R类型转换接口，适用于1:N转换</li>
<li><code>GenericConverter</code>：更为通用的类型转换接口，适用于N:N转换    <ol>
<li>注意：就它没有泛型约束，因为是通用</li>
</ol>
</li>
</ol>
<p>另外，还有一个条件接口<code>ConditionalConverter</code>，可跟上面3个接口搭配组合使用，提供前置条件判断验证。</p>
<p>这套接口，解决了PropertyEditor做类型转换存在的<strong>所有缺陷</strong>，且具有非常高的灵活性和可扩展性。下面进入详细了解。</p>
<h3 id="Converter"><a href="#Converter" class="headerlink" title="Converter"></a>Converter</h3><p>将源类型S转换为目标类型T。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">S</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function">T <span class="title">convert</span><span class="params">(S source)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它是个函数式接口，接口定义非常简单。适合1:1转换场景：可以将任意类型 转换为 任意类型。它的实现类非常多，部分截图如下：<br><img data-src="https://img-blog.csdnimg.cn/20201213211505110.png#pic_center" alt=""><br>值得注意的是：几乎所有实现类的访问权限都是<code>default/private</code>，只有少数几个是public公开的，下面我用代码示例来“近距离”感受一下。</p>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Converter：1:1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"----------------StringToBooleanConverter---------------"</span>);</span><br><span class="line">    Converter&lt;String, Boolean&gt; converter = <span class="keyword">new</span> StringToBooleanConverter();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// trueValues.add("true");</span></span><br><span class="line">    <span class="comment">// trueValues.add("on");</span></span><br><span class="line">    <span class="comment">// trueValues.add("yes");</span></span><br><span class="line">    <span class="comment">// trueValues.add("1");</span></span><br><span class="line">    System.out.println(converter.convert(<span class="string">"true"</span>));</span><br><span class="line">    System.out.println(converter.convert(<span class="string">"1"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// falseValues.add("false");</span></span><br><span class="line">    <span class="comment">// falseValues.add("off");</span></span><br><span class="line">    <span class="comment">// falseValues.add("no");</span></span><br><span class="line">    <span class="comment">// falseValues.add("0");</span></span><br><span class="line">    System.out.println(converter.convert(<span class="string">"FalSe"</span>));</span><br><span class="line">    System.out.println(converter.convert(<span class="string">"off"</span>));</span><br><span class="line">    <span class="comment">// 注意：空串返回的是null</span></span><br><span class="line">    System.out.println(converter.convert(<span class="string">""</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"----------------StringToCharsetConverter---------------"</span>);</span><br><span class="line">    Converter&lt;String, Charset&gt; converter2 = <span class="keyword">new</span> StringToCharsetConverter();</span><br><span class="line">    <span class="comment">// 中间横杠非必须，但强烈建议写上   不区分大小写</span></span><br><span class="line">    System.out.println(converter2.convert(<span class="string">"uTf-8"</span>));</span><br><span class="line">    System.out.println(converter2.convert(<span class="string">"utF8"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，正常输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">----------------StringToBooleanConverter---------------</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">----------------StringToCharsetConverter---------------</span><br><span class="line">UTF-<span class="number">8</span></span><br><span class="line">UTF-<span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>说明：StringToBooleanConverter/StringToCharsetConverter访问权限都是default，外部不可直接使用。此处为了做示例用到一个小技巧 -&gt; <strong>将Demo的报名调整为和转换器的一样，这样就可以直接访问</strong>。</p>
<p>关注点：true/on/yes/1都能被正确转换为<code>true</code>的，且对于英文字母来说一般都不区分大小写，增加了容错性（包括Charset的转换）。</p>
<h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><p>Converter用于解决1:1的任意类型转换，因此它必然存在一个不足：解决1:N转换问题需要写N遍，造成重复冗余代码。</p>
<p>譬如：输入是字符串，它可以转为任意数字类型，包括byte、short、int、long、double等等，如果用Converter来转换的话每个类型都得写个转换器，想想都麻烦有木有。</p>
<p>Spring早早就考虑到了该场景，提供了相应的接口来处理，它就是<code>ConverterFactory&lt;S, R&gt;</code>。</p>
<h3 id="ConverterFactory"><a href="#ConverterFactory" class="headerlink" title="ConverterFactory"></a>ConverterFactory</h3><p>从名称上看它代表一个转换工厂：可以将对象S转换为R的所有<strong>子类型</strong>，从而形成1:N的关系。</p>
<blockquote>
<p>该接口描述为xxxFactory是非常合适的，很好的表达了1:N的关系</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConverterFactory</span>&lt;<span class="title">S</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">	&lt;T extends R&gt; <span class="function">Converter&lt;S, T&gt; <span class="title">getConverter</span><span class="params">(Class&lt;T&gt; targetType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它同样也是个函数式接口。该接口的实现类并不多，Spring Framework共提供了5个内建实现（访问权限全部为default）：<br><img data-src="https://img-blog.csdnimg.cn/20201213213445555.png#pic_center" alt=""><br>以StringToNumberConverterFactory为例看看实现的套路：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToNumberConverterFactory</span> <span class="keyword">implements</span> <span class="title">ConverterFactory</span>&lt;<span class="title">String</span>, <span class="title">Number</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> &lt;T extends Number&gt; <span class="function">Converter&lt;String, T&gt; <span class="title">getConverter</span><span class="params">(Class&lt;T&gt; targetType)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> StringToNumber&lt;T&gt;(targetType);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 私有内部类：实现Converter接口。用泛型边界约束一类类型</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToNumber</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt; <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; targetType;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">StringToNumber</span><span class="params">(Class&lt;T&gt; targetType)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.targetType = targetType;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> T <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (source.isEmpty()) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> NumberUtils.parseNumber(source, <span class="keyword">this</span>.targetType);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由点知面，ConverterFactory作为Converter的工厂，对Converter进行包装，从而达到屏蔽内部实现的目的，对使用者友好，这不正是工厂模式的优点么，符合xxxFactory的语义。但你需要清除的是，工厂内部实现其实也是通过众多if else之类的去完成的，本质上并无差异。</p>
<h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ConverterFactory：1:N</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"----------------StringToNumberConverterFactory---------------"</span>);</span><br><span class="line">    ConverterFactory&lt;String, Number&gt; converterFactory = <span class="keyword">new</span> StringToNumberConverterFactory();</span><br><span class="line">    <span class="comment">// 注意：这里不能写基本数据类型。如int.class将抛错</span></span><br><span class="line">    System.out.println(converterFactory.getConverter(Integer.class).convert("1").getClass());</span><br><span class="line">    System.out.println(converterFactory.getConverter(Double.class).convert("1.1").getClass());</span><br><span class="line">    System.out.println(converterFactory.getConverter(Byte.class).convert("0x11").getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，正常输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">----------------StringToNumberConverterFactory---------------</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Integer</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Double</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Byte</span></span></span><br></pre></td></tr></table></figure>
<p>关注点：数字类型的字符串，是可以被转换为任意Java中的数字类型的，<code>String(1) -&gt;  Number(N)</code>。这便就是ConverterFactory的功劳，它能处理这一类转换问题。</p>
<h4 id="不足-1"><a href="#不足-1" class="headerlink" title="不足"></a>不足</h4><p>既然有了1:1、1:N，自然就有N:N。比如集合转换、数组转换、Map到Map的转换等等，这些N:N的场景，就需要借助下一个接口GenericConverter来实现。</p>
<h3 id="GenericConverter"><a href="#GenericConverter" class="headerlink" title="GenericConverter"></a>GenericConverter</h3><p>它是一个<strong>通用的</strong>转换接口，用于在两个或多个类型之间进行转换。相较于前两个，这是<strong>最灵活</strong>的SPI转换器接口，但也是<strong>最复杂</strong>的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Set&lt;ConvertiblePair&gt; <span class="title">getConvertibleTypes</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">Object <span class="title">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 普通POJO</span></span><br><span class="line">	<span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertiblePair</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; sourceType;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; targetType;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该接口并非函数式接口，虽然方法不多但稍显复杂。现对出现的几个类型做简单介绍：</p>
<ul>
<li><code>ConvertiblePair</code>：维护sourceType和targetType的POJO<ul>
<li>getConvertibleTypes()方法返回此Pair的<strong>Set集合</strong>。由此也能看出该转换器是可以支持N:N的（大多数情况下只写一对值而已，也有写多对的）</li>
</ul>
</li>
<li><code>TypeDescriptor</code>：类型描述。该类专用于Spring的类型转换场景，用于描述from or to的类型<ul>
<li>比单独的Type类型强大，内部借助了ResolvableType来解决泛型议题</li>
</ul>
</li>
</ul>
<p>GenericConverter的内置实现也比较多，部分截图如下：<br><img data-src="https://img-blog.csdnimg.cn/20201213224800371.png#pic_center" alt=""></p>
<blockquote>
<p><code>ConditionalGenericConverter</code>是GenericConverter和条件接口ConditionalConverter的组合，作用是在执行GenericConverter转换时增加一个<strong>前置条件判断</strong>方法。</p>
</blockquote>
<table>
<thead>
<tr>
<th>转换器</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayToArrayConverter</td>
<td>数组转数组Object[] -&gt; Object[]</td>
<td>[“1”,”2”] -&gt; [1,2]</td>
</tr>
<tr>
<td>ArrayToCollectionConverter</td>
<td>数组转集合 Object[] -&gt; Collection</td>
<td>同上</td>
</tr>
<tr>
<td>CollectionToCollectionConverter</td>
<td>数组转集合 Collection -&gt; Collection</td>
<td>同上</td>
</tr>
<tr>
<td>StringToCollectionConverter</td>
<td>字符串转集合String -&gt; Collection</td>
<td>1,2 -&gt; [1,2]</td>
</tr>
<tr>
<td>StringToArrayConverter</td>
<td>字符串转数组String -&gt; Array</td>
<td>同上</td>
</tr>
<tr>
<td>MapToMapConverter</td>
<td>Map -&gt; Map(需特别注意：key和value都支持转换才行)</td>
<td>略</td>
</tr>
<tr>
<td>CollectionToStringConverter</td>
<td>集合转字符串Collection -&gt; String</td>
<td>[1,2] -&gt; 1,2</td>
</tr>
<tr>
<td>ArrayToStringConverter</td>
<td>委托给CollectionToStringConverter完成</td>
<td>同上</td>
</tr>
<tr>
<td><code>--</code></td>
<td><code>--</code></td>
<td><code>--</code></td>
</tr>
<tr>
<td><strong>StreamConverter</strong></td>
<td>集合/数组 <code>&lt;-&gt;</code> Stream互转</td>
<td>集合/数组类型 -&gt; Stream类型</td>
</tr>
<tr>
<td><strong>IdToEntityConverter</strong></td>
<td>ID-&gt;Entity的转换</td>
<td>传入任意类型ID -&gt; 一个Entity实例</td>
</tr>
<tr>
<td><strong>ObjectToObjectConverter</strong></td>
<td>很复杂的对象转换，任意对象之间</td>
<td>obj -&gt; obj</td>
</tr>
<tr>
<td><strong>FallbackObjectToStringConverter</strong></td>
<td>上个转换器的兜底，调用Obj.toString()转换</td>
<td>obj -&gt; String</td>
</tr>
</tbody></table>
<blockquote>
<p>说明：分割线下面的4个转换器比较特殊，字面上不好理解其实际作用，比较“高级”。它们如果能被运用在日常工作中可以<strong>事半功弎</strong>，因此放在在下篇文章专门给你介绍</p>
</blockquote>
<p>下面以CollectionToCollectionConverter为例分析此转换器的“复杂”之处：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionToCollectionConverter</span> <span class="keyword">implements</span> <span class="title">ConditionalGenericConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ConversionService conversionService;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CollectionToCollectionConverter</span><span class="params">(ConversionService conversionService)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.conversionService = conversionService;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 集合转集合：如String集合转为Integer集合</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Set&lt;ConvertiblePair&gt; <span class="title">getConvertibleTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> ConvertiblePair(Collection<span class="class">.<span class="keyword">class</span>, <span class="title">Collection</span>.<span class="title">class</span>))</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是唯一构造器，必须传入ConversionService：元素与元素之间的转换是依赖于conversionService转换服务去完成的，最终完成集合到集合的转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CollectionToCollectionConverter：</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ConversionUtils.canConvertElements(sourceType.getElementTypeDescriptor(), targetType.getElementTypeDescriptor(), <span class="keyword">this</span>.conversionService);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>判断能否转换的依据：集合里的<strong>元素与元素之间</strong>是否能够转换，底层依赖于<code>ConversionService#canConvert()</code>这个API去完成判断。</p>
<p>接下来再看<strong>最复杂</strong>的转换方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CollectionToCollectionConverter：</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (source == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Collection&lt;?&gt; sourceCollection = (Collection&lt;?&gt;) source;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 判断：这些情况下，将不用执行后续转换动作了，直接返回即可</span></span><br><span class="line">		<span class="keyword">boolean</span> copyRequired = !targetType.getType().isInstance(source);</span><br><span class="line">		<span class="keyword">if</span> (!copyRequired &amp;&amp; sourceCollection.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span> source;</span><br><span class="line">		&#125;</span><br><span class="line">		TypeDescriptor elementDesc = targetType.getElementTypeDescriptor();</span><br><span class="line">		<span class="keyword">if</span> (elementDesc == <span class="keyword">null</span> &amp;&amp; !copyRequired) &#123;</span><br><span class="line">			<span class="keyword">return</span> source;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Collection&lt;Object&gt; target = CollectionFactory.createCollection(targetType.getType(),</span><br><span class="line">				(elementDesc != <span class="keyword">null</span> ? elementDesc.getType() : <span class="keyword">null</span>), sourceCollection.size());</span><br><span class="line">		<span class="comment">// 若目标类型没有指定泛型（没指定就是Object），不用遍历直接添加全部即可</span></span><br><span class="line">		<span class="keyword">if</span> (elementDesc == <span class="keyword">null</span>) &#123;</span><br><span class="line">			target.addAll(sourceCollection);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 遍历：一个一个元素的转，时间复杂度还是蛮高的</span></span><br><span class="line">			<span class="comment">// 元素转元素委托给conversionService去完成</span></span><br><span class="line">			<span class="keyword">for</span> (Object sourceElement : sourceCollection) &#123;</span><br><span class="line">				Object targetElement = <span class="keyword">this</span>.conversionService.convert(sourceElement,</span><br><span class="line">						sourceType.elementTypeDescriptor(sourceElement), elementDesc);</span><br><span class="line">				target.add(targetElement);</span><br><span class="line">				<span class="keyword">if</span> (sourceElement != targetElement) &#123;</span><br><span class="line">					copyRequired = <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> (copyRequired ? target : source);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>该转换步骤稍微有点复杂，我帮你屡清楚后有这几个关键步骤：</p>
<ol>
<li>快速返回：对于特殊情况，做快速返回处理<ol>
<li>若目标元素类型是<strong>源</strong>元素类型的子类型（或相同），就没有转换的必要了（copyRequired = false）</li>
<li>若源集合为空，或者目标集合<strong>没指定泛型</strong>，也不需要做转换动作<ol>
<li>源集合为空，还转换个啥</li>
<li>目标集合没指定泛型，那就是Object，因此可以接纳一切，还转换个啥</li>
</ol>
</li>
</ol>
</li>
<li>若没有触发快速返回。给目标创建一个<strong>新集合</strong>，然后把source的元素<strong>一个一个的</strong>放进新集合里去，这里又分为两种处理case<ol>
<li>若新集合（目标集合）没有指定泛型类型（那就是Object），就直接putAll即可，并不需要做类型转换</li>
<li>若新集合（目标集合指定了泛型类型），就<strong>遍历</strong>源集合委托<code>conversionService.convert()</code>对元素一个一个的转</li>
</ol>
</li>
</ol>
<h4 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h4><p>以CollectionToCollectionConverter做示范：<code>List&lt;String&gt; -&gt; Set&lt;Integer&gt;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"----------------CollectionToCollectionConverter---------------"</span>);</span><br><span class="line">    ConditionalGenericConverter conditionalGenericConverter = <span class="keyword">new</span> CollectionToCollectionConverter(<span class="keyword">new</span> DefaultConversionService());</span><br><span class="line">    <span class="comment">// 将Collection转为Collection（注意：没有指定泛型类型哦）</span></span><br><span class="line">    System.out.println(conditionalGenericConverter.getConvertibleTypes());</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; sourceList = Arrays.asList(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>);</span><br><span class="line">    TypeDescriptor sourceTypeDesp = TypeDescriptor.collection(List<span class="class">.<span class="keyword">class</span>, <span class="title">TypeDescriptor</span>.<span class="title">valueOf</span>(<span class="title">String</span>.<span class="title">class</span>))</span>;</span><br><span class="line">    TypeDescriptor targetTypeDesp = TypeDescriptor.collection(Set<span class="class">.<span class="keyword">class</span>, <span class="title">TypeDescriptor</span>.<span class="title">valueOf</span>(<span class="title">Integer</span>.<span class="title">class</span>))</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(conditionalGenericConverter.matches(sourceTypeDesp, targetTypeDesp));</span><br><span class="line">    Object convert = conditionalGenericConverter.convert(sourceList, sourceTypeDesp, targetTypeDesp);</span><br><span class="line">    System.out.println(convert.getClass());</span><br><span class="line">    System.out.println(convert);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，正常输出：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">[java.util.Collection -&gt; java.util.Collection]</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">LinkedHashSet</span></span></span><br><span class="line">[1, 2, 3, 4]</span><br></pre></td></tr></table></figure>
<p>关注点：target最终使用的是LinkedHashSet来存储，这结果和<code>CollectionFactory#createCollection</code>该API的实现逻辑是相关（Set类型默认创建的是LinkedHashSet实例）。</p>
<h4 id="不足-2"><a href="#不足-2" class="headerlink" title="不足"></a>不足</h4><p>如果说它的优点是功能强大，能够处理复杂类型的转换（PropertyEditor和前2个接口都只能转换<strong>单元素</strong>类型），那么缺点就是使用、自定义实现起来比较复杂。这不<strong>官方</strong>也给出了使用指导意见：在Converter/ConverterFactory接口能够满足条件的情况下，可不使用此接口就不使用。</p>
<h3 id="ConditionalConverter"><a href="#ConditionalConverter" class="headerlink" title="ConditionalConverter"></a>ConditionalConverter</h3><p>条件接口，@since 3.2。它可以为Converter、GenericConverter、ConverterFactory转换增加一个<strong>前置判断条件</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConditionalConverter</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该接口的实现，截图如下：<br><img data-src="https://img-blog.csdnimg.cn/20201214075212339.png#pic_center" alt=""><br>可以看到，只有通用转换器GenericConverter和它进行了<strong>合体</strong>。这也很容易理解，作为通用的转换器，加个前置判断将更加严谨和更安全。对于专用的转换器如Converter，它已明确规定了转换的类型，自然就不需要做前置判断喽。</p>
<h1 id="✍总结"><a href="#✍总结" class="headerlink" title="✍总结"></a>✍总结</h1><p>本文详细介绍了Spring新一代的类型转换接口，类型转换作为Spring的基石，其重要性可见一斑。</p>
<p>PropertyEditor作为Spring早期使用“转换器”，因存在众多设计缺陷自Spring 3.0起被新一代转换接口所取代，主要有：</p>
<ol>
<li><code>Converter&lt;S, T&gt;</code>：Source -&gt; Target类型转换接口，适用于1:1转换</li>
<li><code>ConverterFactory&lt;S, R&gt;</code>：Source -&gt; R类型转换接口，适用于1:N转换</li>
<li><code>GenericConverter</code>：更为通用的类型转换接口，适用于N:N转换</li>
</ol>
<p>下篇文章将针对于GenericConverter的几个特殊实现撰专文为你讲解，你也知道做难事必有所得，做难事才有可能破局、破圈，欢迎保持关注。</p>
<hr>
<h3 id="✔✔✔推荐阅读✔✔✔"><a href="#✔✔✔推荐阅读✔✔✔" class="headerlink" title="✔✔✔推荐阅读✔✔✔"></a>✔✔✔推荐阅读✔✔✔</h3><p>【Spring类型转换】系列：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/5daOOdhIFqrGbpgtnuQMNw" target="_blank" rel="noopener">1. 揭秘Spring类型转换 - 框架设计的基石</a></li>
<li><a href="https://mp.weixin.qq.com/s/Afu8YYyREoynAXS6YrJe7g" target="_blank" rel="noopener">2. Spring早期类型转换，基于PropertyEditor实现</a></li>
<li><a href="https://mp.weixin.qq.com/s/--UO3pH1nxTW3f5nQvEnkg" target="_blank" rel="noopener">3. 搞定收工，PropertyEditor就到这</a></li>
</ul>
<p>【Jackson】系列：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/iqSN4HUoIdX0kGcSdnD7EA" target="_blank" rel="noopener">1. 初识Jackson – 世界上最好的JSON库</a></li>
<li><a href="https://mp.weixin.qq.com/s/p6cwP2BVrC8VxkN-T3uAxg" target="_blank" rel="noopener">2. 妈呀，Jackson原来是这样写JSON的</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZHb3P06IC4xElHwJqDepxw" target="_blank" rel="noopener">3. 懂了这些，方敢在简历上说会用Jackson写JSON</a></li>
<li><a href="https://mp.weixin.qq.com/s/syAOETfEawiGItaQO35mLA" target="_blank" rel="noopener">4. JSON字符串是如何被解析的？JsonParser了解一下</a></li>
<li><a href="https://mp.weixin.qq.com/s/0ZaDYb_ueFLbvOf3FbetfQ" target="_blank" rel="noopener">5. JsonFactory工厂而已，还蛮有料，这是我没想到的</a></li>
<li><a href="https://mp.weixin.qq.com/s/VYy1QVeFLRkciymFHueb5w" target="_blank" rel="noopener">6. 二十不惑，ObjectMapper使用也不再迷惑</a></li>
<li><a href="https://mp.weixin.qq.com/s/hPRdt-6sHt4rZaW2_jhdWQ" target="_blank" rel="noopener">7. Jackson用树模型处理JSON是必备技能，不信你看</a></li>
</ul>
<p>【数据校验Bean Validation】系列：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/g04HMhrjbvbPn1Mb9JYa5g" target="_blank" rel="noopener">1. 不吹不擂，第一篇就能提升你对Bean Validation数据校验的认知</a></li>
<li><a href="https://mp.weixin.qq.com/s/-KeOCq2rsXCvrqD8HYHSpQ" target="_blank" rel="noopener">2. Bean Validation声明式校验方法的参数、返回值</a></li>
<li><a href="https://mp.weixin.qq.com/s/MQjXG0cg8domRtwf3ArvHw" target="_blank" rel="noopener">3. 站在使用层面，Bean Validation这些标准接口你需要烂熟于胸</a></li>
<li><a href="https://mp.weixin.qq.com/s/jzOv67ZTSx2rByj0aeUTgw" target="_blank" rel="noopener">4. Validator校验器的五大核心组件，一个都不能少</a></li>
<li><a href="https://mp.weixin.qq.com/s/6_7gZ9jmQcDSRiARO6D-yw" target="_blank" rel="noopener">5. Bean Validation声明式验证四大级别：字段、属性、容器元素、类</a></li>
<li><a href="https://mp.weixin.qq.com/s/MN-_JCGnsEWpPJs9xQ_qZA" target="_blank" rel="noopener">6. 自定义容器类型元素验证，类级别验证（多字段联合验证）</a></li>
</ul>
<p>【新特性】系列：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/vNnfKEGRm7R3PN_lCtXJDA" target="_blank" rel="noopener">IntelliJ IDEA 2020.3正式发布，年度最后一个版本很讲武德</a></li>
<li><a href="https://mp.weixin.qq.com/s/8voJSbmcBbdfNUCUBIcKcA" target="_blank" rel="noopener">IntelliJ IDEA 2020.2正式发布，诸多亮点总有几款能助你提效</a></li>
<li><a href="">IntelliJ IDEA 2020.1正式发布，你要的Almost都在这！</a></li>
<li><a href="https://mp.weixin.qq.com/s/Sw6EqAY0DmF-p2qPoaetUg" target="_blank" rel="noopener">Spring Framework 5.3.0正式发布，在云原生路上继续发力</a></li>
<li><a href="https://mp.weixin.qq.com/s/KywpJkLDHZbZTxUf4WFxhw" target="_blank" rel="noopener">Spring Boot 2.4.0正式发布，全新的配置文件加载机制（不向下兼容）</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZoUG9h1TndW2QpnPyGeIQA" target="_blank" rel="noopener">Spring改变版本号命名规则：此举对非英语国家很友好</a></li>
<li><a href="https://mp.weixin.qq.com/s/3QaiUGzj5nW2N4Aipm47PQ" target="_blank" rel="noopener">JDK15正式发布，划时代的ZGC同时宣布转正</a></li>
</ul>
<p>【程序人生】系列：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/oEShE0fiHSGG8D89NRQYGw" target="_blank" rel="noopener">蚂蚁金服上市了，我不想努力了</a></li>
<li><a href="https://mp.weixin.qq.com/s/SZUJ0sy4vM7UH10pk6NM3g" target="_blank" rel="noopener">如果程序员和产品经理都用凡尔赛文学对话……</a></li>
<li><a href="https://mp.weixin.qq.com/s/PGIFtpI7aZaxY7es0F6C6Q" target="_blank" rel="noopener">程序人生 | 春风得意马蹄疾，一日看尽长安花</a></li>
</ul>
<p>还有诸如【Spring配置类】【Spring-static】【Spring数据绑定】【Spring Cloud Netflix】【Feign】【Ribbon】【Hystrix】…更多原创专栏，关注<code>BAT的乌托邦</code>回复<code>专栏</code>二字即可全部获取，分享、成长，拒绝浅藏辄止。</p>
<blockquote>
<p>有些专栏<strong>已完结</strong>，有些正在<strong>连载中</strong>，期待你的关注、共同进步</p>
</blockquote>]]></content>
      <categories>
        <category>A哥学类型转换</category>
      </categories>
      <tags>
        <tag>Converter</tag>
        <tag>ConverterFactory</tag>
        <tag>GenericConverter</tag>
      </tags>
  </entry>
  <entry>
    <title>3. 搞定收工，PropertyEditor就到这</title>
    <url>/x2y/7889cb09.html</url>
    <content><![CDATA[<blockquote>
<p>分享、成长，拒绝浅藏辄止。搜索公众号【<strong>BAT的乌托邦</strong>】，回复关键字<code>专栏</code>有Spring技术栈、中间件等小而美的<strong>原创专栏</strong>供以免费学习。本文已被 <a href="https://www.yourbatman.cn"><strong>https://www.yourbatman.cn</strong></a> 收录。</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20201213183612314.png#pic_center" alt=""></p>
<h1 id="✍前言"><a href="#✍前言" class="headerlink" title="✍前言"></a>✍前言</h1><p>你好，我是YourBatman。</p>
<p><a href="https://mp.weixin.qq.com/s/Afu8YYyREoynAXS6YrJe7g" target="_blank" rel="noopener">上篇文章</a>介绍了PropertyEditor在类型转换里的作用，以及举例说明了Spring内置实现的PropertyEditor们，它们各司其职完成 <code>String &lt;-&gt; 各种类型</code> 的互转。</p>
<p>在知晓了这些基础知识后，本文将更进一步，为你介绍Spring是如何注册、管理这些转换器，以及如何自定义转换器去实现<strong>私有</strong>转换协议。</p>
<h2 id="版本约定"><a href="#版本约定" class="headerlink" title="版本约定"></a>版本约定</h2><ul>
<li>Spring Framework：5.3.1</li>
<li>Spring Boot：2.4.0</li>
</ul>
<h1 id="✍正文"><a href="#✍正文" class="headerlink" title="✍正文"></a>✍正文</h1><p>稍微熟悉点Spring Framework的小伙伴就知道，Spring特别擅长API设计、模块化设计。<strong>后缀模式</strong>是它常用的一种管理手段，比如<code>xxxRegistry</code>注册中心在Spring内部就有非常多：<br><img data-src="https://img-blog.csdnimg.cn/20201213100621495.png#pic_center" alt=""><br><code>xxxRegistry</code>用于<strong>管理</strong>（注册、修改、删除、查找）一类组件，当组件类型较多时使用注册中心统一管理是一种非常有效的手段。诚然，<code>PropertyEditor</code>就属于这种场景，管理它们的注册中心是<code>PropertyEditorRegistry</code>。</p>
<h2 id="PropertyEditorRegistry"><a href="#PropertyEditorRegistry" class="headerlink" title="PropertyEditorRegistry"></a>PropertyEditorRegistry</h2><p>它是管理PropertyEditor的中心接口，负责注册、查找对应的PropertyEditor。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @since 1.2.6</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PropertyEditorRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册一个转换器：该type类型【所有的属性】都将交给此转换器去转换（即使是个集合类型）</span></span><br><span class="line">    <span class="comment">// 效果等同于调用下方法：registerCustomEditor(type,null,editor);</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">registerCustomEditor</span><span class="params">(Class&lt;?&gt; requiredType, PropertyEditor propertyEditor)</span></span>;</span><br><span class="line">	<span class="comment">// 注册一个转换器：该type类型的【propertyPath】属性将交给此转换器</span></span><br><span class="line">	<span class="comment">// 此方法是重点，详解见下文</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">registerCustomEditor</span><span class="params">(Class&lt;?&gt; requiredType, String propertyPath, PropertyEditor propertyEditor)</span></span>;</span><br><span class="line">	<span class="comment">// 查找到一个合适的转换器</span></span><br><span class="line">	<span class="function">PropertyEditor <span class="title">findCustomEditor</span><span class="params">(Class&lt;?&gt; requiredType, String propertyPath)</span></span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：该API是<code>1.2.6</code>这个小版本新增的。Spring <strong>一般</strong> 不会在小版本里新增核心API以确保稳定性，但这并非100%。Spring认为该API对使用者无感的话（你不可能会用到它），增/减也是有可能的</p>
</blockquote>
<p>此接口的继承树如下：<br><img data-src="https://img-blog.csdnimg.cn/2020121310482599.png#pic_center" alt=""><br>值得注意的是：虽然此接口看似实现者众多，但其实其它<strong>所有的</strong>实现关于PropertyEditor的管理部分都是委托给<code>PropertyEditorRegistrySupport</code>来管理，<strong>无一例外</strong>。因此，本文只需关注PropertyEditorRegistrySupport足矣，这为后面的高级应用（如数据绑定、BeanWrapper等）打好坚实基础。</p>
<blockquote>
<p>用不太正确的理解可这么认为：PropertyEditorRegistry接口的唯一实现只有PropertyEditorRegistrySupport</p>
</blockquote>
<h2 id="PropertyEditorRegistrySupport"><a href="#PropertyEditorRegistrySupport" class="headerlink" title="PropertyEditorRegistrySupport"></a>PropertyEditorRegistrySupport</h2><p>它是PropertyEditorRegistry接口的实现，提供对<code>default editors</code>和<code>custom editors</code>的管理，最终主要为<code>BeanWrapperImpl</code>和<code>DataBinder</code>服务。</p>
<p>一般来说，Registry注册中心内部会使用多个Map来维护，代表注册表。此处也不例外：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 装载【默认的】编辑器们，初始化的时候会注册好</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;Class&lt;?&gt;, PropertyEditor&gt; defaultEditors;</span><br><span class="line"><span class="comment">// 如果想覆盖掉【默认行为】，可通过此Map覆盖（比如处理Charset类型你不想用默认的编辑器处理）</span></span><br><span class="line"><span class="comment">// 通过API：overrideDefaultEditor(...)放进此Map里</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;Class&lt;?&gt;, PropertyEditor&gt; overriddenDefaultEditors;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ======================注册自定义的编辑器======================</span></span><br><span class="line"><span class="comment">// 通过API：registerCustomEditor(...)放进此Map里（若没指定propertyPath）</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;Class&lt;?&gt;, PropertyEditor&gt; customEditors;</span><br><span class="line"><span class="comment">// 通过API：registerCustomEditor(...)放进此Map里（若指定了propertyPath）</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, CustomEditorHolder&gt; customEditorsForPath;</span><br></pre></td></tr></table></figure>
<p>PropertyEditorRegistrySupport使用了<strong>4个</strong> Map来维护不同来源的编辑器，作为查找的 <strong>“数据源”</strong>。<br><img data-src="https://img-blog.csdnimg.cn/20201213113728994.png#pic_center" alt=""><br>这4个Map可分为两大组，并且有如下规律：</p>
<ul>
<li>默认编辑器组：defaultEditors和overriddenDefaultEditors<ul>
<li>overriddenDefaultEditors优先级 <strong>高于</strong> defaultEditors</li>
</ul>
</li>
<li>自定义编辑器组：customEditors和customEditorsForPath<ul>
<li>它俩为互斥关系</li>
</ul>
</li>
</ul>
<p>细心的小伙伴会发现还有一个Map咱还未提到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;Class&lt;?&gt;, PropertyEditor&gt; customEditorCache;</span><br></pre></td></tr></table></figure>
<p>从属性名上理解，它表示<code>customEditors</code>属性的缓存。那么问题来了：customEditors和customEditorCache的数据结构一毛一样（都是Map），谈何缓存呢？直接从customEditors里获取值不更香吗？</p>
<h3 id="customEditorCache作用解释"><a href="#customEditorCache作用解释" class="headerlink" title="customEditorCache作用解释"></a>customEditorCache作用解释</h3><p>customEditorCache用于缓存自定义的编辑器，辅以成员属性customEditors属性一起使用。具体（唯一）使用方式在私有方法：根据类型获取自定义编辑器<code>PropertyEditorRegistrySupport#getCustomEditor</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> PropertyEditor <span class="title">getCustomEditor</span><span class="params">(Class&lt;?&gt; requiredType)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (requiredType == <span class="keyword">null</span> || <span class="keyword">this</span>.customEditors == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	PropertyEditor editor = <span class="keyword">this</span>.customEditors.get(requiredType);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重点：若customEditors没有并不代表处理不了，因为还得考虑父子关系、接口关系</span></span><br><span class="line">	<span class="keyword">if</span> (editor == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 去缓存里查询，是否存在父子类作为key的情况</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.customEditorCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">			editor = <span class="keyword">this</span>.customEditorCache.get(requiredType);</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// 若缓存没命中，就得遍历customEditors了，时间复杂度为O(n)</span></span><br><span class="line">		<span class="keyword">if</span> (editor == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Iterator&lt;Class&lt;?&gt;&gt; it = <span class="keyword">this</span>.customEditors.keySet().iterator(); it.hasNext() &amp;&amp; editor == <span class="keyword">null</span>;) &#123;</span><br><span class="line">				Class&lt;?&gt; key = it.next();</span><br><span class="line">				<span class="keyword">if</span> (key.isAssignableFrom(requiredType)) &#123;</span><br><span class="line">					editor = <span class="keyword">this</span>.customEditors.get(key);</span><br><span class="line">					<span class="keyword">if</span> (<span class="keyword">this</span>.customEditorCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="keyword">this</span>.customEditorCache = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, PropertyEditor&gt;();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">this</span>.customEditorCache.put(requiredType, editor);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> editor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段逻辑不难理解，此流程用一张图可描绘如下：<br><img data-src="https://img-blog.csdnimg.cn/20201213144711754.png#pic_center" alt=""><br>因为遍历<code>customEditors</code>属于比较重的操作（复杂度为O(n)），从而使用了customEditorCache避免每次出现父子类的匹配情况就去遍历一次，大大提高匹配效率。</p>
<p>什么时候customEditorCache会发挥作用？也就说什么时候会出现父子类匹配情况呢？为了加深理解，下面搞个例子玩一玩</p>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p>准备两个具有继承关系的实体类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>书写针对于父类（父接口）类型的编辑器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalPropertyEditor</span> <span class="keyword">extends</span> <span class="title">PropertyEditorSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAsText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsText</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：由于此部分只关注查找/匹配过程逻辑，因此对编辑器内部处理逻辑并不关心</p>
</blockquote>
<p>注册此编辑器，对应的类型为<strong>父类型</strong>：Animal</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PropertyEditorRegistry propertyEditorRegistry = <span class="keyword">new</span> PropertyEditorRegistrySupport();</span><br><span class="line">    propertyEditorRegistry.registerCustomEditor(Animal<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">AnimalPropertyEditor</span>())</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 付类型、子类型均可匹配上对应的编辑器</span></span><br><span class="line">    PropertyEditor customEditor1 = propertyEditorRegistry.findCustomEditor(Cat<span class="class">.<span class="keyword">class</span>, <span class="title">null</span>)</span>;</span><br><span class="line">    PropertyEditor customEditor2 = propertyEditorRegistry.findCustomEditor(Animal<span class="class">.<span class="keyword">class</span>, <span class="title">null</span>)</span>;</span><br><span class="line">    System.out.println(customEditor1 == customEditor2);</span><br><span class="line">    System.out.println(customEditor1.getClass().getSimpleName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line">AnimalPropertyEditor</span><br></pre></td></tr></table></figure>
<p><strong>结论</strong>：</p>
<ul>
<li>类型精确匹配优先级最高</li>
<li>若没精确匹配到结果且本类型的<strong>父类型</strong>已注册上去，则最终也会匹配成功</li>
</ul>
<p><img data-src="https://img-blog.csdnimg.cn/20201213152403888.png#pic_center" alt=""><br>customEditorCache的作用可总结为一句话：帮助customEditors属性装载对已匹配上的子类型的编辑器，从而避免了每次全部遍历，有效的提升了匹配效率。</p>
<p><strong>值得注意的是，每次调用API向<code>customEditors</code>添加新元素时，customEditorCache就会被清空，因此因尽量避免在运行期注册编辑器，以避免缓存失效而降低性能</strong></p>
<h3 id="customEditorsForPath作用解释"><a href="#customEditorsForPath作用解释" class="headerlink" title="customEditorsForPath作用解释"></a>customEditorsForPath作用解释</h3><p>上面说了，它是和customEditors互斥的。</p>
<p>customEditorsForPath的作用是能够实现<strong>更精准匹配</strong>，针对属性级别精准处理。此Map的值通过此API注册进来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerCustomEditor</span><span class="params">(Class&lt;?&gt; requiredType, String propertyPath, PropertyEditor propertyEditor)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：propertyPath不能为null才进此处，否则会注册进customEditors喽</p>
</blockquote>
<p>可能你会想，有了customEditors为何还需要customEditorsForPath呢？这里就不得不说两者的最大区别了：</p>
<ul>
<li><code>customEditors</code>：粒度较粗，通用性强。key为类型，即该类型的转换<strong>全部</strong>交给此编辑器处理<ul>
<li>如：<code>registerCustomEditor(UUID.class,new UUIDEditor())</code>，那么此编辑器就能处理全天下所有的<code>String &lt;-&gt; UUID</code> 转换工作</li>
</ul>
</li>
<li><code>customEditorsForPath</code>：粒度细精确到属性（字段）级别，有点专车专座的意思<ul>
<li>如：<code>registerCustomEditor(Person.class, &quot;cat.uuid&quot; , new UUIDEditor())</code>，那么此编辑器就有且仅能处理<code>Person.cat.uuid</code>属性，其它的一概不管</li>
</ul>
</li>
</ul>
<p>有了这种区别，注册中心在<code>findCustomEditor(requiredType,propertyPath)</code>匹配的时候也是按照优先级顺序执行匹配的：</p>
<ol>
<li>若指定了propertyPath（不为null），就先去<code>customEditorsForPath</code>里找。否则就去<code>customEditors</code>里找</li>
<li>若没有指定propertyPath（为null)，就直接去<code>customEditors</code>里找</li>
</ol>
<p>为了加深理解，讲上场景用代码实现如下。</p>
<h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><p>创建一个Person类，关联Cat</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UUID uuid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在的需求场景是：</p>
<ul>
<li>UUID类型统一交给UUIDEditor处理（当然包括Cat里面的UUID类型）</li>
<li>Person类里面的Cat的UUID类型，需要单独<strong>特殊处理</strong>，因此格式不一样需要“特殊照顾”</li>
</ul>
<p>很明显这就需要两个不同的属性编辑器来实现，然后组织起来协同工作。Spring内置了UUIDEditor可以处理一般性的UUID类型（通用），而Person <strong>专用的</strong> UUID编辑器，自定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonCatUUIDEditor</span> <span class="keyword">extends</span> <span class="title">UUIDEditor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SUFFIX = <span class="string">"_YourBatman"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAsText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getAsText().concat(SUFFIX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsText</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        text = text.replace(SUFFIX, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">super</span>.setAsText(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>向注册中心注册编辑器，并且书写测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PropertyEditorRegistry propertyEditorRegistry = <span class="keyword">new</span> PropertyEditorRegistrySupport();</span><br><span class="line">    <span class="comment">// 通用的</span></span><br><span class="line">    propertyEditorRegistry.registerCustomEditor(UUID<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">UUIDEditor</span>())</span>;</span><br><span class="line">    <span class="comment">// 专用的</span></span><br><span class="line">    propertyEditorRegistry.registerCustomEditor(Person.class, "cat.uuid", new PersonCatUUIDEditor());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    String uuidStr = <span class="string">"1-2-3-4-5"</span>;</span><br><span class="line">    String personCatUuidStr = <span class="string">"1-2-3-4-5_YourBatman"</span>;</span><br><span class="line"></span><br><span class="line">    PropertyEditor customEditor = propertyEditorRegistry.findCustomEditor(UUID<span class="class">.<span class="keyword">class</span>, <span class="title">null</span>)</span>;</span><br><span class="line">    <span class="comment">// customEditor.setAsText(personCatUuidStr); // 抛异常：java.lang.NumberFormatException: For input string: "5_YourBatman"</span></span><br><span class="line">    customEditor.setAsText(uuidStr);</span><br><span class="line">    System.out.println(customEditor.getAsText());</span><br><span class="line"></span><br><span class="line">    customEditor = propertyEditorRegistry.findCustomEditor(Person.class, "cat.uuid");</span><br><span class="line">    customEditor.setAsText(personCatUuidStr);</span><br><span class="line">    System.out.println(customEditor.getAsText());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，打印输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">00000001</span>-<span class="number">0002</span>-<span class="number">0003</span>-<span class="number">0004</span>-<span class="number">000000000005</span></span><br><span class="line"><span class="number">00000001</span>-<span class="number">0002</span>-<span class="number">0003</span>-<span class="number">0004</span>-<span class="number">000000000005</span>_YourBatman</span><br></pre></td></tr></table></figure>
<p><strong>完美。</strong></p>
<p>customEditorsForPath相当于给你留了钩子，当你在某些特殊情况需要特殊照顾的时候，你可以借助它来搞定，十分的方便。</p>
<p><strong>此方式有必要记住并且尝试，在实际开发中使用得还是比较多的。特别在你不想全局定义，且要确保向下兼容性的时候，使用抽象接口类型 + 此种方式缩小影响范围将十分有用</strong></p>
<blockquote>
<p>说明：propertyPath不仅支持Java Bean导航方式，还支持集合数组方式，如<code>Person.cats[0].uuid</code>这样格式也是ok的</p>
</blockquote>
<h2 id="PropertyEditorRegistrar"><a href="#PropertyEditorRegistrar" class="headerlink" title="PropertyEditorRegistrar"></a>PropertyEditorRegistrar</h2><p>Registrar：登记员。它一般和xxxRegistry配合使用，其实内核还是Registry，只是运用了<strong>倒排思想</strong>屏蔽一些内部实现而已。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PropertyEditorRegistrar</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">registerCustomEditors</span><span class="params">(PropertyEditorRegistry registry)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，Spring内部也有很多类似实现模式：<br><img data-src="https://img-blog.csdnimg.cn/20201213163801803.png#pic_center" alt=""></p>
<p>PropertyEditorRegistrar接口在Spring体系内唯一实现为：<code>ResourceEditorRegistrar</code>。它可值得我们絮叨絮叨。</p>
<h3 id="ResourceEditorRegistrar"><a href="#ResourceEditorRegistrar" class="headerlink" title="ResourceEditorRegistrar"></a>ResourceEditorRegistrar</h3><p>从命名上就知道它和Resource资源有关，实际上也确实如此：主要负责将<code>ResourceEditor</code>注册到注册中心里面去，用于处理形如Resource、File、URI等这些资源类型。</p>
<blockquote>
<p>你配置classpath:xxx.xml用来启动Spring容器的配置文件，String -&gt; Resource转换就是它的功劳喽</p>
</blockquote>
<p>唯一构造器为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ResourceEditorRegistrar</span><span class="params">(ResourceLoader resourceLoader, PropertyResolver propertyResolver)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">	<span class="keyword">this</span>.propertyResolver = propertyResolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>resourceLoader：一般传入ApplicationContext</li>
<li>propertyResolver：一般传入Environment</li>
</ul>
<p>很明显，它的设计就是服务于ApplicationContext上下文，在Bean创建过程中辅助<code>BeanWrapper</code>实现资源加载、转换。</p>
<p><code>BeanFactory</code>在初始化的<strong>准备过程中</strong>就将它实例化，从而具备资源处理能力：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractApplicationContext：</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		...</span><br><span class="line">		beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">		beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这也是PropertyEditorRegistrar在Spring Framework的<strong>唯一</strong>使用处，值的关注。</p>
<h2 id="PropertyEditor自动发现机制"><a href="#PropertyEditor自动发现机制" class="headerlink" title="PropertyEditor自动发现机制"></a>PropertyEditor自动发现机制</h2><p>最后介绍一个使用中的奇淫小技巧：PropertyEditor自动发现机制。</p>
<p>一般来说，我们自定义一个PropertyEditor是为了实现<strong>自定义类型 &lt;-&gt; 字符串</strong>的自动转换，它一般需要有如下步骤：</p>
<ol>
<li>为自定义类型写好一个xxxPropertyEditor（实现PropertyEditor接口）</li>
<li>将写好的编辑器注册到注册中心PropertyEditorRegistry</li>
</ol>
<p>显然步骤1属个性化行为无法替代，但步骤2属于标准行为，重复劳动是可以标准化的。自动发现机制就是用来解决此问题，对自定义的编辑器制定了如下标准：</p>
<ol>
<li>实现了PropertyEditor接口，具有<strong>空构造器</strong></li>
<li>与自定义类型<strong>同包</strong>（在同一个package内），名称必须为：<code>targetType.getName() + &quot;Editor&quot;</code></li>
</ol>
<p>这样你就无需再手动注册到注册中心了（当然手动注册了也不碍事），Spring能够自动发现它，这在有大量自定义类型编辑器的需要的时候将很有用。</p>
<blockquote>
<p>说明：此段核心逻辑在<code>BeanUtils#findEditorByConvention()</code>里，有兴趣者可看看</p>
</blockquote>
<p>值得注意的是：此机制属Spring遵循Java Bean规范而单独提供，在单独使用<code>PropertyEditorRegistry</code>时并未开启，而是在使用Spring产品级能力<code>TypeConverter</code>时有提供，这在后文将有体现，欢迎保持关注。</p>
<h1 id="✍总结"><a href="#✍总结" class="headerlink" title="✍总结"></a>✍总结</h1><p>本文在了解PropertyEditor基础支持之上，主要介绍了其注册中心<code>PropertyEditorRegistry</code>的使用。PropertyEditorRegistrySupport作为其“唯一”实现，负责管理PropertyEditor，包括通用处理和专用处理。最后介绍了PropertyEditor的自动发现机制，其实在实际生产中我并<strong>不</strong>建议使用自动机制，因为对于可能发生改变的因素，<strong>显示指定优于隐式约定</strong>。</p>
<p>关于Spring类型转换PropertyEditor相关内容就介绍到这了，虽然它很“古老”但并没有退出历史舞台，在排查问题，甚至日常扩展开发中还经常会碰到，因此<strong>强烈建议你掌握</strong>。下面起将介绍Spring类型转换的另外一个重点：新时代的类型转换服务<code>ConversionService</code>及其周边。</p>
<hr>
<h3 id="✔✔✔推荐阅读✔✔✔"><a href="#✔✔✔推荐阅读✔✔✔" class="headerlink" title="✔✔✔推荐阅读✔✔✔"></a>✔✔✔推荐阅读✔✔✔</h3><p>【Spring类型转换】系列：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/5daOOdhIFqrGbpgtnuQMNw" target="_blank" rel="noopener">1. 揭秘Spring类型转换 - 框架设计的基石</a></li>
<li><a href="https://mp.weixin.qq.com/s/Afu8YYyREoynAXS6YrJe7g" target="_blank" rel="noopener">2. Spring早期类型转换，基于PropertyEditor实现</a></li>
<li><a href="https://mp.weixin.qq.com/s/--UO3pH1nxTW3f5nQvEnkg" target="_blank" rel="noopener">3. 搞定收工，PropertyEditor就到这</a></li>
</ul>
<p>【Jackson】系列：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/iqSN4HUoIdX0kGcSdnD7EA" target="_blank" rel="noopener">1. 初识Jackson – 世界上最好的JSON库</a></li>
<li><a href="https://mp.weixin.qq.com/s/p6cwP2BVrC8VxkN-T3uAxg" target="_blank" rel="noopener">2. 妈呀，Jackson原来是这样写JSON的</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZHb3P06IC4xElHwJqDepxw" target="_blank" rel="noopener">3. 懂了这些，方敢在简历上说会用Jackson写JSON</a></li>
<li><a href="https://mp.weixin.qq.com/s/syAOETfEawiGItaQO35mLA" target="_blank" rel="noopener">4. JSON字符串是如何被解析的？JsonParser了解一下</a></li>
<li><a href="https://mp.weixin.qq.com/s/0ZaDYb_ueFLbvOf3FbetfQ" target="_blank" rel="noopener">5. JsonFactory工厂而已，还蛮有料，这是我没想到的</a></li>
<li><a href="https://mp.weixin.qq.com/s/VYy1QVeFLRkciymFHueb5w" target="_blank" rel="noopener">6. 二十不惑，ObjectMapper使用也不再迷惑</a></li>
<li><a href="https://mp.weixin.qq.com/s/hPRdt-6sHt4rZaW2_jhdWQ" target="_blank" rel="noopener">7. Jackson用树模型处理JSON是必备技能，不信你看</a></li>
</ul>
<p>【数据校验Bean Validation】系列：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/g04HMhrjbvbPn1Mb9JYa5g" target="_blank" rel="noopener">1. 不吹不擂，第一篇就能提升你对Bean Validation数据校验的认知</a></li>
<li><a href="https://mp.weixin.qq.com/s/-KeOCq2rsXCvrqD8HYHSpQ" target="_blank" rel="noopener">2. Bean Validation声明式校验方法的参数、返回值</a></li>
<li><a href="https://mp.weixin.qq.com/s/MQjXG0cg8domRtwf3ArvHw" target="_blank" rel="noopener">3. 站在使用层面，Bean Validation这些标准接口你需要烂熟于胸</a></li>
<li><a href="https://mp.weixin.qq.com/s/jzOv67ZTSx2rByj0aeUTgw" target="_blank" rel="noopener">4. Validator校验器的五大核心组件，一个都不能少</a></li>
<li><a href="https://mp.weixin.qq.com/s/6_7gZ9jmQcDSRiARO6D-yw" target="_blank" rel="noopener">5. Bean Validation声明式验证四大级别：字段、属性、容器元素、类</a></li>
<li><a href="https://mp.weixin.qq.com/s/MN-_JCGnsEWpPJs9xQ_qZA" target="_blank" rel="noopener">6. 自定义容器类型元素验证，类级别验证（多字段联合验证）</a></li>
</ul>
<p>【新特性】系列：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/vNnfKEGRm7R3PN_lCtXJDA" target="_blank" rel="noopener">IntelliJ IDEA 2020.3正式发布，年度最后一个版本很讲武德</a></li>
<li><a href="https://mp.weixin.qq.com/s/8voJSbmcBbdfNUCUBIcKcA" target="_blank" rel="noopener">IntelliJ IDEA 2020.2正式发布，诸多亮点总有几款能助你提效</a></li>
<li><a href="">IntelliJ IDEA 2020.1正式发布，你要的Almost都在这！</a></li>
<li><a href="https://mp.weixin.qq.com/s/Sw6EqAY0DmF-p2qPoaetUg" target="_blank" rel="noopener">Spring Framework 5.3.0正式发布，在云原生路上继续发力</a></li>
<li><a href="https://mp.weixin.qq.com/s/KywpJkLDHZbZTxUf4WFxhw" target="_blank" rel="noopener">Spring Boot 2.4.0正式发布，全新的配置文件加载机制（不向下兼容）</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZoUG9h1TndW2QpnPyGeIQA" target="_blank" rel="noopener">Spring改变版本号命名规则：此举对非英语国家很友好</a></li>
<li><a href="https://mp.weixin.qq.com/s/3QaiUGzj5nW2N4Aipm47PQ" target="_blank" rel="noopener">JDK15正式发布，划时代的ZGC同时宣布转正</a></li>
</ul>
<p>【程序人生】系列：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/oEShE0fiHSGG8D89NRQYGw" target="_blank" rel="noopener">蚂蚁金服上市了，我不想努力了</a></li>
<li><a href="https://mp.weixin.qq.com/s/SZUJ0sy4vM7UH10pk6NM3g" target="_blank" rel="noopener">如果程序员和产品经理都用凡尔赛文学对话……</a></li>
<li><a href="https://mp.weixin.qq.com/s/PGIFtpI7aZaxY7es0F6C6Q" target="_blank" rel="noopener">程序人生 | 春风得意马蹄疾，一日看尽长安花</a></li>
</ul>
<p>还有诸如【Spring配置类】【Spring-static】【Spring数据绑定】【Spring Cloud Netflix】【Feign】【Ribbon】【Hystrix】…更多原创专栏，关注<code>BAT的乌托邦</code>回复<code>专栏</code>二字即可全部获取，分享、成长，拒绝浅藏辄止。</p>
<blockquote>
<p>有些专栏<strong>已完结</strong>，有些正在<strong>连载中</strong>，期待你的关注、共同进步</p>
</blockquote>]]></content>
      <categories>
        <category>A哥学类型转换</category>
      </categories>
      <tags>
        <tag>Spring Framework</tag>
        <tag>类型转换</tag>
        <tag>PropertyEditor</tag>
      </tags>
  </entry>
  <entry>
    <title>2. Spring早期类型转换，基于PropertyEditor实现</title>
    <url>/x2y/e715a0e7.html</url>
    <content><![CDATA[<blockquote>
<p>青年时种下什么，老年时就收获什么。关注公众号【<strong>BAT的乌托邦</strong>】，有Spring技术栈、MyBatis、JVM、中间件等小而美的<strong>原创专栏</strong>供以免费学习。分享、成长，拒绝浅尝辄止。本文已被 <a href="https://www.yourbatman.cn"><strong>https://www.yourbatman.cn</strong></a> 收录。</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20201203061043610.jpg#pic_center" alt=""></p>
<h1 id="✍前言"><a href="#✍前言" class="headerlink" title="✍前言"></a>✍前言</h1><p>你好，我是YourBatman。</p>
<p>Spring早在1.0（2004年发布，2003年孵化中）的时候，就有了类型转换功能模块。此模块存在的必要性不必多说，相信每个同学都可理解。最初，Spring做类型转换器是基于Java标准的<code>java.beans.PropertyEditor</code>这个API去扩展实现的，直到Spring 3.0后才得以出现更好替代方案（Spring 3.0发布于2009 年12月）。</p>
<blockquote>
<p>提示：文章末尾附有Spring主要版本的发布时间和以及主要特性，感兴趣者可文末查看</p>
</blockquote>
<p>虽说Spring自3.0就提出了更为灵活、优秀的类型转换接口/服务，但是早期基于<code>PropertyEditor</code>实现的转换器并未废弃且还在发挥余热中，因此本文就针对其早期类型转换实现做出专文讲解。</p>
<h2 id="版本约定"><a href="#版本约定" class="headerlink" title="版本约定"></a>版本约定</h2><ul>
<li>Spring Framework：5.3.1</li>
<li>Spring Boot：2.4.0</li>
</ul>
<blockquote>
<p>说明：版本均于2020-11发布，且版本号均不带有<code>.RELEASE</code>后缀，这和之前是不一样的。具体原因请参考：<a href="https://mp.weixin.qq.com/s/ZoUG9h1TndW2QpnPyGeIQA" target="_blank" rel="noopener">Spring改变版本号命名规则：此举对非英语国家很友好</a></p>
</blockquote>
<h1 id="✍正文"><a href="#✍正文" class="headerlink" title="✍正文"></a>✍正文</h1><p>若你用当下的眼光去看Spring基于<code>PropertyEditor</code>的类型转换实现，会发现这么搞是存在一些设计缺陷的。当然并不能这么去看，毕竟现在都2020年了，那会才哪跟哪呢。既然Spring里的<code>PropertyEditor</code>现如今依然健在，那咱就会会它呗。</p>
<h2 id="PropertyEditor是什么？"><a href="#PropertyEditor是什么？" class="headerlink" title="PropertyEditor是什么？"></a>PropertyEditor是什么？</h2><p><code>PropertyEditor</code>位于java.beans包中，要知道这个包里面的类都是设计为Java GUI程序（AWT）服务的，所以你看官方javadoc对<code>PropertyEditor</code>的介绍也无出其右：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A PropertyEditor <span class="class"><span class="keyword">class</span> <span class="title">provides</span> <span class="title">support</span> <span class="title">for</span> <span class="title">GUIs</span> <span class="title">that</span> <span class="title">want</span> <span class="title">to</span> <span class="title">allow</span> <span class="title">users</span> <span class="title">to</span> <span class="title">edit</span> <span class="title">a</span> <span class="title">property</span> <span class="title">value</span> <span class="title">of</span> <span class="title">a</span> <span class="title">given</span> <span class="title">type</span>.</span></span><br></pre></td></tr></table></figure>
<p>为GUI程序提供支持，允许你对给定的value进行编辑，作用类似于一个转换器：GUI上你可以输入、编辑某个属性然后经过它转换成合适的类型。<br><img data-src="https://img-blog.csdnimg.cn/20201129232545656.png#pic_center" alt="Java GUI程序"></p>
<p>此接口提供的方法挺多的，和本文类型转换有关的最多只有4个：</p>
<ol>
<li><code>void setValue(Object value)</code>：设置属性值</li>
<li><code>Object getValue()</code>：获取属性值</li>
<li><code>String getAsText()</code>：输出。把属性值转换成String输出</li>
<li><code>void setAsText(String text)</code>：输入。将String转换为属性值类型输入</li>
</ol>
<p>JDK对PropertyEditor接口提供了一个默认实现<code>java.beans.PropertyEditorSupport</code>，因此我们若需扩展此接口，仅需继承此类，根据需要复写<code>getAsText/setAsText</code>这两个方法即可，Spring无一例外都是这么做的。</p>
<p>PropertyEditor作为一个JDK原生接口，内置了一些基本实现来服务于GUI程序，如：</p>
<ul>
<li><code>BooleanEditor</code>：将true/false字符串转换为Boolean类型</li>
<li><code>IntegerEditor</code>：将字符串转换为Integer类型<ul>
<li>同类别的还有LongEditor、FloatEditor…</li>
</ul>
</li>
</ul>
<p>JDK内置的实现比较少（如上），功能简陋，但对于服务GUI程序来说已经够用，毕竟界面输入的只可能是字符串，并且还均是基础类型。但这对于复杂的Spring环境、以及富文本的web环境来说就不够用了，所以Spring在此基础上有所扩展，因此才有了本文来讨论。</p>
<h3 id="注意：PropertyEditorSupport线程不安全"><a href="#注意：PropertyEditorSupport线程不安全" class="headerlink" title="注意：PropertyEditorSupport线程不安全"></a>注意：PropertyEditorSupport线程不安全</h3><p><code>PropertyEditor</code>实现的是双向类型转换：String和Object互转。调用<code>setValue()</code>方法后，需要先“缓存”起来后续才能够使用（输出）。<code>PropertyEditorSupport</code>为此提供了一个成员属性来做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PropertyEditorSupport：</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用setValue()方法对此属性赋值   getValue()方法取值</span></span><br><span class="line">	<span class="keyword">private</span> Object value;</span><br></pre></td></tr></table></figure>
<p>这么一来<code>PropertyEditorSupport</code>就是有状态的了，因此是线程不安全的。在使用过程中需要特别注意，避免出现并发风险。</p>
<blockquote>
<p>说明：Support类里还看到属性监听器<code>PropertyChangeListener</code>，因它属于GUI程序使用的组件，与我们无关，所以后续丝毫不会提及哦</p>
</blockquote>
<p>Spring内置的<strong>所有扩展</strong>均是基于PropertyEditorSupport来实现的，因此也<strong>都是</strong>线程不安全的哦~</p>
<h2 id="Spring为何基于它扩展？"><a href="#Spring为何基于它扩展？" class="headerlink" title="Spring为何基于它扩展？"></a>Spring为何基于它扩展？</h2><p>官方的javadoc都说得很清楚：PropertyEditor设计是为GUI程序服务的，那么Spring为何看上它了呢？</p>
<p>试想一下：那会的Spring只能支持xml方式配置，而XML属于文本类型配置，因此在给某个属性设定值的时候，书写上去的<strong>100%</strong>是个字符串，但是此属性对应的类型却不一定是字符串，可能是任意类型。你思考下，这种场景是不是跟GUI程序（AWT）一毛一样：输入字符串，对应任意类型。</p>
<p>为了实现这种需求，在<code>PropertyEditorSupport</code>的基础上只需要复写<code>setAsText</code>和<code>getAsText</code>这两个方法就行，然后Spring就这么干了。我<code>个人yy</code>一下，当初Spring选择这么干而没自己另起炉灶的原因可能有这么几个：</p>
<ol>
<li>本着不重复发明轮子的原则，有得用就直接用呗，况且是100%满足要求的</li>
<li>示好Java EE技术。毕竟那会Spring地位还并不稳，有大腿就先榜上</li>
<li>2003年左右，Java GUI程序还并未退出历史舞台，Spring为了通用性就选择基于它扩展喽<ol>
<li>说明：那会的通用性可能和现在通用性含义上是不一样的，需要稍作区别</li>
</ol>
</li>
</ol>
<h2 id="Spring内建扩展实现有哪些？"><a href="#Spring内建扩展实现有哪些？" class="headerlink" title="Spring内建扩展实现有哪些？"></a>Spring内建扩展实现有哪些？</h2><p>Spring为了扩展自身功能，提高配置灵活性，扩展出了非常非常多的<code>PropertyEditor</code>实现，共计40余个，部分截图如下：<br><img data-src="https://img-blog.csdnimg.cn/20201129232906258.png#pic_center" alt=""></p>
<table>
<thead>
<tr>
<th>PropertyEditor</th>
<th>功能</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>ZoneIdEditor</td>
<td>转为java.time.ZoneId</td>
<td>Asia/Shanghai</td>
</tr>
<tr>
<td>URLEditor</td>
<td>转为URL，支持传统方式<code>file:,http:</code>，也支持Spring风格：<code>classpath:,context上下文相对路径</code>等等</td>
<td><a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a></td>
</tr>
<tr>
<td>StringTrimmerEditor</td>
<td>trim()字符串，也可删除指定字符char</td>
<td>任意字符串</td>
</tr>
<tr>
<td>StringArrayPropertyEditor</td>
<td>转为字符串数组</td>
<td>A,B,C</td>
</tr>
<tr>
<td>PropertiesEditor</td>
<td>转为Properties</td>
<td>name = YourBatman</td>
</tr>
<tr>
<td>PatternEditor</td>
<td>转为Pattern</td>
<td>(\D<em>)(\d+)(.</em>)</td>
</tr>
<tr>
<td>PathEditor</td>
<td>转为java.nio.file.Path。支持传统URL和Spring风格的url</td>
<td>classpath:xxx</td>
</tr>
<tr>
<td>ClassEditor</td>
<td>转为Class</td>
<td>全类名</td>
</tr>
<tr>
<td>CustomBooleanEditor</td>
<td>转为Boolean</td>
<td>见示例</td>
</tr>
<tr>
<td>CharsetEditor</td>
<td>转为Charset</td>
<td>见示例</td>
</tr>
<tr>
<td>CustomDateEditor</td>
<td>转为java.util.Date</td>
<td>见示例</td>
</tr>
</tbody></table>
<p>Spring把实现基本(大多数)都放在<code>org.springframework.beans.propertyeditors</code>包下，接下来我挑选几个代表性API举例说明。</p>
<h3 id="标准实现示例"><a href="#标准实现示例" class="headerlink" title="标准实现示例"></a>标准实现示例</h3><ul>
<li><strong>CustomBooleanEditor</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PropertyEditor editor = <span class="keyword">new</span> CustomBooleanEditor(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这些都是true，不区分大小写</span></span><br><span class="line">    editor.setAsText(<span class="string">"trUe"</span>);</span><br><span class="line">    System.out.println(editor.getAsText());</span><br><span class="line">    editor.setAsText(<span class="string">"on"</span>);</span><br><span class="line">    System.out.println(editor.getAsText());</span><br><span class="line">    editor.setAsText(<span class="string">"yes"</span>);</span><br><span class="line">    System.out.println(editor.getAsText());</span><br><span class="line">    editor.setAsText(<span class="string">"1"</span>);</span><br><span class="line">    System.out.println(editor.getAsText());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这些都是false（注意：null并不会输出为false，而是输出空串）</span></span><br><span class="line">    editor.setAsText(<span class="keyword">null</span>);</span><br><span class="line">    System.out.println(editor.getAsText());</span><br><span class="line">    editor.setAsText(<span class="string">"fAlse"</span>);</span><br><span class="line">    System.out.println(editor.getAsText());</span><br><span class="line">    editor.setAsText(<span class="string">"off"</span>);</span><br><span class="line">    System.out.println(editor.getAsText());</span><br><span class="line">    editor.setAsText(<span class="string">"no"</span>);</span><br><span class="line">    System.out.println(editor.getAsText());</span><br><span class="line">    editor.setAsText(<span class="string">"0"</span>);</span><br><span class="line">    System.out.println(editor.getAsText());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 报错</span></span><br><span class="line">    editor.setAsText(<span class="string">"2"</span>);</span><br><span class="line">    System.out.println(editor.getAsText());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关注点：对于Spring来说，传入的<strong>true、on、yes、1</strong>等都会被“翻译”成true（字母不区分大小写），大大提高兼容性。</p>
<blockquote>
<p>现在知道为啥你用Postman传个1，用Bool值也能正常封装进去了吧，就是它的功劳。此效果等同于转换器<code>StringToBooleanConverter</code>，将在后面进行讲述对比</p>
</blockquote>
<ul>
<li><strong>CharsetEditor</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 虽然都行，但建议你规范书写：UTF-8</span></span><br><span class="line">    PropertyEditor editor = <span class="keyword">new</span> CharsetEditor();</span><br><span class="line">    editor.setAsText(<span class="string">"UtF-8"</span>);</span><br><span class="line">    System.out.println(editor.getAsText()); <span class="comment">// UTF-8</span></span><br><span class="line">    editor.setAsText(<span class="string">"utF8"</span>);</span><br><span class="line">    System.out.println(editor.getAsText()); <span class="comment">// UTF-8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关注点：utf-8中间的横杠可要可不要，但建议加上使用标准写法，另外字母也是不区分大小写的。</p>
<ul>
<li><strong>CustomDateEditor</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PropertyEditor editor = <span class="keyword">new</span> CustomDateEditor(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>),<span class="keyword">true</span>);</span><br><span class="line">    editor.setAsText(<span class="string">"2020-11-30 09:10:10"</span>);</span><br><span class="line">    System.out.println(editor.getAsText()); <span class="comment">// 2020-11-30 09:10:10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// null输出空串</span></span><br><span class="line">    editor.setAsText(<span class="keyword">null</span>);</span><br><span class="line">    System.out.println(editor.getAsText());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 报错</span></span><br><span class="line">    editor.setAsText(<span class="string">"2020-11-30"</span>);</span><br><span class="line">    System.out.println(editor.getAsText());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关注点：这个时间/日期转换器很不好用，构造时就必须指定一个<code>SimpleDateFormat</code>格式化器。在实际应用中，Spring并没有使用到它，而是用后面会说到的替代方案。</p>
<h3 id="特殊实现"><a href="#特殊实现" class="headerlink" title="特殊实现"></a>特殊实现</h3><p>把没有放在<code>org.springframework.beans.propertyeditors</code>包下的实现称作特殊实现（前者称为标准实现）。</p>
<ul>
<li><strong>MediaTypeEditor</strong>：位于org.springframework.http。依赖的核心API是<code>MediaType.parseMediaType(text)</code>，可以把诸如text/html、application/json转为MediaType对象<ul>
<li>显然它属于spring-web包，使用在web环境下</li>
</ul>
</li>
<li><strong>FormatterPropertyEditorAdapter</strong>：位于org.springframework.format.support。将3.0新增的Formatter接口适配为一个PropertyEditor：setAsText这种转换操作委托给<code>formatter.parse()</code>去完成，反向委托给<code>formatter.print()</code>去完成。<ul>
<li>此适配器在<code>DataBinder#addCustomFormatter()</code>得到应用</li>
</ul>
</li>
<li><strong>PropertyValuesEditor</strong>：位于org.springframework.beans。将k-v字符串（Properties格式）转换为一个PropertyValues，从而方便放进Environment里</li>
<li><strong>ResourceEditor</strong>：位于org.springframework.core.io。此转换器将String转换为<code>Resource</code>资源，特别实用。作为基础设施，广泛被用到Spring的很多地方<ul>
<li>像什么标准的<code>FileEditor、InputSourceEditor、InputStreamEditor、URLEditor</code>等等与资源相关的转换器，均依赖它而实现</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 支持标准URL如file:C:/myfile.txt，也支持classpath:myfile.txt</span></span><br><span class="line">    <span class="comment">// 同时还支持占位符形式</span></span><br><span class="line">    PropertyEditor editor = <span class="keyword">new</span> ResourceEditor(<span class="keyword">new</span> DefaultResourceLoader(), <span class="keyword">new</span> StandardEnvironment(), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// file:形式本处略</span></span><br><span class="line">    <span class="comment">// editor.setAsText("file:...");</span></span><br><span class="line">    <span class="comment">// System.out.println(editor.getAsText());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// classpath形式（注意：若文件不存在不会报错，而是输出null）</span></span><br><span class="line">    editor.setAsText(<span class="string">"classpath:app.properties"</span>);</span><br><span class="line">    System.out.println(editor.getAsText()); <span class="comment">// 输出带盘符的全路径</span></span><br><span class="line"></span><br><span class="line">    System.setProperty(<span class="string">"myFile.name"</span>, <span class="string">"app.properties"</span>);</span><br><span class="line">    editor.setAsText(<span class="string">"classpath:$&#123;myFile.name&#125;"</span>);</span><br><span class="line">    System.out.println(editor.getAsText()); <span class="comment">// 结果同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关注点：Spring扩展出来的Resource不仅自持常规<code>file:</code>资源协议，还支持平时使用最多的<code>classpath:</code>协议，可谓非常好用。</p>
<ul>
<li><strong>ConvertingPropertyEditorAdapter</strong>：位于org.springframework.core.convert.support。将3.0新增的<code>ConversionService</code>转换服务适配为一个<code>PropertyEditor</code>，内部转换动作都委托给前者去完成。<ul>
<li><code>AbstractPropertyBindingResult#findEditor()</code>为属性寻找合适PropertyEditor的时候，若ConversionService能支持就包装为ConvertingPropertyEditorAdapter供以使用，这是适配器模式的典型应用场景。</li>
</ul>
</li>
</ul>
<h2 id="“谁”在使用ProertyEditor"><a href="#“谁”在使用ProertyEditor" class="headerlink" title="“谁”在使用ProertyEditor"></a>“谁”在使用ProertyEditor</h2><h2 id="PropertyEditor自动发现机制"><a href="#PropertyEditor自动发现机制" class="headerlink" title="PropertyEditor自动发现机制"></a>PropertyEditor自动发现机制</h2><h2 id="PropertyEditor存在的缺陷"><a href="#PropertyEditor存在的缺陷" class="headerlink" title="PropertyEditor存在的缺陷"></a>PropertyEditor存在的缺陷</h2><p>考虑到阅读的舒适性，单篇文章不宜太长，因此涉及到<code>PropertyEditor</code>的这几个问题，放在下篇文章单独列出。这个几个问题会明显比本文更深入，欢迎保持持续关注，peace！</p>
<h1 id="✍总结"><a href="#✍总结" class="headerlink" title="✍总结"></a>✍总结</h1><p>本文主要介绍了三点内容：</p>
<ol>
<li>PropertyEditor是什么？</li>
<li>Spring为何选择基于PropertyEditor？</li>
<li>Spring内建的那些PropertyEditor都有哪些，各自什么作用？</li>
</ol>
<p>PropertyEditor虽然已经很古老，不适合当下复杂环境。但不可否认它依旧有存在的价值，Spring内部也大量的仍在使用，因此<strong>不容忽视</strong>。下篇文章将深度探讨Spring内部是如何使用PropertyEditor的，赋予了它哪些机制，以及最终为何还是决定自己另起炉灶搞一套呢？欢迎对本系列保持持续关注~</p>
<hr>
<h2 id="附：Spring主要版本发布时间和特性"><a href="#附：Spring主要版本发布时间和特性" class="headerlink" title="附：Spring主要版本发布时间和特性"></a>附：Spring主要版本发布时间和特性</h2><ul>
<li><strong>2002-02</strong>，开始开发孵化此项目，项目名叫：<code>interface21</code>，它便就是Spring的前身</li>
<li><strong>2004-03</strong>，1.0版发布。进入迅速发展期</li>
<li><strong>2006-10</strong>，2.0版发布。支持可扩展的xml配置功能、支持Java5、支持动态语言、支持更多扩展点</li>
<li><strong>2007-11</strong>，2.5版发布。项目名从此改为Spring Source，支持Java 6，支持注解配置（部分）</li>
<li><strong>2009-12</strong>，3.0版发布。这是非常非常重要的一个版本，支持了模块驱动、支持SpEL、支持Java Bean配置、支持嵌入式数据库……</li>
<li><strong>2011和2012</strong>，这两年发布了非常多的3.x系列小版本，带来了很多惊喜，同时也让Spring更加扎实</li>
<li><strong>2013-12</strong>，4.0版发布。这是有一次进步，提供了对Java 8的全面支持，支持Java EE 7、支持websocket、泛型依赖注入……</li>
<li><strong>2017-09</strong>，5.0版发布。最低JDK版本要求是Java 8，同时支持Servlet 3.1。当然最为重要的是引入了全新模块：WebFlux</li>
</ul>
<p>截止到当前，Spring Framework的最新版本是<code>5.3.x</code>版本，此版本是5.x的最后一个主要功能分支，下个版本将是6.x喽，咱们拭目以待。</p>
<hr>
<h5 id="✔推荐阅读："><a href="#✔推荐阅读：" class="headerlink" title="✔推荐阅读："></a>✔推荐阅读：</h5><ul>
<li><a href="https://mp.weixin.qq.com/s/5daOOdhIFqrGbpgtnuQMNw" target="_blank" rel="noopener">1. 揭秘Spring类型转换 - 框架设计的基石</a></li>
<li></li>
<li><a href="https://mp.weixin.qq.com/s/oEShE0fiHSGG8D89NRQYGw" target="_blank" rel="noopener">蚂蚁金服上市了，我不想努力了</a></li>
<li><a href="https://mp.weixin.qq.com/s/SZUJ0sy4vM7UH10pk6NM3g" target="_blank" rel="noopener">如果程序员和产品经理都用凡尔赛文学对话……</a></li>
<li><a href="https://mp.weixin.qq.com/s/PGIFtpI7aZaxY7es0F6C6Q" target="_blank" rel="noopener">程序人生 | 春风得意马蹄疾，一日看尽长安花</a></li>
</ul>]]></content>
      <categories>
        <category>A哥学类型转换</category>
      </categories>
      <tags>
        <tag>Spring Framework</tag>
        <tag>类型转换</tag>
        <tag>PropertyEditor</tag>
      </tags>
  </entry>
  <entry>
    <title>IntelliJ IDEA 2020.3正式发布，年度最后一个版本很讲武德</title>
    <url>/x2y/68a5f936.html</url>
    <content><![CDATA[<blockquote>
<p>仰不愧天，俯不愧人，内不愧心。关注公众号【<strong>BAT的乌托邦</strong>】，有Spring技术栈、MyBatis、JVM、中间件等小而美的<strong>原创专栏</strong>供以免费学习。分享、成长，拒绝浅尝辄止。本文已被 <a href="https://www.yourbatman.cn"><strong>https://www.yourbatman.cn</strong></a> 收录。</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20201203063806482.png#pic_center" alt=""></p>
<h1 id="✍前言"><a href="#✍前言" class="headerlink" title="✍前言"></a>✍前言</h1><p>你好，我是YourBatman。</p>
<p>2020庚子年是载入史册的一年，但对Jetbrain公司来说却是它的<strong>20周年</strong>。上个较大版本的发布，要追溯到8月份了：<br><img data-src="https://img-blog.csdnimg.cn/20201203232400898.png#pic_center" alt=""><br>时隔近4个月，北京时间2020-12-01深夜，IntelliJ IDEA再迎更新，这是2020年的第<strong>三</strong>个里程碑版本。踩着2020年的尾巴，Jetbrain团队完成了他们的“KPI”：交付了第三次里程碑版本。</p>
<p>最近几个版本的介绍这里可电梯直达：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/8voJSbmcBbdfNUCUBIcKcA" target="_blank" rel="noopener">IntelliJ IDEA 2020.2正式发布，诸多亮点总有几款能助你提效</a></li>
<li><a href="https://fangshixiang.blog.csdn.net/article/details/105435920" target="_blank" rel="noopener">IntelliJ IDEA 2020.1正式发布，你要的Almost都在这！</a></li>
<li><a href="https://fangshixiang.blog.csdn.net/article/details/103309292" target="_blank" rel="noopener">IntelliJ IDEA 2019.3正式发布，给我们带来哪些新特性？</a></li>
</ul>
<h1 id="✍正文"><a href="#✍正文" class="headerlink" title="✍正文"></a>✍正文</h1><p>我们知道，Jetbrain公司它简直就是个IDE工厂，产出过各种语言使用IDE，并且每个IDEA都做得都非常优秀，傲视群雄。本次除了发布最受瞩目的IntelliJ IDEA外，其它兄弟也相继’out’了（红红绿绿的简直亮瞎眼）：<br><img data-src="https://img-blog.csdnimg.cn/20201203234954506.png#pic_center" alt="Php"></p>
<p><img data-src="https://img-blog.csdnimg.cn/20201203234943473.png#pic_center" alt="C/C++"><br><img data-src="https://img-blog.csdnimg.cn/20201203235003913.png#pic_center" alt="Python"><br><img data-src="https://img-blog.csdnimg.cn/20201203235012145.png#pic_center" alt="HTML/CSS/JS"><br><img data-src="https://img-blog.csdnimg.cn/20201203235020689.png#pic_center" alt="Ruby">)<img data-src="https://img-blog.csdnimg.cn/20201203235240124.png#pic_center" alt="Java/Scala/Kotlin"></p>
<blockquote>
<p>说明：Go语言用的IDE <strong>Goland</strong>本次发布的是Release Candidate而非正式Release，还得过个几天（不会扣Goland团队年终奖吧）</p>
</blockquote>
<p>这么多兄弟能基于在几乎同一时间发布，有充分的理由相信它们使用的是<strong>同一基座</strong>，所以做到了一致的体验、一致的稳定、一致的优秀、一致的吃吃吃内存。<code>IntelliJ IDEA</code>作为最为出名的代表作，可以说是我们Java程序员的饭碗呀，接下来就来看看我们的<strong>新碗</strong>带来了哪些好玩的东西呢。</p>
<h2 id="what’s-new（新特性）"><a href="#what’s-new（新特性）" class="headerlink" title="what’s new（新特性）"></a>what’s new（新特性）</h2><p>此版本在<strong>调试器</strong>中添加了交互式提示和嵌入式监视，改进了对Java 15的支持，并引入了对Git暂存的支持以及其它各种功能。然后呢，有些界面上也焕然一新了，做了重新设计。</p>
<p>按照惯例，先来张启动图新老对比：<br><img data-src="https://img-blog.csdnimg.cn/20201204000830784.png#pic_center" alt=""><br><img data-src="https://img-blog.csdnimg.cn/20201204000901835.png#pic_center" alt=""><br>设计师领盒饭去吧，我觉得这个启动图很难再有进步了。</p>
<h3 id="1、全新的欢迎屏幕"><a href="#1、全新的欢迎屏幕" class="headerlink" title="1、全新的欢迎屏幕"></a>1、全新的欢迎屏幕</h3><p><img data-src="https://img-blog.csdnimg.cn/20201204001243694.png#pic_center" alt=""><br>老的在这：<br><img data-src="https://img-blog.csdnimg.cn/20201204001143210.png#pic_center" alt=""><br>这个不得不夸：进步了，更大气更方便了。此次IntelliJ IDEA欢迎屏幕经过重新设计，初始向导已替换为包含<strong>四个标签</strong>快速进入：</p>
<ul>
<li>项目管理项目</li>
<li>自定义设置IDE</li>
<li>插件安装</li>
<li>了解IntelliJ IDEA的访问帮助和学习资源<ul>
<li>如果你是IDEA的初级使用者，或者想再学习一次IDEA，从这个页面点进去将会非常适合你</li>
</ul>
</li>
</ul>
<h3 id="2、IDE主题已与操作系统设置同步"><a href="#2、IDE主题已与操作系统设置同步" class="headerlink" title="2、IDE主题已与操作系统设置同步"></a>2、IDE主题已与操作系统设置同步</h3><p>IntelliJ IDEA现在可以将其主题与您的OS主题同步。<br><img data-src="https://img-blog.csdnimg.cn/20201204001552648.png#pic_center" alt=""><br>勾选后，如果你的操作系统选用暗色主题，IDEA也会自动切换主题，保护双眼。</p>
<p>注意，有一点官方并未做出说明：<strong>此功能windows 7不支持，此功能windows 7不支持，此功能windows 7不支持</strong>，亲测截图为证：<br><img data-src="https://img-blog.csdnimg.cn/20201203070050347.png#pic_center" alt=""><br>可能你会说：为毛现在还有人用win 7？呃呃呃，我刚从XP升级上来……</p>
<h3 id="3、一键进入阅读器模式"><a href="#3、一键进入阅读器模式" class="headerlink" title="3、一键进入阅读器模式"></a>3、一键进入阅读器模式</h3><p>这个功能很赞，对阅读源码很有帮助。</p>
<p>默认情况<strong>在Reader模式下</strong>打开<strong>只读文件</strong>（也可以是本项目的只读文件）和来自外部库（Jar内）的文件，注释就像被格式化过一样，方便阅读。如下图表示你当前正在以阅读模式看此文件：<br><img data-src="https://img-blog.csdnimg.cn/20201204002500565.png#pic_center" alt=""></p>
<p>开启阅读模式的效果：像看web页面<br><img data-src="https://img-blog.csdnimg.cn/20201204002539719.png#pic_center" alt=""><br>关闭阅读模式的效果：像看html源代码<br><img data-src="https://img-blog.csdnimg.cn/20201204002640736.png#pic_center" alt=""><br>简单的说：阅读器模式就是帮你翻译了一下javadoc，<strong>更适合源码阅读</strong>。默认情况下是关闭的，建议你<strong>全局开启</strong>（或者在页面右上角单独点击开启亦可）：<br><img data-src="https://img-blog.csdnimg.cn/20201203070545388.png#pic_center" alt=""></p>
<h3 id="3、LightEdit模式优化"><a href="#3、LightEdit模式优化" class="headerlink" title="3、LightEdit模式优化"></a>3、LightEdit模式优化</h3><p>还记得LightEdit模式吗？它是在2020.1版本（2020-04发布）引进的新功能：<br><img data-src="https://img-blog.csdnimg.cn/20201203071338579.png#pic_center" alt=""><br>本次改进：现在要从命令行以<code>LightEdit</code>模式打开文件，只需<code>idea -e xxx</code>命令即可（若-e后不写文件名，那就打开上次刚打开的文件）。</p>
<p>我个人觉得此功能鸡肋，至少对我来说很鸡肋，只玩过没实际用过，毕竟只打开一个文件的话我用普通编辑器更轻量些不香吗？</p>
<h3 id="4、改进的拼写检查"><a href="#4、改进的拼写检查" class="headerlink" title="4、改进的拼写检查"></a>4、改进的拼写检查</h3><p>一句话：就是帮你检查你的单词是不是拼写错了，并且给出建议（可自定义字典）：<br><img data-src="https://img-blog.csdnimg.cn/20201203072103799.png#pic_center" alt=""><br>看起来挺智能，实际然并卵，毕竟咱们方法名起个都费劲，还用应为写注释？拼写检查可作用在<strong>doc注释</strong>上、<strong>字符串</strong>上。但不可检查变量名、方法名上~</p>
<p>对于大多数程序员来说（如果你不做开源项目，个别拼错无所谓），建议关闭拼写检查，毕竟它还是耗性能的，特别是windows用户（手动o(╥﹏╥)o）。</p>
<h3 id="5、更强的Serch-Everywhere"><a href="#5、更强的Serch-Everywhere" class="headerlink" title="5、更强的Serch Everywhere"></a>5、更强的Serch Everywhere</h3><p>这个搜索更加强大了：新增了对git的支持，可以根据commit id等git相关元素进行搜索啦。</p>
<p>老的：<br><img data-src="https://img-blog.csdnimg.cn/20201204003458410.png#pic_center" alt=""><br>新的：增加了Git Refs选项（暂忽略Calc）<br><img data-src="https://img-blog.csdnimg.cn/20201204003548592.png#pic_center" alt=""><br>现在如果你只知道一个commit id就可以拿去搜啦~</p>
<h3 id="6、浏览项目新增预览模式"><a href="#6、浏览项目新增预览模式" class="headerlink" title="6、浏览项目新增预览模式"></a>6、浏览项目新增预览模式</h3><p>提效神器，如下图（Project视窗）：<br><img data-src="https://img-blog.csdnimg.cn/20201203072742482.png#pic_center" alt=""><br>点击（Project视窗）右上角设置图标，把图中红框部门勾选上就开启预览模式浏览项目，就开启了预览模式。</p>
<p>什么叫预览模式：之前打开文件你需要<strong>双击</strong>，现在光标定位在哪个文件就显示哪个其对应内容，所以就支持键盘操作啦（上下键、tab键），不用依赖鼠标真的十分方便，提效神器啊。</p>
<h3 id="7、在IDEA内部直接更新JDK"><a href="#7、在IDEA内部直接更新JDK" class="headerlink" title="7、在IDEA内部直接更新JDK"></a>7、在IDEA内部直接更新JDK</h3><p>在之前版本介绍中知道现在可以在IDEA内部直接下载JDK（非Oracle官方的），这次更狠：可以在IDEA内直接升级JDK了（若有更新的话）。</p>
<p>我个人觉得此功能<strong>鸡肋</strong>，毕竟JDK谁会轻易去换呢。毕竟<strong>你发任你发，我用Java 8。</strong></p>
<h3 id="8、拖拽标签页"><a href="#8、拖拽标签页" class="headerlink" title="8、拖拽标签页"></a>8、拖拽标签页</h3><p>有些时候我们希望在处理一个项目时多打开几个选项卡（毕竟我们外接屏幕比较大嘛），有点分屏的意思。以前处理起来比较困难：先选中标签页右键，然后选择合适的split方式。现在很简单啦：可以通过<strong>拖放文件</strong>选项卡来水平或垂直地分割编辑器<br><img data-src="https://img-blog.csdnimg.cn/20201204005303696.gif#pic_center" alt=""><br>如果想分屏的文件不在顶部选项卡里，IDEA也为你考虑到了，最近文件里也给你提供了入口：<br><img data-src="https://img-blog.csdnimg.cn/2020120400563848.png#pic_center" alt=""></p>
<h3 id="8、IDEA设为某些文件默认打开程序"><a href="#8、IDEA设为某些文件默认打开程序" class="headerlink" title="8、IDEA设为某些文件默认打开程序"></a>8、IDEA设为某些文件默认打开程序</h3><p>感觉IDEA的侵占欲越来越强了啊，它不仅仅只想做个开发用的IDE，我们的文本编辑工作它都想接管。这不你可以设置某些类型的文件默认打开程序为IDEA了：<br><img data-src="https://img-blog.csdnimg.cn/20201204010506483.png#pic_center" alt=""></p>
<h3 id="9、调试器-交互式提示"><a href="#9、调试器-交互式提示" class="headerlink" title="9、调试器 - 交互式提示"></a>9、调试器 - 交互式提示</h3><p>当你在debug模式下运行时，可以直接点击变量后面的“小按钮”，弹出交互式窗口，从而可直接修改其值（做小家），大大方便了调试：<br><img data-src="https://img-blog.csdnimg.cn/20201204011356908.png#pic_center" alt=""><br>老版这里是木有可点按钮的：<br><img data-src="https://img-blog.csdnimg.cn/20201204011213761.png#pic_center" alt=""><br>若想要修改变量的值，得到底部的专门的窗口来，<strong>并且还得右键</strong>，选择set value才能达到目的，路径还是蛮长的：<br><img data-src="https://img-blog.csdnimg.cn/20201204011538706.png#pic_center" alt=""></p>
<h3 id="10、调试器-内联watches"><a href="#10、调试器-内联watches" class="headerlink" title="10、调试器 - 内联watches"></a>10、调试器 - 内联watches</h3><p>这也是调试的时候经常用到的一个功能：watch观察一个表达式的值。这在新版本里操作方便到令人发指：<br><img data-src="https://img-blog.csdnimg.cn/20201204011949603.png#pic_center" alt=""><br>点击这个按钮后就把i加入观察了，直接在程序里就可以观察到：<strong>所见即所得</strong><br><img data-src="https://img-blog.csdnimg.cn/20201204012138920.png#pic_center" alt=""><br>若是以前版本的IDEA：<br><img data-src="https://img-blog.csdnimg.cn/20201204012319583.png#pic_center" alt=""><br>哎哟麻烦，技术真的具有<strong>不可逆性</strong>，用过就回不去喽。</p>
<h3 id="11、Profiler-更强大的分析器工具窗口"><a href="#11、Profiler-更强大的分析器工具窗口" class="headerlink" title="11、Profiler - 更强大的分析器工具窗口"></a>11、Profiler - 更强大的分析器工具窗口</h3><p>Profiler功能在2020.1就引入了，当时作为一个试验功能，但是Jetbrain承诺将来的方向会一直迭代它，然后它变得越来越强了。</p>
<p>上个版本，我们要用它分析一个<code>xxx.hprof</code>需要如下步骤：</p>
<ol>
<li>通过jps命令找到java进程id</li>
<li>通过jmap -dump xxx生成一个hprof文件</li>
<li>将此快照文件放进IDEA的Profiler里来进行分析</li>
</ol>
<blockquote>
<p>具体操作示例，参见这篇文章：<a href="https://mp.weixin.qq.com/s/8voJSbmcBbdfNUCUBIcKcA" target="_blank" rel="noopener">IntelliJ IDEA 2020.2正式发布，诸多亮点总有几款能助你提效</a></p>
</blockquote>
<p>如果需要分析的项目就是本地项目，这顿操作还是非常麻烦的。既然是本地项目有木有更便捷的方法呢？IDEA在此版本给出了答案：<br><img data-src="https://img-blog.csdnimg.cn/20201204013929875.png#pic_center" alt=""><br>它允许你可以将分析器<strong>直接附加</strong>到<strong>正在运行</strong>的应用程序上，进而选择要执行的功能：分析快照、监控CPU内存等等。</p>
<h3 id="12、Profiler-对-jfr和-hprof轻松访问"><a href="#12、Profiler-对-jfr和-hprof轻松访问" class="headerlink" title="12、Profiler - 对.jfr和.hprof轻松访问"></a>12、Profiler - 对.jfr和.hprof轻松访问</h3><p>在这之前，我们需要分析一个现成的<code>.hprof</code>文件，只能在Profiler视窗里把它导入进来。现在更加方便了，直接可以通过<code>File - Open</code>打开此文件，即自动调起Profiler视窗进行分析。</p>
<h3 id="13、主菜单栏VCS-gt-Git"><a href="#13、主菜单栏VCS-gt-Git" class="headerlink" title="13、主菜单栏VCS -&gt; Git"></a>13、主菜单栏VCS -&gt; Git</h3><p>不说了，一切看图说话：<br><img data-src="https://img-blog.csdnimg.cn/20201204014653510.png#pic_center" alt=""><br>老版本是这样的：<br><img data-src="https://img-blog.csdnimg.cn/20201204014726897.png#pic_center" alt=""><br>这侧面也说明了什么问题呢：Git现在是VCS（version control system）版本控制系统的事实标准，勇敢点说甚至是<strong>唯一</strong>标准。</p>
<h3 id="14、基于机器学习的代码完成"><a href="#14、基于机器学习的代码完成" class="headerlink" title="14、基于机器学习的代码完成"></a>14、基于机器学习的代码完成</h3><p>现在啥都跟机器学习扯上关系，IDEA号称这个代码补全建议在新版本里是基于机器学习技术搞的，我竟然信了。</p>
<p>要查看新的这套推荐系统是如何工作的，这么打开设置即可：<br><img data-src="https://img-blog.csdnimg.cn/20201204015636253.png#pic_center" alt=""><br>这样你就可以看到本次推荐的排名情况喽：<br><img data-src="https://img-blog.csdnimg.cn/20201204015851426.png#pic_center" alt=""></p>
<p>总之IDEA的自动代码完成/补全是一绝，用得越多它就越懂你，好像成为好朋友一样，有温度了。</p>
<h3 id="15、其它"><a href="#15、其它" class="headerlink" title="15、其它"></a>15、其它</h3><p>对Kotlin、Scala等的（新特性）支持，支持<strong>http -&gt; cURL</strong>转换，更好的url自动补全，对Spring更好的支持等等。</p>
<p>当然还少不了对Javascript，以及当先很火的云原生<code>Kubernetes</code>的支持（主要体现在日志、脚本、配置上），这些因为不太普适，因此留给你在使用过程中慢慢发现吧。</p>
<p>另外，值得关注的是此版本的IDEA已经支持到了<code>Maven 3.7.0</code>，虽然后者还未正式发布，但这是马上的事，所以IDEA就提前先给支持喽。</p>
<h2 id="升级建议"><a href="#升级建议" class="headerlink" title="升级建议"></a>升级建议</h2><p>升。毕竟我木有“正版”烦恼，O(∩_∩)O哈哈~：<br><img data-src="https://img-blog.csdnimg.cn/2020120402083830.png#pic_center" alt=""></p>
<h1 id="✍总结"><a href="#✍总结" class="headerlink" title="✍总结"></a>✍总结</h1><p>作为2020年的封板之作，这个版本我个人觉得还是很讲武德的，符合定位。主要喜欢：</p>
<ol>
<li>某些外观UI的重新设计，缓解了审美疲劳</li>
<li>阅读器模式，很赞</li>
<li>调试器的增强，是真的爱了，调试效率再进一步</li>
</ol>
<p>虽然说坐在第二排看戏是最安全的，但每次我都安奈不住想尝试新功能的心，所以我也邀你一起吧，come on<br><img data-src="https://img-blog.csdnimg.cn/20201204021312119.png#pic_center" alt=""><br>最后不能忘了，依旧要向那些孜孜不倦为IT行业提供优秀工具的人们致敬！！！特别是捷克的那些创造者们，你们创造了非常好的工具提高了生产力，<strong>推动了社会某些产业的进步，功勋卓越！！！</strong></p>
<hr>
<h5 id="✔推荐阅读："><a href="#✔推荐阅读：" class="headerlink" title="✔推荐阅读："></a>✔推荐阅读：</h5><ul>
<li><a href="https://mp.weixin.qq.com/s/8voJSbmcBbdfNUCUBIcKcA" target="_blank" rel="noopener">IntelliJ IDEA 2020.2正式发布，诸多亮点总有几款能助你提效</a></li>
<li><a href="https://fangshixiang.blog.csdn.net/article/details/105435920" target="_blank" rel="noopener">IntelliJ IDEA 2020.1正式发布，你要的Almost都在这！</a></li>
<li><a href="https://fangshixiang.blog.csdn.net/article/details/103309292" target="_blank" rel="noopener">IntelliJ IDEA 2019.3正式发布，给我们带来哪些新特性？</a></li>
<li></li>
<li><a href="https://fangshixiang.blog.csdn.net/article/details/109698458" target="_blank" rel="noopener">Spring Framework 5.3.0正式发布，在云原生路上继续发力</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZoUG9h1TndW2QpnPyGeIQA" target="_blank" rel="noopener">Spring改变版本号命名规则：此举对非英语国家很友好</a></li>
<li><a href="https://mp.weixin.qq.com/s/3QaiUGzj5nW2N4Aipm47PQ" target="_blank" rel="noopener">JDK15正式发布，划时代的ZGC同时宣布转正</a></li>
</ul>]]></content>
      <categories>
        <category>新特性</category>
      </categories>
      <tags>
        <tag>IntelliJ IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>1. 揭秘Spring类型转换 - 框架设计的基石</title>
    <url>/x2y/5cc800bc.html</url>
    <content><![CDATA[<blockquote>
<p>仰不愧天，俯不愧人，内不愧心。关注公众号【<strong>BAT的乌托邦</strong>】，有Spring技术栈、MyBatis、JVM、中间件等小而美的<strong>原创专栏</strong>供以免费学习。分享、成长，拒绝浅尝辄止。本文已被 <a href="https://www.yourbatman.cn"><strong>https://www.yourbatman.cn</strong></a> 收录。</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20201129162517566.png" alt=""></p>
<h1 id="✍前言"><a href="#✍前言" class="headerlink" title="✍前言"></a>✍前言</h1><p>你好，我是YourBatman。</p>
<p><code>Spring Framework</code>是一个现代化的框架，俨然已发展成为Java开发的基石。随着高度封装、高度智能化的Spring Boot的普及，发现团队内越来越少的人知道其深层次机制，哪怕只有一点点。这是让Spirng团队开心，但却是让使用的团队比较担忧的现象。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201129133001611.png#pic_center" alt=""><br>若运行一个完全黑箱程序无疑像抱着一个定时炸弹，总是如履薄冰、战战兢兢。团队内需要这样的同学来为它保驾护航，惊爆之时方可泰然自诺。所以，你愿意pick吗？</p>
<p>本系列将讨论<code>Spring Framework</code>里贯穿其上下文，具有举足轻重地位的一个模块：<strong>类型转换</strong>（也可叫数据转换）。</p>
<h1 id="✍正文"><a href="#✍正文" class="headerlink" title="✍正文"></a>✍正文</h1><p>Java是个多类型且强类型语言，类型转换这个概念对它来说并不陌生。比如：</p>
<ul>
<li>自动类型转换（隐式）：小类型 -&gt; 大类型。eg：<code>int a = 10;    double b = a;</code></li>
<li>强制类型转换（显式）：大类型 -&gt; 小类型。eg：<code>double a = 10.123;    int b = (int)a;</code><ul>
<li>说明：强转有可能产生精度丢失</li>
</ul>
</li>
<li>调用API类型转换：常见的是字符串和其它类型的互转。eg：<code>parseInt(String); parseBoolean(String); JSON.toJSONString(Obj); LocalDate.parse(String)</code><ul>
<li>说明：API可能来自于JDK提供、一方库、二方库、三方库提供</li>
</ul>
</li>
</ul>
<p><img data-src="https://img-blog.csdnimg.cn/20201129084119479.png#pic_center" alt=""></p>
<p>在企业级开发环境中，会遇到更为复杂的数据转换场景，譬如说：</p>
<ol>
<li>输入/传入一个规格字符串（如<code>1,2,3,4</code>），转换为一个数组</li>
<li>输入/传入一个JSON串（如<code>{&quot;name&quot;:&quot;YourBatman&quot;,&quot;age&quot;:18}</code>），转换为一个Person对象</li>
<li>输入/传入一个URL串（如：<code>C:/myfile.txt、classpath:myfile.txt</code>），转换为一个<code>org.springframework.core.io.Resource</code>对象</li>
</ol>
<p>虽说数据输入/传入绝大部分都会是字符串（如Http请求信息、XML配置信息），但结构可以千差万别，那么这就必然会涉及到大量的数据类型、结构转换的逻辑。倘若这都需要程序员自己手动编码做转换处理，那会让人望而生畏甚至怯步。</p>
<p><strong>还好我们有Spring</strong>。从本文起，A哥就帮你解密Spring Framework它是如何帮你接管类型转换，实现“自动化”的。有了此部分知识的储备，后续再讨论自动化数据绑定、自动化数据校验、Spring Boot松散绑定等，一切都变得容易接受得多。</p>
<blockquote>
<p>说明：类型转换其实每个框架都会存在，其中Java领域以Spring的实现最为经典，学会后便可举一反三</p>
</blockquote>
<h2 id="Spring类型转换"><a href="#Spring类型转换" class="headerlink" title="Spring类型转换"></a>Spring类型转换</h2><p><strong>Spring的类型转换也并非一步到位</strong>。完全掌握Spring的类型转换并非易事，需要有一定的脉络按步骤进行。本文作为类型转换系列第一篇文章，将绘制目录大纲，将从以下几个方面逐步展开讨论。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201129164614705.png#pic_center" alt=""></p>
<h3 id="早期类型转换之PropertyEditor"><a href="#早期类型转换之PropertyEditor" class="headerlink" title="早期类型转换之PropertyEditor"></a>早期类型转换之PropertyEditor</h3><p>早期的Spirng（3.0之前）类型转换是基于Java Beans接口<code>java.beans.PropertyEditor</code>来实现的（全部继承自<code>PropertyEditorSupport</code>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PropertyEditor</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// String -&gt; Object</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setAsText</span><span class="params">(String text)</span> <span class="keyword">throws</span> java.lang.IllegalArgumentException</span>;</span><br><span class="line">	<span class="comment">// Object -&gt; String</span></span><br><span class="line">	<span class="function">String <span class="title">getAsText</span><span class="params">()</span></span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这类实现举例有：</p>
<ul>
<li><code>StringArrayPropertyEditor</code>：<code>,</code>分隔的字符串和<code>String[]</code>类型互转</li>
<li><code>PropertiesEditor</code>：键值对字符串和<code>Properties</code>类型互转</li>
<li><code>IntegerEditor</code>：字符串和<code>Integer</code>类型互转</li>
<li>…</li>
</ul>
<p>基于<code>PropertyEditor</code>的类型转换作为一种古老的、遗留下来的方式，是具有一些设计缺陷的，如：职责不单一，类型不安全，只能实现<code>String</code>类型的转换等。虽然自Spring 3.0起提供了现代化的类型转换接口，但是此部分机制一直得以<strong>保留</strong>，保证了向下兼容性。</p>
<blockquote>
<p>说明：Spring 3.0之前在Java领域还未完全站稳脚跟，因此良好的向下兼容显得尤为重要</p>
</blockquote>
<p>这块内容将在本系列后面具体篇章中得到专题详解，敬请关注。</p>
<h3 id="新一代类型转换接口Converter、GenericConverter"><a href="#新一代类型转换接口Converter、GenericConverter" class="headerlink" title="新一代类型转换接口Converter、GenericConverter"></a>新一代类型转换接口Converter、GenericConverter</h3><p>为了解决<code>PropertyEditor</code>作为类型转换方式的设计缺陷，Spring 3.0版本重新设计了一套类型转换接口，其中主要包括：</p>
<ul>
<li><code>Converter&lt;S, T&gt;</code>：Source -&gt; Target类型转换接口，适用于1:1转换<ul>
<li>StringToPropertiesConverter：将String类型转换为Properties</li>
<li>StringToBooleanConverter：将String类型转换为Boolean</li>
<li>EnumToIntegerConverter：将Enum类型转换为Integer</li>
</ul>
</li>
<li><code>ConverterFactory&lt;S, R&gt;</code>：Source -&gt; R类型转换接口，适用于1:N转换<ul>
<li>StringToEnumConverterFactory：将String类型转任意Enum</li>
<li>StringToNumberConverterFactory：将String类型转为任意数字（可以是int、long、double等等）</li>
<li>NumberToNumberConverterFactory：数字类型转为数字类型（如int到long，long到double等等）</li>
</ul>
</li>
<li><code>GenericConverter</code>：更为通用的类型转换接口，适用于N:N转换<ul>
<li>ObjectToCollectionConverter：任意集合类型转为任意集合类型（如<code>List&lt;String&gt;</code>转为<code>List&lt;Integer&gt; / Set&lt;Integer&gt;</code>都使用此转换器）</li>
<li>CollectionToArrayConverter：解释基本同上</li>
<li>MapToMapConverter：解释基本同上</li>
</ul>
</li>
<li><code>ConditionalConverter</code>：条件转换接口。可跟上面3个接口组合使用，提供<strong>前置条件</strong>判断验证</li>
</ul>
<p>重新设计的这套接口，解决了<code>PropertyEditor</code>做类型转换存在的所有缺陷，且具有非常高的灵活性和可扩展性。但是，每个接口独立来看均具有一定的局限性，只有使用<strong>组合拳</strong>方才有最大威力。当然喽，这也造成学习曲线变得陡峭。据我了解，很少有同学搞得清楚新的这套类型转换机制，特别容易混淆。倘若你掌握了是不是自己价值又提升了呢？不信你细品？</p>
<p>这块内容将在本系列后面具体篇章中得到专题详解，敬请关注。</p>
<h3 id="新一代转换服务接口：ConversionService"><a href="#新一代转换服务接口：ConversionService" class="headerlink" title="新一代转换服务接口：ConversionService"></a>新一代转换服务接口：ConversionService</h3><p>从上一小节我们知道，新的这套接口中，<code>Converter、ConverterFactory、GenericConverter</code>它们三都着力于完成类型转换。对于使用者而言，如果做个类型转换需要了解到这三套体系无疑成本太高，因此就有了<code>ConversionService</code>用于整合它们三，统一化接口操作。</p>
<p>此接口也是Spring 3.0新增，用于<strong>统一化</strong> 底层类型转换实现的差异，对外提供统一服务，所以它也被称作类型转换的<strong>门面接口</strong>，从接口名称<code>xxxService</code>也能看出来其设计思路。它主要有两大实现：</p>
<ol>
<li><code>GenericConversionService</code>：提供模版实现，如转换器的注册、删除、匹配查找等，但并不内置转换器实现</li>
<li><code>DefaultConversionService</code>：继承自GenericConversionService。在它基础上默认注册了非常多的内建的转换器实现，从而能够实现<strong>绝大部分</strong>的类型转换需求</li>
</ol>
<p><code>ConversionService</code>转换服务它贯穿于Spring上下文<code>ApplicationContext</code>的多项功能，包括但不限于：BeanWrapper处理Bean属性、DataBinder数据绑定、PropertySource外部化属性处理等等。因此想要进一步深入了解的话，ConversionService是你绕不过去的坎。</p>
<blockquote>
<p>说明：很多小伙伴问WebConversionService是什么场景下使用？我说：它并非Spirng Framework的API，而属于Spring Boot提供的增强，且起始于2.x版本，这点需引起注意</p>
</blockquote>
<p>这块内容将在本系列后面具体篇章中得到专题详解，敬请关注。</p>
<h3 id="类型转换整合格式化器Formatter"><a href="#类型转换整合格式化器Formatter" class="headerlink" title="类型转换整合格式化器Formatter"></a>类型转换整合格式化器Formatter</h3><p>Spring 3.0还新增了一个<code>Formatter&lt;T&gt;</code>接口，作用为：将Object格式化为类型T。从语义上理解它也具有类型转换（数据转换的作用），相较于<code>Converter&lt;S,T&gt;</code>它强调的是<strong>格式化</strong>，因此一般用于时间/日期、数字（小数、分数、科学计数法等等）、货币等场景，举例它的实现：</p>
<ul>
<li><code>DurationFormatter</code>：字符串和<code>Duration</code>类型的互转</li>
<li><code>CurrencyUnitFormatter</code>：字符串和<code>javax.money.CurrencyUnit</code>货币类型互转</li>
<li><code>DateFormatter</code>：字符串和<code>java.util.Date</code>类型互转。这个就使用得太多了，它默认支持什么格式？支持哪些输出方式，这将在后文详细描述</li>
<li>……</li>
</ul>
<p>为了和类型转换服务<code>ConversionService</code>完成整合，对外只提供统一的API。Spring提供了<code>FormattingConversionService</code>专门用于整合Converter和Formatter，从而使得两者具有一致的编程体验，对开发者更加友好。</p>
<p>这块内容将在本系列后面具体篇章中得到专题详解，敬请关注。</p>
<h3 id="类型转换底层接口TypeConvert"><a href="#类型转换底层接口TypeConvert" class="headerlink" title="类型转换底层接口TypeConvert"></a>类型转换底层接口TypeConvert</h3><p>定义类型转换方法的接口，它在Spring 2.0就已经存在。在还没有<code>ConversionService</code>之前，它的类型转换动作均委托给已注册的<code>PropertyEditor</code>来完成。但自3.0之后，这个转换动作可能被PropertyEditor来做，也可能交给<code>ConversionService</code>处理。</p>
<p>它一共提供三个重载方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @since 2.0</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// value：待转换的source源数据</span></span><br><span class="line"> 	<span class="comment">// requiredType：目标类型targetType</span></span><br><span class="line"> 	<span class="comment">// methodParam：转换的目标方法参数，主要为了分析泛型类型，可能为null</span></span><br><span class="line"> 	<span class="comment">// field：目标的反射字段，为了泛型，可能为null</span></span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">convertIfNecessary</span><span class="params">(Object value, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> TypeMismatchException</span>;</span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">convertIfNecessary</span><span class="params">(Object value, Class&lt;T&gt; requiredType, MethodParameter methodParam)</span> <span class="keyword">throws</span> TypeMismatchException</span>;</span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">convertIfNecessary</span><span class="params">(Object value, Class&lt;T&gt; requiredType, Field field)</span> <span class="keyword">throws</span> TypeMismatchException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它是Spring内部使用类型转换的<strong>入口</strong>，最终委托给<code>PropertyEditor</code>或者注册到<code>ConversionService</code>里的转换器去完成。它的主要实现有：</p>
<ul>
<li><code>TypeConverterSupport</code>：@since 3.2。继承自<code>PropertyEditorRegistrySupport</code>，它主要是为子类<code>BeanWrapperImpl</code>提供功能支撑。作用有如下两方面：<ol>
<li>提供对<strong>默认编辑器</strong>（支持JDK内置类型的转换如：Charset、Class、Class[]、Properties、Collection等等）和<strong>自定义编辑器</strong>的管理（PropertyEditorRegistry#registerCustomEditor）</li>
<li>提供get/set方法，把<code>ConversionService</code>管理上（可选依赖，可为null）</li>
</ol>
</li>
<li>数据绑定相关：因为数据绑定<strong>强依赖于</strong>类型转换，因此数据绑定涉及到的属性访问操作将会依赖于此组件，不管是直接访问属性的<code>DirectFieldAccessor</code>还是功能更强大的<code>BeanWrapperImpl</code>均是如此</li>
</ul>
<p>总的来说，<code>TypeConverter</code>能把类型的各种实现、API收口于此，Spring把类型转换的能力都转嫁到TypeConverter这个API里面去了。虽然方便了使用，但其内部实现原理稍显复杂，同样的这块内容将在本系列后面具体篇章中得到专题详解，敬请关注。</p>
<h3 id="Spring-Boot使用增强"><a href="#Spring-Boot使用增强" class="headerlink" title="Spring Boot使用增强"></a>Spring Boot使用增强</h3><p>在传统Spring Framework场景下，若想使用<code>ConversionService</code>还得手动档去配置，这对于不太了解其运行机制的同学无疑是有使用门槛的。而在Spring Boot场景下这一切都会变得简单许多，可谓使用起来愈发方便了。</p>
<p>另外，Spring Boot在内建转换器的基础上额外扩展了不少实用转换器，形如：</p>
<ul>
<li><code>StringToFileConverter</code>：String -&gt; File</li>
<li><code>NumberToDurationConverter</code>：</li>
<li><code>DelimitedStringToCollectionConverter</code>：</li>
<li>……</li>
</ul>
<h1 id="✍总结"><a href="#✍总结" class="headerlink" title="✍总结"></a>✍总结</h1><p><strong>基于配置</strong>来控制程序运行总比你修改程序代码来得更优雅、更富弹性，但这是需要依赖于数据绑定、数据校验等功能的，而它们又依赖于类型转换。</p>
<p>虽说几乎所有的框架都会有类型转换的功能模块，但Spring的可能是最为通用、最为经典的存在。因此本系列专题讲解Spring Framework的类型转换，旨在能够帮你你撬开通往跃升的大门，节节攀高。</p>
<hr>
<h5 id="✔推荐阅读："><a href="#✔推荐阅读：" class="headerlink" title="✔推荐阅读："></a>✔推荐阅读：</h5><ul>
<li><a href="https://mp.weixin.qq.com/s/KywpJkLDHZbZTxUf4WFxhw" target="_blank" rel="noopener">Spring Boot 2.4.0正式发布，全新的配置文件加载机制（不向下兼容）</a></li>
<li><a href="https://mp.weixin.qq.com/s/SZUJ0sy4vM7UH10pk6NM3g" target="_blank" rel="noopener">如果程序员和产品经理都用凡尔赛文学对话……</a></li>
<li><a href="https://mp.weixin.qq.com/s/Sw6EqAY0DmF-p2qPoaetUg" target="_blank" rel="noopener">Spring Framework 5.3.0正式发布，在云原生路上继续发力</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZoUG9h1TndW2QpnPyGeIQA" target="_blank" rel="noopener">Spring改变版本号命名规则：此举对非英语国家很友好</a></li>
<li><a href="https://mp.weixin.qq.com/s/3QaiUGzj5nW2N4Aipm47PQ" target="_blank" rel="noopener">JDK15正式发布，划时代的ZGC同时宣布转正</a></li>
<li><a href="https://mp.weixin.qq.com/s/8voJSbmcBbdfNUCUBIcKcA" target="_blank" rel="noopener">IntelliJ IDEA 2020.2正式发布，诸多亮点总有几款能助你提效</a></li>
<li><a href="https://mp.weixin.qq.com/s/ikI9c3XyR_czOSmsu6FLMw" target="_blank" rel="noopener">Spring Boot 2.3.0正式发布：优雅停机、配置文件位置通配符新特性一览</a></li>
<li><a href="https://mp.weixin.qq.com/s/nb4oT02dlU4pxINZw9aLLw" target="_blank" rel="noopener">搞事情？Spring Boot今天一口气发布三个版本</a></li>
</ul>]]></content>
      <categories>
        <category>A哥学类型转换</category>
      </categories>
      <tags>
        <tag>Spring Framework</tag>
        <tag>类型转换</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 2.4.0正式发布，全新的配置文件加载机制（不向下兼容）</title>
    <url>/x2y/943b0f62.html</url>
    <content><![CDATA[<blockquote>
<p>千里之行，始于足下。关注公众号【<strong>BAT的乌托邦</strong>】，有Spring技术栈、MyBatis、JVM、中间件等小而美的<strong>原创专栏</strong>供以免费学习。分享、成长，拒绝浅尝辄止。本文已被 <a href="https://www.yourbatman.cn"><strong>https://www.yourbatman.cn</strong></a> 收录。</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20201122153939319.jpg" alt=""></p>
<h1 id="✍前言"><a href="#✍前言" class="headerlink" title="✍前言"></a>✍前言</h1><p>你好，我是YourBatman。</p>
<p>北京时间2020-11-12，<code>Spring Boot 2.4.0</code>正式发布。2.4.0是第一个使用<strong>新版本方案</strong>的Spring Boot发行版本。</p>
<blockquote>
<p>注意：2.4.0版本号没有<code>.RELEASE</code>后缀，没有<code>.RELEASE</code>后缀，没有<code>.RELEASE</code>后缀。使用的是Spring最新的版本发布规则。此规则详解请参考上篇文章：<a href="https://mp.weixin.qq.com/s/ZoUG9h1TndW2QpnPyGeIQA" target="_blank" rel="noopener">Spring改变版本号命名规则：此举对非英语国家很友好</a></p>
</blockquote>
<p>还记得<code>Spring Boot 2.3.0.RELEASE</code>版本发布时那会麽？前后相差将好半年：<br><img data-src="https://img-blog.csdnimg.cn/20201114170514555.png?#pic_center" alt=""><br>直达电梯：<a href="https://mp.weixin.qq.com/s/ikI9c3XyR_czOSmsu6FLMw" target="_blank" rel="noopener">Spring Boot 2.3.0正式发布：优雅停机、配置文件位置通配符新特性一览</a></p>
<p>一般来说，次版本号的升级会有点料，根据之前的爆料此次升级据说是做了大量的更新和改进。那么老规矩，作为小白鼠的我先代你玩一玩，初体验吧。</p>
<blockquote>
<p>也可参见官方的更新日志：<a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.4-Release-Notes" target="_blank" rel="noopener">Spring Boot 2.4.0 Release Notes</a></p>
</blockquote>
<h1 id="✍正文"><a href="#✍正文" class="headerlink" title="✍正文"></a>✍正文</h1><p>除了刚发布的Spring Boot 2.4.0，Spring Boot 2.3.x/2.2.x仍旧是<strong>活跃的</strong>维护的版本。Spring Boot遵循的是<code>Pivotal OSS</code>支持策略，从发布日期起支持主要版本<strong>3年</strong>（注意：是主要版本）。下面是详情：</p>
<ul>
<li><code>2.3.x</code>：<strong>支持的版本</strong>。2020.05发布，是现在的活跃的主干</li>
<li><code>2.2.x</code>：<strong>支持的版本</strong>。2019.10发布，是现在的活跃的主干</li>
<li><code>2.1.x</code>：2018.10发布，支持到2020.10月底，<strong>建议尽快升级</strong></li>
</ul>
<p><strong>EOL分支</strong>：</p>
<ul>
<li><code>2.0.x</code>：2018.3发布，2019.4.3停止维护</li>
<li><code>1.5.x</code>：生命已终止的版本。2017.1发布，是最后一个1.x分支，2019.8.1停止维护</li>
</ul>
<p><img data-src="https://img-blog.csdnimg.cn/20201116071254550.png#pic_center" alt=""></p>
<h2 id="回忆2-3版本的新特性"><a href="#回忆2-3版本的新特性" class="headerlink" title="回忆2.3版本的新特性"></a>回忆2.3版本的新特性</h2><p>可能大部分小伙伴都还没用过2.3.x分支，没想到2.4.x就已发布。因此这里先对2.3.x版本的新特性，来波简单回忆：</p>
<ol>
<li>优雅停机。这是<strong>2.3.x主打的新特性</strong>：在关闭时，web服务器将不再允许新的请求，并将等待完成的请求给个宽限期让它完成。这个宽限期是可以设置的：可以使用<code>spring.lifecycle.timeout-per-shutdown-phase=xxx</code>来配置，默认值是30s。</li>
<li>配置文件位置支持通配符。简单的说，如果你有MySql的配置和Redis配置的话，你就可以把他们分开来放置，这个新特性也是棒棒哒。隔离性更好目录也更加清晰了（注意：此格式只支持放在classpath外部）：<ol>
<li>mysql：<code>/config/mysql/application.properties</code></li>
<li>redis：<code>/config/redis/application.properties</code></li>
</ol>
</li>
<li>核心依赖升级。<ol>
<li>Spring Data Neumann。备注：很明显这个还是旧的命名方式。在Spirng新的版本规则下，Spring Data最新版本为Spring Data 2020.0.0</li>
<li>Spring Session Dragonfruit（很明显这个也还是旧的命名方式）</li>
<li>Spring Security 5.3</li>
<li><strong>Spring Framework</strong> 没有升级，使用的依旧是和Spring Boot 2.2相同的<code>5.2.x</code>版本<ol>
<li>说明：小版本号的升级对于新特性来说一般选择性忽略</li>
</ol>
</li>
<li>关于<strong>Bean Validation</strong>：从此版本开始，<code>spring-boot-starter-web</code>不会再把validation带进来，所以若使用到，你需要自己添加这个<code>spring-boot-starter-validation</code>依赖<ol>
<li>一般来说建议你手动引入，毕竟Bean Validation的使用还是很广泛，并且真的非常非常好用</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>做足功课后，就开始最新的Spring Boot 2.4.0之旅吧。</p>
<h2 id="2-4-0主要新特性"><a href="#2-4-0主要新特性" class="headerlink" title="2.4.0主要新特性"></a>2.4.0主要新特性</h2><h3 id="全新的配置文件处理-properties-yaml"><a href="#全新的配置文件处理-properties-yaml" class="headerlink" title="全新的配置文件处理(properties/yaml)"></a>全新的配置文件处理(properties/yaml)</h3><p>这个改变<strong>最为重磅</strong>，本次改变了配置文件的加载逻辑，旨在<strong>简化</strong>和<strong>合理化</strong>外部配置的加载方式，它可能具有不向下兼容性。</p>
<p>Spring Boot 2.4改变了处理<code>application.properties</code>和<code>application.yml</code>文件的方式：</p>
<ul>
<li>若你只是简单的文件application.properties/yaml，那么升级对你是<strong>无缝</strong>的，你感受不到任何变化</li>
<li>若你使用了比较复杂的文件，如<code>application-profile.properties/yaml</code>这种（或者使用了Spirng Cloud的配置中心、（带有分隔符—-的）多yaml文件），那么默认是不向下兼容的，需要你显式的做出些更改</li>
</ul>
<p>因为配置文件隶属于程序的一部分，特别是我们现在几乎都会使用到配置中心。因此下面针对于老版本升级到Spring Boot 2.4.0做个简单的迁移指导。</p>
<blockquote>
<p>说明：因配置文件加载逻辑完全进行了重写，因此详细版本我放到了下文专文讲解，有兴趣可保持关注</p>
</blockquote>
<h4 id="老版本版本配置属性迁移指南"><a href="#老版本版本配置属性迁移指南" class="headerlink" title="老版本版本配置属性迁移指南"></a>老版本版本配置属性迁移指南</h4><p>老版本：2.4.0之前的版本都叫老版本。</p>
<p>Spring Boot 2.4对<code>application.poperties/yaml</code>的处理做了更新/升级。旨在简化和合理化外部配置的加载方式。它还提供了新功能：<code>spring.config.import</code>支持。所以呢，对于Spring Boot 2.4.0之前的版本（老版本）若升级到2.4.0需要做些修改，指导建议如下：</p>
<h5 id="方式一：恢复旧模式（不推荐）"><a href="#方式一：恢复旧模式（不推荐）" class="headerlink" title="方式一：恢复旧模式（不推荐）"></a>方式一：恢复旧模式（不推荐）</h5><p>如果你还未准备好做配置迁移的修改，Spring Boot也帮你考虑到了，提供了<strong>一键切换</strong>到旧模式的“按钮”。具体做法是：只需要在<code>Environment</code>里增加一个属性<code>spring.config.use-legacy-processing = true</code>就搞定。最简的方式就是把这个属性放在application.poperties/yaml里即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.config.use-legacy-processing = <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>增加此配置后，Spring Boot对配置文件的解析恢复到原来模式：仍旧使用<code>ConfigFileApplicationListener</code>去解析。</p>
<blockquote>
<p><code>ConfigFileApplicationListener</code>属于Spring Boot非常核心的底层代码，这次做了不向下兼容的改进，可见它对进击云原生的决心</p>
</blockquote>
<p>值得注意的是：此API在2.4.0已被标记为过期：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @since 1.0.0</span></span><br><span class="line"><span class="comment">// @deprecated since 2.4.0 in favor of &#123;@link ConfigDataEnvironmentPostProcessor&#125;</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigFileApplicationListener</span> <span class="keyword">implements</span> <span class="title">EnvironmentPostProcessor</span>, <span class="title">SmartApplicationListener</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照Spring Boot的版本策略，此类将在Spring Boot 2.6.0版本被移除。因此：若不是迫不得已（时间紧急），并不建议你用兼容手法这么去做，因为这将成为技术债，迟早要还的。</p>
<blockquote>
<p>说明：很多RD其实只会看到当前的方便，获得利益（比如快速上线获奖），坑交给后人。我个人认为作为程序员应该有一定自我修养，自我追求，不为一时的爽而持续给团队积累债务，毕竟积重难返。</p>
</blockquote>
<h5 id="方式二：按新规则迁移（推荐）"><a href="#方式二：按新规则迁移（推荐）" class="headerlink" title="方式二：按新规则迁移（推荐）"></a>方式二：按新规则迁移（推荐）</h5><p>若你对配置文件的使用有如下情行，那么你需要做迁移：</p>
<ol>
<li>多文档的yaml文件（带有—-分隔符的文件）</li>
<li>在Jar外使用配置文件，或者使用形如application-{xxx}.properties/yaml这种配置</li>
<li>若在多文档yaml中使用到了<code>spring.profiles</code>配置项</li>
<li>…</li>
</ol>
<p>Spring Boot 2.4.0升级对配置文件的改动是最大的，并且还<strong>不具备向下兼容性</strong>，简单的说就是从此版本开始要把Spring Boot的配置文件加载机制重学一遍（比如还增加了<code>spring.config.import</code>，增加了对kubernetes配置的支持等等），并且还要学会如何迁移。</p>
<p><strong>为了更好的描述好这个非常非常重要的知识点，下篇文章我会用专文来全面介绍 Spring Boot这套全新的配置文件加载机制，并且辅以原理，以及和过去方式的比较，帮助你更全面、更快速、更劳的掌握它，欢迎持续关注。</strong></p>
<blockquote>
<p>说明：Spring Boot的配置文件加载机制非常非常重要，因为你也知道你平时开发中很大程度实际上是在跟它的配置项打交道。新的配置加载方式比老的更加优秀，适应发展，敬请期待</p>
</blockquote>
<h3 id="从spring-boot-starter-test中删除Vintage-Engine"><a href="#从spring-boot-starter-test中删除Vintage-Engine" class="headerlink" title="从spring-boot-starter-test中删除Vintage Engine"></a>从spring-boot-starter-test中删除Vintage Engine</h3><p><code>Spring Boot 2.2.0</code>版本开始就引入JUnit 5作为单元测试<strong>默认库</strong>，在此之前，spring-boot-starter-test包含的是JUnit 4的依赖，Spring Boot 2.2.0版本之后替换成了Junit Jupiter（Junit5）。</p>
<p>Vintage Engine属于Junit5的一个模块，它的作用是：允许用JUnit 5运行用JUnit 4编写的测试，从而提供了向下兼容的能力。</p>
<p>从2.2.0到现在经过了2个版本的迭代，到<code>Spring Boot 2.4.0</code>这个版本决定了把Vintage Engine从spring-boot-starter-test正式移除。因此：若你的工程仍需要对JUnit4支持，那么请手动引入依赖项（如果工程量不大，强烈建议使用JUnit5，比4好用太多）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hamcrest<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hamcrest-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：其实在2.4.0之前，若你是从<code>https://start.spring.io</code>生成的项目其实也是不会带有vintage-engine的。只不过它是通过显式的在pom里通过exclusion标签来排除的</p>
</blockquote>
<h3 id="嵌入式数据库检测"><a href="#嵌入式数据库检测" class="headerlink" title="嵌入式数据库检测"></a>嵌入式数据库检测</h3><p>改进嵌入式数据库检测机制：仅当数据库在<strong>内存中</strong>时才将其视为嵌入式数据库。所以如果使用H2、HSQL等产品，<strong>但是</strong>你是基于文件的持久性或使用的是服务器模式，那么将不会检测为内存数据库。而对于<strong>非内存</strong>数据库，你可能需要额外做如下动作：</p>
<ol>
<li>sa用户名将不会再被主动设置。所以如果你的数据库需要用户名，请增加配置项：<code>spring.datasource.username = sa</code></li>
<li>这种数据库将不会再被自动初始化，若要使用请根据需要更改<code>spring.datasource.initialization-mode</code>的值</li>
</ol>
<h3 id="Logback配置属性"><a href="#Logback配置属性" class="headerlink" title="Logback配置属性"></a>Logback配置属性</h3><p>Logback一些配置项改名了，更加表名了它是logback的配置项。</p>
<blockquote>
<p>新增了配置类<code>LogbackLoggingSystemProperties</code>用于对应，它继承自之前的<code>LoggingSystemProperties</code></p>
</blockquote>
<p>之前的配置项有些被废弃（此版本还未删除，后续版本肯定会删除的），对应关系如下：</p>
<table>
<thead>
<tr>
<th><del>老(已废弃)</del></th>
<th>新</th>
</tr>
</thead>
<tbody><tr>
<td><del>logging.pattern.rolling-file-name</del></td>
<td>logging.logback.rollingpolicy.file-name-pattern</td>
</tr>
<tr>
<td><del>logging.file.clean-history-on-start</del></td>
<td>logging.logback.rollingpolicy.clean-history-on-start</td>
</tr>
<tr>
<td><del>logging.file.max-size</del></td>
<td>logging.logback.rollingpolicy.max-file-size</td>
</tr>
<tr>
<td><del>logging.file.total-size-cap</del></td>
<td>logging.logback.rollingpolicy.total-size-cap</td>
</tr>
<tr>
<td><del>logging.file.max-history</del></td>
<td>logging.logback.rollingpolicy.max-history</td>
</tr>
</tbody></table>
<p>一些属性是被放到system environment里面的：</p>
<table>
<thead>
<tr>
<th><del>老(已废弃)</del></th>
<th>新</th>
</tr>
</thead>
<tbody><tr>
<td><del>ROLLING_FILE_NAME_PATTERN ~</del></td>
<td>LOGBACK_ROLLINGPOLICY_FILE_NAME_PATTERN</td>
</tr>
<tr>
<td><del>LOG_FILE_CLEAN_HISTORY_ON_START</del></td>
<td>LOGBACK_ROLLINGPOLICY_CLEAN_HISTORY_ON_START</td>
</tr>
<tr>
<td><del>LOG_FILE_MAX_SIZE</del></td>
<td>LOGBACK_ROLLINGPOLICY_MAX_FILE_SIZE</td>
</tr>
<tr>
<td><del>LOG_FILE_TOTAL_SIZE_CAP</del></td>
<td>LOGBACK_ROLLINGPOLICY_TOTAL_SIZE_CAP</td>
</tr>
<tr>
<td><del>LOG_FILE_MAX_HISTORY</del></td>
<td>LOGBACK_ROLLINGPOLICY_MAX_HISTORY</td>
</tr>
</tbody></table>
<h3 id="不再注册DefaultServlet"><a href="#不再注册DefaultServlet" class="headerlink" title="不再注册DefaultServlet"></a>不再注册DefaultServlet</h3><p>从Spring Boot 2.4开始，默认将不会再注册<code>DefaultServlet</code>。因为在绝大多数的应用中，Spring MVC提供的<code>DispatcherServlet</code>是<strong>唯一</strong>需要被注册的Servlet。从源码处感受下这次改动：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractServletWebServerFactory：</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.4.0之前版本，默认值是true</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> registerDefaultServlet = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 2.4.0以及之后版本，默认值是false</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> registerDefaultServlet = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<p>当然喽，若你的工程强依赖于此Servelt，那么可以通过此配置项<code>server.servlet.register-default-servlet = true</code>把它注册上去。</p>
<h4 id="补课：什么是DefaultServlet？"><a href="#补课：什么是DefaultServlet？" class="headerlink" title="补课：什么是DefaultServlet？"></a>补课：什么是DefaultServlet？</h4><p>它是Java EE提供的标准技术，如Tomcat、Jetty等都提供了这个类。简而言之它的作用就是兜底（拦截<code>/</code>），当别的servlet都没匹配上时就交给它来处理，一般用于处理静态资源如<code>.jpg,.html,.js</code>这类的静态文件。</p>
<p><code>DefaultServlet</code>在传统web容器里，会被配置在tomcat目录（此处以tomcat为例）下的<code>conf/web.xml</code>里：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.catalina.servlets.DefaultServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>debug<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>0<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>listings<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：tomcat下的web.xml对其加载的所有的Application都生效，并且最终和Application自己的web.xml内容合并，遇相同的话后者优先级更高</p>
</blockquote>
<p>在Spring Boot <strong>嵌入式容器</strong>里配置是这样的（完全等价于xml配置）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addDefaultServlet</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">	Wrapper defaultServlet = context.createWrapper();</span><br><span class="line">	defaultServlet.setName(<span class="string">"default"</span>);</span><br><span class="line">	defaultServlet.setServletClass(<span class="string">"org.apache.catalina.servlets.DefaultServlet"</span>);</span><br><span class="line">	defaultServlet.addInitParameter(<span class="string">"debug"</span>, <span class="string">"0"</span>);</span><br><span class="line">	defaultServlet.addInitParameter(<span class="string">"listings"</span>, <span class="string">"false"</span>);</span><br><span class="line">	defaultServlet.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">	<span class="comment">// Otherwise the default location of a Spring DispatcherServlet cannot be set</span></span><br><span class="line">	defaultServlet.setOverridable(<span class="keyword">true</span>);</span><br><span class="line">	context.addChild(defaultServlet);</span><br><span class="line">	context.addServletMappingDecoded(<span class="string">"/"</span>, <span class="string">"default"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是：Spring Boot注册的<code>DispatcherServlet</code>的path也是<code>/</code>（覆盖掉了<code>DefaultServelt</code>）。在Spring MVC环境下倘若是静态资源，也不用DefaultServelt费心，Spring MVC专门提供了一个<code>DefaultServletHttpRequestHandler</code>用于处理静态资源（虽然最终还是Dispatcher给<code>defaultServlet</code>去搞定）。</p>
<p>现在的Spring Boot服务大都是REST服务，并无静态资源需要提供，因此就没有必要启用<code>DefaultServletHttpRequestHandler</code>和注册<code>DefaultServlet</code>来增加不必要的开销喽。</p>
<h3 id="HTTP-traces不再包含cookie头"><a href="#HTTP-traces不再包含cookie头" class="headerlink" title="HTTP traces不再包含cookie头"></a>HTTP traces不再包含cookie头</h3><p>Http traces默认将不再包含请求头<code>Cookie</code>以及响应头<code>Set-Cookie</code>。源码处感受一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.actuate.trace.http.Include：</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.4.0版本之前：包含COOKIE_HEADERS这个头</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">	Set&lt;Include&gt; defaultIncludes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">	defaultIncludes.add(Include.REQUEST_HEADERS);</span><br><span class="line">	defaultIncludes.add(Include.RESPONSE_HEADERS);</span><br><span class="line">	defaultIncludes.add(Include.COOKIE_HEADERS);</span><br><span class="line">	defaultIncludes.add(Include.TIME_TAKEN);</span><br><span class="line">	DEFAULT_INCLUDES = Collections.unmodifiableSet(defaultIncludes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.4.0版本以及之后：不包含COOKIE_HEADERS这个头</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">	Set&lt;Include&gt; defaultIncludes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">	defaultIncludes.add(Include.REQUEST_HEADERS);</span><br><span class="line">	defaultIncludes.add(Include.RESPONSE_HEADERS);</span><br><span class="line">	defaultIncludes.add(Include.TIME_TAKEN);</span><br><span class="line">	DEFAULT_INCLUDES = Collections.unmodifiableSet(defaultIncludes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>若你仍旧想保留老的习惯，那么请用配置项<code>management.trace.http.include = cookies, errors, request-headers, response-headers</code>自行控制。</p>
<h3 id="Neo4j"><a href="#Neo4j" class="headerlink" title="Neo4j"></a>Neo4j</h3><p>这个版本对Neo4j的支持进行了重大调整。直接用源码来说明差异：</p>
<p>Spring Boot 2.4.0之前版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.data.neo4j"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Neo4jProperties</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="comment">// 无Neo4jDataProperties配置类</span></span><br></pre></td></tr></table></figure>
<p>Spring Boot 2.4.0以及之后版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.neo4j"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Neo4jProperties</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.data.neo4j"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Neo4jDataProperties</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<h2 id="其它升级关注点"><a href="#其它升级关注点" class="headerlink" title="其它升级关注点"></a>其它升级关注点</h2><ul>
<li><strong>Spring Framework 5.3</strong>：Spring Boot 2.4.0使用的是5.3.0主线分支（之前使用的5.2.x或更低）<ul>
<li>Spring Framework 5.3的新特性应该<strong>重点关注</strong>，请移步我上篇文章：<a href="https://mp.weixin.qq.com/s/Sw6EqAY0DmF-p2qPoaetUg" target="_blank" rel="noopener">Spring Framework 5.3.0正式发布，在云原生路上继续发力</a></li>
</ul>
</li>
<li><strong>Spring Data 2020.0</strong>：Spring Boot 2.4.0使用的是最新发布的Spring Data 2020.0<ul>
<li>此版本的命名方式不同于之前，是因为使用了Spirng最新的release train命名方式。Spring在2020年4月份发布了最新的版本命名方式，可参考前面这篇文章：<a href="https://mp.weixin.qq.com/s/ZoUG9h1TndW2QpnPyGeIQA" target="_blank" rel="noopener">Spring改变版本号命名规则：此举对非英语国家很友好</a></li>
</ul>
</li>
<li><strong>支持Java 15</strong>：此版本的Spring Boot完全支持Java 15，最小支持依旧是Java 8</li>
<li>自定义属性名支持：当使用<strong>构造函数绑定</strong>时，属性的名称需要和参数名称保持一样。如果您想使用Java保留关键字，这可能是一个问题。如下例子：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"sample"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleConfigurationProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String importValue;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// import是Java关键字</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SampleConfigurationProperties</span><span class="params">(@Name(<span class="string">"import"</span>)</span> String importValue) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.importValue = importValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>@Name注解是Spring Boot 2.4.0新增的注解，能标注在<code>ElementType.PARAMETER</code>上</p>
</blockquote>
</li>
<li><strong>支持导入无扩展名的配置文件</strong>：如果您有这样的需求，现在就可以通过向Spring Boot引导提供关于内容类型的提示来导入这些文件<ul>
<li>此版本对Spring Boot的配置文件加载进行了完全重新改造，并且不向下兼容，具体参见<strong>下篇文章</strong></li>
</ul>
</li>
<li><strong>新增StartupEndpoint</strong>：显示有关应用程序启动的信息。此端点可以帮助您识别启动时间超过预期的bean<ul>
<li>此端点依赖于Spring Framework 5.3.0新提供的应用启动追踪新特性。具体可参考<code>ApplicationStartup</code>和<code>StartupStep</code>这个两个API是如何做追踪的</li>
</ul>
</li>
<li><strong>新增RedisCacheMetrics</strong>：用于监控使用redis时的puts、gets、deletes以及缓存命中率等信息<ul>
<li>此指标信息默认不开启，需你增加配置<code>spring.cache.redis.enable-statistics = true</code></li>
</ul>
</li>
<li><strong>新增些Web配置项</strong>：<code>spring.web.locale、spring.web.locale-resolver、spring.web.resources.*、management.server.base-path</code>，这些属性既支持Servlet也支持WebFlux<ul>
<li>对应的<strong>只能用于</strong> Spring MVC或servelt下配置项<code>spring.mvc.locale/spring.mvc.locale-resolver/spring.resources.*/management.server.servlet.context-path</code>均以标注为过期</li>
</ul>
</li>
<li><strong>支持Flyway 7</strong>：这个版本升级到Flyway 7，带来了一些额外的属性。如：<code>spring.flyway.url/user/password</code>（开源版本）；<code>spring.flyway.cherry-pick/jdbc-properties...</code>（团队版本）</li>
<li><strong>H2数据库控制台支持配置密码</strong>：可通过<code>spring.h2.console.settings.web-admin-password</code>属性配置通过密码访问H2控制台</li>
<li><strong>增强的错误分析器FailureAnalizers</strong>：现在即使你还没有创建ApplicationContext，FailureAnalizers都会生效来帮你定位错误位置</li>
<li><strong>处理/标注Spring Boot 2.2和2.3中过期项</strong>：按照Spring Boot的<strong>版本兼容性政策</strong>，在2.2版本已被标记为<code>@Deprecated</code>的在2.4.0版本会被删除，在2.3版本中被标记为<code>@Deprecated</code>的计划在2.5.0版本中将其移除</li>
</ul>
<h1 id="✍总结"><a href="#✍总结" class="headerlink" title="✍总结"></a>✍总结</h1><p>这是A哥奉给大家的，对Spring Boot2.4.0版本新特性的介绍，希望对你有些帮助。</p>
<p>Spring Boot 2.4.0版本的升级目标，基本和Spring Framework 5.3.0保持一致：<strong>为云原生做努力</strong>。表现在除了删除些无用类，禁止不需要的类的加载外，重点还会体现在它对<strong>配置文件加载机制</strong>的重构上，这将是下文的内容，也是本次升级的重头戏，敬请关注。</p>
<p>Spring Boot重写了对配置文件的加载机制，并且新引入了近40个类来处理（老方式仅有区区几个类），可见其重视、重要程度。因此，为了适应未来的发展，你一定要掌握，并且越早越好，下篇将为你揭晓。</p>
<hr>
<h5 id="✔推荐阅读："><a href="#✔推荐阅读：" class="headerlink" title="✔推荐阅读："></a>✔推荐阅读：</h5><ul>
<li><a href="https://mp.weixin.qq.com/s/SZUJ0sy4vM7UH10pk6NM3g" target="_blank" rel="noopener">如果程序员和产品经理都用凡尔赛文学对话……</a></li>
<li><a href="https://mp.weixin.qq.com/s/Sw6EqAY0DmF-p2qPoaetUg" target="_blank" rel="noopener">Spring Framework 5.3.0正式发布，在云原生路上继续发力</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZoUG9h1TndW2QpnPyGeIQA" target="_blank" rel="noopener">Spring改变版本号命名规则：此举对非英语国家很友好</a></li>
<li><a href="https://mp.weixin.qq.com/s/3QaiUGzj5nW2N4Aipm47PQ" target="_blank" rel="noopener">JDK15正式发布，划时代的ZGC同时宣布转正</a></li>
<li><a href="https://mp.weixin.qq.com/s/8voJSbmcBbdfNUCUBIcKcA" target="_blank" rel="noopener">IntelliJ IDEA 2020.2正式发布，诸多亮点总有几款能助你提效</a></li>
<li><a href="https://mp.weixin.qq.com/s/ikI9c3XyR_czOSmsu6FLMw" target="_blank" rel="noopener">Spring Boot 2.3.0正式发布：优雅停机、配置文件位置通配符新特性一览</a></li>
<li><a href="https://mp.weixin.qq.com/s/nb4oT02dlU4pxINZw9aLLw" target="_blank" rel="noopener">搞事情？Spring Boot今天一口气发布三个版本</a></li>
</ul>]]></content>
      <categories>
        <category>新特性</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>云原生</tag>
      </tags>
  </entry>
  <entry>
    <title>如果程序员和产品经理都用凡尔赛文学对话......</title>
    <url>/x2y/6992bf65.html</url>
    <content><![CDATA[<blockquote>
<p>有了坚持不一定成功；但没有坚持，就注定失败。本文已被 <a href="https://www.yourbatman.cn"><strong>https://www.yourbatman.cn</strong></a> 收录，里面一并有Spring技术栈、MyBatis、JVM、中间件等小而美的<strong>专栏</strong>供以免费学习。关注公众号【<strong>BAT的乌托邦</strong>】逐个击破，深入掌握，拒绝浅尝辄止。</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20201121075740568.png#pic_center" alt=""></p>
<h1 id="✍前言"><a href="#✍前言" class="headerlink" title="✍前言"></a>✍前言</h1><p>你好，我是YourBatman。</p>
<p>当我们还在双十一剁手的时候，“凡尔赛”三个字悄无声息的火了。凡尔赛，<strong>谐音烦而晒，又烦又爱晒</strong>。若你是第一次听到这三个字，那么反应可能和当时的我一样：<br><img data-src="https://img-blog.csdnimg.cn/20201121080501252.png#pic_center" alt=""><br>所以我赶紧用谷歌百度了一下。凡尔赛文学之流行，《Hallo，你好周杰伦》的伊能静也不经意间<strong>被</strong>凡尔赛了：双十一也没买多少，就900多个快递。<br><img data-src="https://img-blog.csdnimg.cn/20201121083956834.png#pic_center" alt=""><br>既然这么火，作为紧紧把握时代脉搏的后浪们就没有理由不去了解一波，特别是还有程序员和产品经理这对好CP可用。</p>
<h1 id="✍正文"><a href="#✍正文" class="headerlink" title="✍正文"></a>✍正文</h1><p>先了解什么是凡尔赛文学，再举例加强理解，最后评论区见，毕竟高手永远在民间。</p>
<h2 id="什么是凡尔赛文学？"><a href="#什么是凡尔赛文学？" class="headerlink" title="什么是凡尔赛文学？"></a>什么是凡尔赛文学？</h2><p>凡尔赛文学：网络热词，指通过先抑后扬、自问自答或第三人称视角，不经意间露出”贵族生活的线索”。</p>
<blockquote>
<p>此解释来自百度百科</p>
</blockquote>
<p>通俗的给它下个定义，需要满足三点：</p>
<ol>
<li><strong>先抑后扬</strong>，明贬暗褒</li>
<li>自问自答</li>
<li>灵活运用第三人称</li>
</ol>
<p>以平静淡泊的口吻，“不经意”地炫耀。用何老师的话解释凡尔赛文学：用最低调的话，炫最高调的耀。</p>
<p>为了更方便理解，下面举几个例子玩玩。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="政企界"><a href="#政企界" class="headerlink" title="政企界"></a>政企界</h3><p>普通家庭马化腾，不知妻美刘强东；<br>悔创阿里杰克马，北大还行撒贝宁；</p>
<ul>
<li><p><strong>普通家庭马化腾</strong><br><img data-src="https://img-blog.csdnimg.cn/20201121095720743.png#pic_center" alt=""></p>
</li>
<li><p><strong>不知妻美刘强东</strong><br><img data-src="https://img-blog.csdnimg.cn/20201121100311494.png#pic_center" alt=""></p>
</li>
<li><p><strong>悔创阿里杰克马</strong><br><img data-src="https://img-blog.csdnimg.cn/20201121100354779.png#pic_center" alt=""></p>
</li>
<li><p><strong>北大还行撒贝宁</strong><br><img data-src="https://img-blog.csdnimg.cn/20201121101116255.png#pic_center" alt=""></p>
</li>
<li><p><strong>先挣一亿王健林</strong><br><img data-src="https://img-blog.csdnimg.cn/20201121101345228.png#pic_center" alt=""></p>
</li>
</ul>
<p>这些大佬聊（装）天（x）的角度，让我等凡夫俗子望尘莫及。你听起来想给他扔一块板砖，然后呢你又不得不承认他们貌似真的没有在装，描述的事实。</p>
<h4 id="附：娱乐圈反凡尔赛"><a href="#附：娱乐圈反凡尔赛" class="headerlink" title="附：娱乐圈反凡尔赛"></a>附：娱乐圈反凡尔赛</h4><p>演技精湛吴亦凡；<br>一米八零黄晓明；<br>从未整容是杨颖；<br>冰清玉洁钟欣桐；<br>男儿本色是鹿晗；<br>摇滚教父是汪峰；<br>用情专一章子怡；<br>不近女色曾志伟；<br>从一而终郭富城；<br>不靠老子王思聪；<br>爱国艺人杜海涛；<br>清纯美女白百合；<br>阖家欢乐王宝强；<br>不用替身是杨洋；<br>坚持原创郭小四；<br>从不吸毒柯震东；<br>百花影帝李易峰；<br>铁血硬汉黄子韬；<br>贤妻良母是马蓉；</p>
<h3 id="科学界"><a href="#科学界" class="headerlink" title="科学界"></a>科学界</h3><ul>
<li><p><strong>牛顿(1643-1727)：就是宅在家时太闲了</strong><br><img data-src="https://img-blog.csdnimg.cn/20201121104333809.png#pic_center" alt=""><br>23岁才考进剑桥大学那年，爆发了大瘟疫只能stay at home。然后闲着没事就开始研究数学、力学、光学。当时没多想，光想着打发打发打发时间。然后搞出了微积分、力学定律、光的折射原理等，真没想到<strong>这些打发时间的成果竟然成为了现代数学、物理学的基础。</strong></p>
</li>
<li><p><strong>爱因斯坦(1879-1955)：写论文时也想参考文献</strong><br><img data-src="https://img-blog.csdnimg.cn/20201121104531886.png#pic_center" alt=""><br>在我研究牛顿力学的时候，我提出了<strong>相对论</strong>。当时的人基本都不懂，所以我好像搞出一点点东西都算是重大发现一样，奇怪得很。说起相对论，发论文的历程我觉得还是蛮心酸的。我在发表《狭义相对论》的第一篇论文时，<strong>一篇参考文献都找不到，不像现在动不动就有几百篇论文献可看，真是羡慕嫉妒（恨）。</strong></p>
</li>
</ul>
<h3 id="群众界"><a href="#群众界" class="headerlink" title="群众界"></a>群众界</h3><ul>
<li>哎呀凡尔赛文学到底是什么啊我现在还没搞明白，昨天刚去山里度假没信号，都没跟上时代啦！我今天早上登微博突然发现信号满格，原来是我先生昨天连夜建了信号站！直男又乱花钱，看来真的得好好谈谈了！</li>
<li>害，感冒了，好烦啊。一晚上7、8个妹子跟我抢被子，真难受。<strong>这还不是重点</strong>，一晚上床上掉落的什么猫眼钻戒啊，什么钻石项链是，什么钻石手机啊 ，都特别的硌人，睡得一点也不舒服</li>
<li>说出来挺不好意思的，我是最近才知道鸡蛋有壳的，以前都是吃管家剥好的，一直以为鸡蛋都是白色的软软的</li>
<li>今天又是努力搬砖的一天！根本没时间摸鱼，中午只能休息两个小时，虽然五点就能准时下班，但早上十点就得到公司，还容易堵车迟到，开兰博基尼有什么用，要不是公司是自己家的，工资早就扣没了</li>
<li>昨天领导汇报，说这个ppt如果不过关的话，年薪要降50万，这可是我一天饭钱呀</li>
<li>这几天真的心太累了，老板总是担心我会自己出去创业，人与人的信任呢，难道就因为我是硅谷回来的吗？唉，不说了</li>
<li>这阵子太难了，难过的要死，不敢在家哭，就定了机票去香港，看着房间外的维多利亚港，终于可以痛痛快快的哭一场。</li>
<li>每次定外卖，外卖小哥总是找不到我的家，每栋别墅都有门牌号的啊。算了，以后想吃什么还是让家里阿姨做吧</li>
<li>今天和朋友在博物馆看到一件青铜鼎，似曾相识。回到家才想起，原来和我家的书柜上那个是一对，也不知道我这么放会不会坏</li>
<li>真的很后悔加薪升职，工资算税后其实也就多了五十万而已，但是操心的事情却多了很多，打工真的不容易啊</li>
<li>好羡慕别人可以朝九晚五，在忙碌的生活节奏中找到自己存在的价值和意义，不像我，每天无所事事，只能靠收房租来勉强维生，这样的生活什么时候才能改变啊！</li>
<li>好纠结啊！同时收到了三家名牌大学的offer，我这个人最不擅长做选择了。早知道备考的时候就稍微放松点了，看来一个星期的复习备考时间还是有点长了</li>
<li>我对象不知道从哪里学到的坏毛病，一喝多就给我转账，上次直接转了6位数。我每次都说我不需要，我自己一个月工资够转给他好多次，他还是不听。唉，男人就是这样</li>
<li>难得跟先生一起共进周末晚餐，他果然还是订了那家米其林九星的澳洲羊肉串店，真是毫无新意，虽然要399一串，但吃100串之后也是味如嚼蜡。这都不是重点，重点是他非要喝酒。我说你别喝啦，我不会开你的法拉利，先生说，没事，撞坏了再买一部</li>
<li>…</li>
</ul>
<p><img data-src="https://img-blog.csdnimg.cn/20201121144938828.png#pic_center" alt=""></p>
<p>凡尔赛文学，让天下没有难装的x</p>
<h2 id="程序员VS产品经理"><a href="#程序员VS产品经理" class="headerlink" title="程序员VS产品经理"></a>程序员VS产品经理</h2><p>在IT界，不和程序员吵架的产品经理，不是一名合格的程序员，他们似乎有着“不共戴天”之仇。</p>
<p>还记得前两年的产品经理提的这个需求吗：<strong>App的主题颜色可根据手机壳颜色自动调整</strong>。当程序员小哥哥面对这个需求时，最终没再只停留在嘴上而选择了动手。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201121112300458.png#pic_center" alt=""></p>
<p>那么，如果程序员和产品经理都熟悉凡尔赛文学，他们又会有哪样互捧（掐）的场面对话呢？<br><img data-src="https://img-blog.csdnimg.cn/20201121112830193.png#pic_center" alt=""></p>
<hr>
<hr>
<hr>
<p>程序员웃：好羡慕你们用电脑一个屏幕就够了，不像我们要双屏。一个查资料，一个写代码<br><code>产品经理유</code>：哦。我这次方案本以为预算只有1万，没想到少看一个0而是10万，帮我想想如何花钱呗？<br>程序员웃：…<br><img data-src="https://img-blog.csdnimg.cn/20201121114927376.png#pic_center" alt=""></p>
<hr>
<p>程序员웃：刚参加工作那会特别喜欢使用机械键盘，声音清脆B格高。现在我觉得<strong>静电容</strong>的键盘也还行，手感也是挺好的<br><code>产品经理유</code>：我也不喜欢使用机械键盘，按键的声音太大。有时早起工作时会吵到旁边睡觉的妹纸<br><img data-src="https://img-blog.csdnimg.cn/20201121115437325.png#pic_center" alt=""></p>
<hr>
<p>程序员웃：双十一血拼结束，入手一块RTX4000，那打游戏真是太爽了。前端时间又刚买了房，现在房贷、花呗、借呗让我这个月只能吃土了<br><code>产品经理유</code>：真会享受<br>程序员웃：对了，你买了啥？<br><code>产品经理유</code>：买个锤子<br>程序员웃：锤子不是破产了吗？买IPhone 12 Pro Max呀<br><code>产品经理유</code>：是我上个月刚在二环内买了个四合院，装修有点破旧，买个锤子自己有空修整修整<br><img data-src="https://img-blog.csdnimg.cn/20201121145952429.png#pic_center" alt=""></p>
<hr>
<p>程序员웃：我这几年一直在公司核心部门，兢兢业业的为公司服务，每次都能解决一些技术难题。预计年底能给我升到小组长位置了，到时候汇报对象直接变为部门总监了，压力不小。老铁，你在干啥呢？<br><code>产品经理유</code>：搞PPT<br>程序员웃：这么晚了还在给客户写产品说明啊。对了，以后我就安排我的组长助理跟你对接需求了哈<br><code>产品经理유</code>：是晋升述职报告。我下周正式升任为产品总监了，直接汇报给CEO压力还是蛮大的，所以这么晚了还在调整PPT<br><img data-src="https://img-blog.csdnimg.cn/20201121152118203.png#pic_center" alt=""></p>
<hr>
<p>程序员웃：今天可以下个早班了，测试说测完没有Bug明天就可上线。我明明只用了5、6分精力敲的代码，竟然没有Bug，太不可思议了！<br><code>产品经理유</code>：哦，顺道来我家吃个饭？我今晚在公司附近这套房住，阿姨正在做饭，想吃什么？<br>程序员웃：…<br><img data-src="https://img-blog.csdnimg.cn/2020112115310945.png#pic_center" alt=""></p>
<hr>
<p>程序员웃：平时加班狗终于得到了回报，月底就能升职加薪了，不知道一个月拿10万是一种什么样的体验？<br><code>产品经理유</code>：不清楚呢，没拿过这么低的<br>程序员웃：你忙吧（NMB）<br><img data-src="https://img-blog.csdnimg.cn/2020112115045676.png#pic_center" alt=""></p>
<hr>
<p>程序员웃：自从当上部门经理后，就再也不用敲代码了。执行性的事情安排给下面去完成，然后我跟同事们聊聊天，划划水就行，时间长了感觉还蛮无聊的<br><code>产品经理유</code>：我每天也挺无聊的，自从家里拿到拆迁款从公司离职后，就再也没上过班。说实话还挺羡慕你有人聊天<br><img data-src="https://img-blog.csdnimg.cn/20201121154203644.gif#pic_center" alt=""></p>
<h1 id="✍总结"><a href="#✍总结" class="headerlink" title="✍总结"></a>✍总结</h1><p>其实“凡尔赛文学”只是大家工作生活之余的一个调侃，更多的时候只是网友用来自嘲，搞搞气氛还是不错的哈。这里提醒下，如果你不是公司创始人加董事长，只是打工的，不论你是CEO还是President，千万不要公开场合装这种类型的逼哦。</p>
<p>凡尔赛文学的入门门槛低，但想<strong>学成</strong>则非常之难。毕竟它的终极段位，不在口嗨，在于用真材实料克服心虚。比如你看看马云、马化腾、王健林等等。<br><img data-src="https://img-blog.csdnimg.cn/20201121095103304.png#pic_center" alt=""></p>
<hr>
<h5 id="✔推荐阅读："><a href="#✔推荐阅读：" class="headerlink" title="✔推荐阅读："></a>✔推荐阅读：</h5><ul>
<li><a href="https://fangshixiang.blog.csdn.net/article/details/109698458" target="_blank" rel="noopener">Spring Framework 5.3.0正式发布，在云原生路上继续发力</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZoUG9h1TndW2QpnPyGeIQA" target="_blank" rel="noopener">Spring改变版本号命名规则：此举对非英语国家很友好</a></li>
<li><a href="https://mp.weixin.qq.com/s/3QaiUGzj5nW2N4Aipm47PQ" target="_blank" rel="noopener">JDK15正式发布，划时代的ZGC同时宣布转正</a></li>
<li><a href="https://mp.weixin.qq.com/s/8voJSbmcBbdfNUCUBIcKcA" target="_blank" rel="noopener">IntelliJ IDEA 2020.2正式发布，诸多亮点总有几款能助你提效</a></li>
<li><a href="https://mp.weixin.qq.com/s/ikI9c3XyR_czOSmsu6FLMw" target="_blank" rel="noopener">Spring Boot 2.3.0正式发布：优雅停机、配置文件位置通配符新特性一览</a></li>
<li><a href="https://mp.weixin.qq.com/s/nb4oT02dlU4pxINZw9aLLw" target="_blank" rel="noopener">搞事情？Spring Boot今天一口气发布三个版本</a></li>
</ul>]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>凡尔赛文学</tag>
        <tag>程序员</tag>
      </tags>
  </entry>
  <entry>
    <title>6. 自定义容器类型元素验证，类级别验证（多字段联合验证）</title>
    <url>/x2y/787ed03b.html</url>
    <content><![CDATA[<blockquote>
<p>今天搬砖不狠，明天地位不稳。本文已被 <a href="https://www.yourbatman.cn"><strong>https://www.yourbatman.cn</strong></a> 收录，里面一并有Spring技术栈、MyBatis、JVM、中间件等小而美的<strong>专栏</strong>供以免费学习。关注公众号【<strong>BAT的乌托邦</strong>】逐个击破，深入掌握，拒绝浅尝辄止。</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20201025205032222.jpg" alt=""></p>
<h1 id="✍前言"><a href="#✍前言" class="headerlink" title="✍前言"></a>✍前言</h1><p>你好，我是YourBatman。</p>
<p>本文是上篇文章的续篇，个人建议可先花3分钟移步上篇文章浏览一下：<a href="https://mp.weixin.qq.com/s/6_7gZ9jmQcDSRiARO6D-yw" target="_blank" rel="noopener">5. Bean Validation声明式验证四大级别：字段、属性、容器元素、类</a></p>
<p>很多人说Bean Validation只能验证单属性（单字段），但我却说它能完成99.99%的Bean验证，不信你可继续阅读本文，能否解你疑惑。</p>
<h2 id="版本约定"><a href="#版本约定" class="headerlink" title="版本约定"></a>版本约定</h2><ul>
<li>Bean Validation版本：<code>2.0.2</code></li>
<li>Hibernate Validator版本：<code>6.1.5.Final</code></li>
</ul>
<h1 id="✍正文"><a href="#✍正文" class="headerlink" title="✍正文"></a>✍正文</h1><p>本文接上文叙述，继续介绍Bean Validation声明式验证四大级别中的：容器元素验证（自定义容器类型）以及类级别验证（也叫多字段联合验证）。</p>
<p>据我了解，很多小伙伴对这部分内容并不熟悉，遇到类似场景往往被迫只能是<strong>一半BV验证 + 一半事务脚本验证</strong>的方式，显得洋不洋俗不俗。 本文将给出具体案例场景，然后统一使用BV来解决数据验证问题，希望可以帮助到你，给予参考之作用。</p>
<h2 id="自定义容器类型元素验证"><a href="#自定义容器类型元素验证" class="headerlink" title="自定义容器类型元素验证"></a>自定义容器类型元素验证</h2><p>通过<a href="https://mp.weixin.qq.com/s/6_7gZ9jmQcDSRiARO6D-yw" target="_blank" rel="noopener">上文</a>我们已经知道了Bean Validation是可以对形如List、Set、Map这样的容器类型<strong>里面的元素</strong>进行验证的，内置支持的容器虽然能cover大部分的使用场景，但不免有的场景依旧不能覆盖，而且这个可能还非常常用。</p>
<p>譬如我们都不陌生的方法返回值容器<code>Result&lt;T&gt;</code>，结构形如这样（最简形式，仅供参考）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> success = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> T data = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String errCode;</span><br><span class="line">    <span class="keyword">private</span> String errMsg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Controller层用它包装（装载）数据data，形如这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/room"</span>)</span><br><span class="line"><span class="function">Result&lt;Room&gt; <span class="title">room</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Room</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="meta">@AssertTrue</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> finished;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候希望对<code>Result&lt;Room&gt;</code>里面的<code>Room</code>进行合法性验证：借助BV进行声明式验证而非硬编码。希望这么写就可以了：<code>Result&lt;@Notnull @Valid LoggedAccountResp&gt;</code>。显然，缺省情况下即使这样声明了约束注解也是无效的，毕竟Bean Validation根本就“不认识”Result这个“容器”，更别提验证其元素了。</p>
<p>好在Bean Validation对此提供了扩展点。下面我将一步一步的来对此提供实现，让验证优雅再次起来。</p>
<ul>
<li>自定义一个可以从<code>Result&lt;T&gt;</code>里提取出T值的<code>ValueExtractor</code>值提取器 </li>
</ul>
<p>Bean Validation允许我们对<strong>自定义容器</strong>元素类型进行支持。通过前面这篇文章：<a href="https://mp.weixin.qq.com/s/jzOv67ZTSx2rByj0aeUTgw" target="_blank" rel="noopener">4. Validator校验器的五大核心组件，一个都不能少</a> 知道要想支持自定义的容器类型，需要注册一个自定义的<code>ValueExtractor</code>用于值的提取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在此处添加备注信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yourbatman</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@site</span> https://www.yourbatman.cn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/10/25 10:01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Result</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultValueExtractor</span> <span class="keyword">implements</span> <span class="title">ValueExtractor</span>&lt;<span class="title">Result</span>&lt;@<span class="title">ExtractedValue</span> ?&gt;&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extractValues</span><span class="params">(Result&lt;?&gt; originalValue, ValueReceiver receiver)</span> </span>&#123;</span><br><span class="line">        receiver.value(<span class="keyword">null</span>, originalValue.getData());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将此自定义的值提取器注册进验证器Validator里，并提供测试代码：</li>
</ul>
<p>把Result作为一个Filed字段装进Java Bean里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Result&lt;<span class="meta">@Valid</span> Room&gt; roomResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Room room = <span class="keyword">new</span> Room();</span><br><span class="line">    room.name = <span class="string">"YourBatman"</span>;</span><br><span class="line">    Result&lt;Room&gt; result = <span class="keyword">new</span> Result&lt;&gt;();</span><br><span class="line">    result.setData(room);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把Result作为属性放进去</span></span><br><span class="line">    ResultDemo resultDemo = <span class="keyword">new</span> ResultDemo();</span><br><span class="line">    resultDemo.roomResult = result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册自定义的值提取器</span></span><br><span class="line">    Validator validator = ValidatorUtil.obtainValidatorFactory()</span><br><span class="line">            .usingContext()</span><br><span class="line">            .addValueExtractor(<span class="keyword">new</span> ResultValueExtractor())</span><br><span class="line">            .getValidator();</span><br><span class="line">    ValidatorUtil.printViolations(validator.validate(resultDemo));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行测试程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">roomResult.finished只能为<span class="keyword">true</span>，但你的值是： <span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<p>完美的实现了对Result“容器”里的元素进行了验证。</p>
<blockquote>
<p>小贴士：本例是把Result作为Java Bean的属性进行试验的。实际上大多数情况下是把它作为<strong>方法返回值</strong>进行校验。方式类似，有兴趣的同学可自行举一反三哈</p>
</blockquote>
<p>在此弱弱补一句，若在Spring Boot场景下你想像这样对<code>Result&lt;T&gt;</code>提供支持，那么你需要自行提供一个验证器来<strong>覆盖掉</strong>自动装配进去的，可参考<code>ValidationAutoConfiguration</code>。</p>
<h2 id="类级别验证（多字段联合验证）"><a href="#类级别验证（多字段联合验证）" class="headerlink" title="类级别验证（多字段联合验证）"></a>类级别验证（多字段联合验证）</h2><p>约束也可以放在<strong>类级别</strong>上（也就说注解标注在类上）。在这种情况下，验证的主体不是单个属性，而是整个对象。如果验证依赖于对象的<strong>几个属性</strong>之间的相关性，那么类级别约束就能搞定这一切。</p>
<p>这个需求场景在平时开发中也非常常见，比如此处我举个场景案例：<code>Room</code>表示一个教室，<code>maxStuNum</code>表示该教室允许的最大学生数，<code>studentNames</code>表示教室里面的学生们。很明显这里存在这么样一个规则：学生总数不能大于教室允许的最大值，即<code>studentNames.size() &lt;=  maxStuNum</code>。如果用事务脚本来实现这个验证规则，那么你的代码里肯定穿插着类似这样的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (room.getStudentNames().size() &gt; room.getMaxStuNum()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这么做也能达到校验的效果，但很明显这不够优雅。期望这种case依旧能借助Bean Validation来优雅实现，下面我来走一把。</p>
<p>相较于前面但字段/属性验证的使用case，这个需要验证的是<strong>整个对象</strong>（多个字段）。下面呀，我给出<strong>两种</strong>实现方式，供以参考。</p>
<h3 id="方式一：基于内置的-ScriptAssert实现"><a href="#方式一：基于内置的-ScriptAssert实现" class="headerlink" title="方式一：基于内置的@ScriptAssert实现"></a>方式一：基于内置的@ScriptAssert实现</h3><p>虽说Bean Validation没有内置任何类级别的注解，但Hibernate-Validator却对此提供了增强，弥补了其不足。<code>@ScriptAssert</code>就是HV内置的一个非常强大的、可以用于类级别验证注解，它可以很容易的处理这种case：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ScriptAssert</span>(lang = <span class="string">"javascript"</span>, alias = <span class="string">"_"</span>, script = <span class="string">"_.maxStuNum &gt;= _.studentNames.length"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Room</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Positive</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxStuNum;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; studentNames;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>@ScriptAssert</code>支持写脚本来完成验证逻辑，这里使用的是javascript（缺省情况下的唯一选择，也是默认选择）</p>
</blockquote>
<p>测试用例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Room room = <span class="keyword">new</span> Room();</span><br><span class="line">    ValidatorUtil.printViolations(ValidatorUtil.obtainValidator().validate(room));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，抛错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Caused by: &lt;eval&gt;:<span class="number">1</span> TypeError: Cannot get property <span class="string">"length"</span> of <span class="keyword">null</span></span><br><span class="line">	at jdk.nashorn.internal.runtime.ECMAErrors.error(ECMAErrors.java:<span class="number">57</span>)</span><br><span class="line">	at jdk.nashorn.internal.runtime.ECMAErrors.typeError(ECMAErrors.java:<span class="number">213</span>)</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>这个报错意思是<code>_.studentNames</code>值为null，也就是<code>room.studentNames</code>字段的值为null。</p>
<p>what？它头上不明明标了<code>@NotNull</code>注解吗，怎么可能为null呢？这其实涉及到前面所讲到的一个小知识点，这里提一嘴：<strong>所有的约束注解都会执行，不存在短路效果</strong>（除非校验程序抛异常），只要你敢标，我就敢执行，所以这里为嘛报错你懂了吧。</p>
<blockquote>
<p>小贴士：@ScriptAssert对null值并不免疫，不管咋样它都会执行的，因此书写脚本时注意判空哦</p>
</blockquote>
<p>当然喽，多个约束之间的执行也是可以排序（有序的），这就涉及到多个约束的执行顺序（序列）问题，本文暂且绕过。例子种先给填上一个值，后续再专文详解多个约束注解执行序列问题和案例剖析。</p>
<p>修改测试脚本（增加一个学生，让其不为null）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Room room = <span class="keyword">new</span> Room();</span><br><span class="line">    room.setStudentNames(Collections.singletonList(<span class="string">"YourBatman"</span>));</span><br><span class="line"></span><br><span class="line">    ValidatorUtil.printViolations(ValidatorUtil.obtainValidator().validate(room));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次运行，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">执行脚本表达式<span class="string">"_.maxStuNum &gt;= _.studentNames.length"</span>没有返回期望结果，但你的值是： Room(maxStuNum=<span class="number">0</span>, studentNames=[YourBatman])</span><br><span class="line">maxStuNum必须是正数，但你的值是： <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>验证结果符合预期：0（maxStuNum） &lt; 1（studentNames.length）。</p>
<blockquote>
<p>小贴士：若测试脚本中增加一句<code>room.setMaxStuNum(1);</code>，那么请问结果又如何呢？</p>
</blockquote>
<h3 id="方式二：自定义注解方式实现"><a href="#方式二：自定义注解方式实现" class="headerlink" title="方式二：自定义注解方式实现"></a>方式二：自定义注解方式实现</h3><p>虽说BV自定义注解前文还暂没提到，但这并不难，因此这里先混个脸熟，也可在阅读到后面文章后再杀个回马枪回来。</p>
<ul>
<li>自定义一个约束注解，并且提供约束逻辑的实现<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;TYPE, ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="meta">@Constraint</span>(validatedBy = &#123;ValidStudentCountConstraintValidator<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">ValidStudentCount</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "学生人数超过最大限额"</span>;</span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidStudentCountConstraintValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">ValidStudentCount</span>, <span class="title">Room</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ValidStudentCount constraintAnnotation)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(Room room, ConstraintValidatorContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (room == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> isValid = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (room.getStudentNames().size() &lt;= room.getMaxStuNum()) &#123;</span><br><span class="line">            isValid = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义提示语（当然你也可以不自定义，那就使用注解里的message字段的值）</span></span><br><span class="line">        <span class="keyword">if</span> (!isValid) &#123;</span><br><span class="line">            context.disableDefaultConstraintViolation();</span><br><span class="line">            context.buildConstraintViolationWithTemplate(<span class="string">"校验失败xxx"</span>)</span><br><span class="line">                    .addPropertyNode(<span class="string">"studentNames"</span>)</span><br><span class="line">                    .addConstraintViolation();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isValid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>书写测试脚本<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Room room = <span class="keyword">new</span> Room();</span><br><span class="line">    room.setStudentNames(Collections.singletonList(<span class="string">"YourBatman"</span>));</span><br><span class="line"></span><br><span class="line">    ValidatorUtil.printViolations(ValidatorUtil.obtainValidator().validate(room));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
运行程序，输出：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">maxStuNum必须是正数，但你的值是： <span class="number">0</span></span><br><span class="line">studentNames校验失败xxx，但你的值是： Room(maxStuNum=<span class="number">0</span>, studentNames=[YourBatman])</span><br></pre></td></tr></table></figure>
完美，完全符合预期。</li>
</ul>
<p>这两种方式都可以实现类级别的验证，它俩可以说各有优劣，主要体现在如下方面：</p>
<ul>
<li><code>@ScriptAssert</code>是内置就提供的，因此使用起来非常的方便和通用。但缺点也是因为过于通用，因此语义上不够明显，需要阅读脚本才知。推荐少量（非重复使用）、逻辑较为简单时使用</li>
<li>自定义注解方式。缺点当然是“开箱使用”起来稍显麻烦，但它的优点就是语义明确，灵活且不易出错，即使是复杂的验证逻辑也能轻松搞定</li>
</ul>
<p>总之，若你的验证逻辑只用一次（只一个地方使用）且简单（比如只是简单判断而已），推荐使用<code>@ScriptAssert</code>更为轻巧。否则，你懂的~</p>
<h1 id="✍总结"><a href="#✍总结" class="headerlink" title="✍总结"></a>✍总结</h1><p>如果说能熟练使用Bean Validation进行字段、属性、容器元素级别的验证是及格60分的话，那么能够使用BV解决本文中几个场景问题的话就应该达到优秀级80分了。</p>
<p>本文举例的两个场景：<code>Result&lt;T&gt;</code>和多字段联合验证均属于平时开发中比较常见的场景，如果能让Bean Validation介入帮解决此类问题，相信对提效是很有帮助的，说不定你还能成为团队中最靓的仔呢。</p>
<h5 id="✔推荐阅读："><a href="#✔推荐阅读：" class="headerlink" title="✔推荐阅读："></a>✔推荐阅读：</h5><ul>
<li><a href="https://mp.weixin.qq.com/s/g04HMhrjbvbPn1Mb9JYa5g" target="_blank" rel="noopener">1. 不吹不擂，第一篇就能提升你对Bean Validation数据校验的认知</a></li>
<li><a href="https://mp.weixin.qq.com/s/-KeOCq2rsXCvrqD8HYHSpQ" target="_blank" rel="noopener">2. Bean Validation声明式校验方法的参数、返回值</a></li>
<li><a href="https://mp.weixin.qq.com/s/MQjXG0cg8domRtwf3ArvHw" target="_blank" rel="noopener">3. 站在使用层面，Bean Validation这些标准接口你需要烂熟于胸</a></li>
<li><a href="https://mp.weixin.qq.com/s/jzOv67ZTSx2rByj0aeUTgw" target="_blank" rel="noopener">4. Validator校验器的五大核心组件，一个都不能少</a></li>
<li><a href="https://mp.weixin.qq.com/s/6_7gZ9jmQcDSRiARO6D-yw" target="_blank" rel="noopener">5. Bean Validation声明式验证四大级别：字段、属性、容器元素、类</a></li>
</ul>]]></content>
      <categories>
        <category>A哥学数据校验</category>
      </categories>
      <tags>
        <tag>Bean Validation</tag>
        <tag>Hibernate Validator</tag>
        <tag>数据校验</tag>
        <tag>JSR380</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring改变版本号命名规则：此举对非英语国家很友好</title>
    <url>/x2y/78d89441.html</url>
    <content><![CDATA[<blockquote>
<p>要想改变命运，首先改变自己。本文已被 <a href="https://www.yourbatman.cn"><strong>https://www.yourbatman.cn</strong></a> 收录，里面一并有Spring技术栈、MyBatis、JVM、中间件等小而美的<strong>专栏</strong>供以免费学习。关注公众号【<strong>BAT的乌托邦</strong>】逐个击破，深入掌握，拒绝浅尝辄止。</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20201114230749457.png" alt=""></p>
<h1 id="✍前言"><a href="#✍前言" class="headerlink" title="✍前言"></a>✍前言</h1><p>你好，我是YourBatman。</p>
<p>还记得在今年5月份样子看到了一篇来自Pivotal的邮件，大致内容是说Spring改变了版本号的命名规则，当时本着先收藏一下准备晚上再看，然后，就没有然后了。</p>
<p>直到前些天突然看到了篇标题为：<code>Spring Data 2020.0.0</code>正式发布的文章，这才让我把此事联想了起来，因此才决定写此文记录一下，顺带分享给你。</p>
<blockquote>
<p>若你已苦于Spring Cloud的版本号命名方式，那么本文给你带来了曙光</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20201114183420279.png#pic_center" alt=""></p>
<h1 id="✍正文"><a href="#✍正文" class="headerlink" title="✍正文"></a>✍正文</h1><p>天下苦Spring Cloud版本命名久矣。在正式开始之前，管生管养的A哥有意对这其中的相关名词进行解释，方便理解本文。</p>
<h2 id="Release-Train"><a href="#Release-Train" class="headerlink" title="Release Train"></a>Release Train</h2><p>Release Train直译过来意思为：发版火车/火车发版。火车大家不陌生，它有一个显著的特点：<strong>定时定点发车</strong>。这里的<strong>发车</strong>在软件领域就等同于软件的<strong>发版</strong>。<br><img data-src="https://img-blog.csdnimg.cn/2020111419165664.png#pic_center" alt=""></p>
<h3 id="为何需要Release-Train发版模式？"><a href="#为何需要Release-Train发版模式？" class="headerlink" title="为何需要Release Train发版模式？"></a>为何需要Release Train发版模式？</h3><p>在公司还很小很小的时候，整个公司可能只有一个软件，版本发布非常的简单，没什么需要协调的，发就完了。<strong>但是</strong>，一旦公司快速发展变得比较大后，核心产品功能数以十、百计，各功能模块由不同的团队负责，沟通成本明显升高，单单在版本上稍不注意就会产生各种问题，很容易给人一种“乱如麻”的感觉。</p>
<p>使用Release Train的发版模式就能很大程度上避免这些问题，可以这样做：规定每个月的最后一天（精确的发版日期）需要发一版（类比于火车发车），那么就可以以这个时间点为deadline，<strong>参与的</strong>的各方包括产品经理、RD、QA等等都提前沟通好需求内容，并做好计划，充分做好统一发车的准备。在这期间，如果中间某一团队出现问题跟不上节奏了，那么请<strong>及时下车</strong>（前提是控制好下车的影响面），不要影响整体发车时间点。</p>
<p>总的来讲：火车是按点准时出发的，各方应按点上车，倘若本次赶不上车的那么就请<strong>等下一趟车</strong>。通过这种方式可以确保软件产品的<strong>持续迭代</strong>，保证产品的稳定性，这就是Release Train发版模式。</p>
<p>在实际的软件产品中，可以认为稍微大一点的软件都是按照此模式来持续迭代的，比如IOS、maxOS、MIUI、Spring Cloud等等。这些软件版本在命名方式上不同但均遵循一定规律：</p>
<ul>
<li>IOS 14、IOS 14.1、IOS14.1.1</li>
<li>macOS Mojave、macOS Sierra</li>
<li>Spring Cloud Greenwich、Spring Cloud Hoxton</li>
</ul>
<h2 id="Project-Module"><a href="#Project-Module" class="headerlink" title="Project Module"></a>Project Module</h2><p>如果说按照Release Train发版模式发出的一个版本代表着一个大的产品版本号，那么Project Module就代表其内部的模块。一般一个软件产品由N多个模块组成，以最新的<code>Spring Data 2020.0.0</code>版本为例，内含有多个Project Module模块：</p>
<ul>
<li>Spring Data Commons 2.4</li>
<li>Spring Data JDBC 2.1</li>
<li>Spring Data JPA 2.4</li>
<li>Spring Data MongoDB 3.1</li>
<li>Spring Data KeyValue 2.4</li>
<li>Spring Data LDAP 2.4</li>
<li>Spring Data Elasticsearch 4.1</li>
<li>…</li>
</ul>
<h2 id="Semantic-Versioning"><a href="#Semantic-Versioning" class="headerlink" title="Semantic Versioning"></a>Semantic Versioning</h2><p>语义化版本号，有被称作语义化版本控制规范，简称“SemVer”。它是一套版本号规则的<strong>标准/规范</strong>，用于改善软件版本号格式混乱问题，顺便统一一下版本号所表达的含义。官方主页是：<a href="https://semver.org" target="_blank" rel="noopener">https://semver.org</a></p>
<h3 id="版本号组成"><a href="#版本号组成" class="headerlink" title="版本号组成"></a>版本号组成</h3><p>SemVer版本号主要由<strong>三个部分</strong>组成，每个部分是一个非负整数，部分和部分之间用<code>.</code>分隔：<code>主版本号.次版本号.修订号</code>（简写为<code>x.y.z</code>）。下面对这三部分做出解释（约定）：</p>
<ul>
<li>主版本号：只有进行非向下兼容的修改或者颠覆性的更新时，主版本号加1<ul>
<li>话外音：改变很大，暴力式更改</li>
</ul>
</li>
<li>次版本号：进行<strong>向下兼容</strong>的修改或者添加兼容性的新功能时，次版本号加1<ul>
<li>话外音：改变不很大，<strong>一般</strong>是向下兼容的。值得注意的是：这里指的是一般，有些情况也存在不兼容情况也是允许的，当然不能是主要功能不兼容</li>
</ul>
</li>
<li>补丁号：没有新功能加入，一般修复bug、优化代码等，补丁号加1<ul>
<li>话外音：此版本号可放心无缝升级</li>
</ul>
</li>
</ul>
<p>关于这三部分还有两点值得注意：</p>
<ol>
<li>版本号均从0开始（包括主版本号）<ol>
<li>主版本号为零（0.y.z）的软件处于<strong>开发初始阶段</strong>，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版</li>
<li>1.0.0 的版本号用于<strong>界定</strong>公共 API 的形成。也就说从</li>
</ol>
</li>
<li>当主版本号更新时，次版本号和补丁号都要归零；次版本号更新时补丁号归零</li>
</ol>
<h3 id="版本号比较"><a href="#版本号比较" class="headerlink" title="版本号比较"></a>版本号比较</h3><p>这种三段式的版本号是<strong>可以比较大小</strong>的。比较的顺序是：<strong>主版本号、次版本号、补丁号</strong>。举例：<code>4.3.0 &lt; 5.0.0 &lt; 5.0.3 &lt; 5.1.0</code></p>
<blockquote>
<p>说明：使用<code>.</code>分隔开的话，正常比较（当字符串比较）是不会出现形如<code>.2. &gt; .10.</code>的问题的</p>
</blockquote>
<p>值得注意的是，Semantic Versioning只是一个标准，它并没有提供实现（比如版本号比较），虽然按照此规则自己实现一个并不复杂，但我建议各位<strong>不要自己实现</strong>，毕竟这种轮子社区里大把的，各种语言的都有哦，何必重复造呢。</p>
<h2 id="Calendar-Versioning"><a href="#Calendar-Versioning" class="headerlink" title="Calendar Versioning"></a>Calendar Versioning</h2><p>日历化版本，简称CalVer。CalVer不是基于任意数字，而是基于项目<strong>发布日期</strong>的版本控制约定。相较于语义化版本号，日历化版本号更接地气，显得<strong>活力</strong>更强些。因为日期是单向向前的，因此版本随着时间的推移会变得更好。</p>
<h3 id="方案类别"><a href="#方案类别" class="headerlink" title="方案类别"></a>方案类别</h3><p>有多种日历化版本方案，长期被各种大小项目使用。对于CalVer来说，它的规范非常抽象，毕竟发布日期本就是一个很抽象的概念嘛。</p>
<p>CalVer 并未像 “语义化版本” 那样选择单一方案， 而是引入了开发人员的 标准术语：</p>
<ul>
<li>YYYY：年份全称。如：2020</li>
<li>YY：年费缩写。如：20</li>
<li>MM：月份缩写。如：1、2、3</li>
<li>DD：日缩写。如：1、2、3</li>
<li>…</li>
</ul>
<p>和日期格式化类似有木有。是的，日期你可以随意，甚至可以是任意递增格式，但建议使用标准格式而已。</p>
<h2 id="Spring改变版本号命名规则"><a href="#Spring改变版本号命名规则" class="headerlink" title="Spring改变版本号命名规则"></a>Spring改变版本号命名规则</h2><p>Spring团队在其官网博客里于2020-04-30对外宣布要改变版本号命名规则，共包含两部分的内容：</p>
<ol>
<li><strong>Release Train</strong>版本规则改变</li>
<li><strong>Project Module</strong>版本规则改变</li>
</ol>
<p>这些改变将在<strong>下一个</strong>发布版本里体现出来，比如我们<strong>已经</strong>能看到的使用新规则命名版本号的是：Spring Data 2020.0.0、Spring Data 2020.0.1</p>
<h3 id="Release-Train版本规则改变"><a href="#Release-Train版本规则改变" class="headerlink" title="Release Train版本规则改变"></a>Release Train版本规则改变</h3><p>Spring自2013年以来一直按照<strong>字母表顺序</strong>来进行排序版本。举例两个典型的，也是我们比较熟悉的按照Release Train发版的项目给你瞧一瞧，我绘制成图标如下：</p>
<p><strong>Spring Data</strong>：</p>
<table>
<thead>
<tr>
<th>Release Train</th>
<th>发布日期</th>
</tr>
</thead>
<tbody><tr>
<td>Spring Data <strong>Arora</strong></td>
<td>2013-02</td>
</tr>
<tr>
<td>Spring Data <strong>Babbage</strong></td>
<td>2013-09</td>
</tr>
<tr>
<td>Spring Data <strong>Codd</strong></td>
<td>2014-02</td>
</tr>
<tr>
<td>Spring Data <strong>Dijkstra</strong></td>
<td>2014-05</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>Spring Data <strong>Neumann</strong></td>
<td>2020-05</td>
</tr>
<tr>
<td><code>Spring Data 2020.0.0</code></td>
<td><code>2020-10</code></td>
</tr>
</tbody></table>
<p><strong>Spring Cloud</strong>：</p>
<table>
<thead>
<tr>
<th>Release Train</th>
<th>发布日期</th>
</tr>
</thead>
<tbody><tr>
<td>Spring Cloud <strong>Angel</strong></td>
<td>2015-06</td>
</tr>
<tr>
<td>Spring Cloud <strong>Brixton</strong></td>
<td>2016-05</td>
</tr>
<tr>
<td>Spring Cloud <strong>Camden</strong></td>
<td>2016-09</td>
</tr>
<tr>
<td>Spring Cloud <strong>Dalston</strong></td>
<td>2017-04</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>Spring Cloud <strong>Hoxton</strong></td>
<td>2019-11</td>
</tr>
<tr>
<td><code>Spring Cloud 2020.0.0-M4</code></td>
<td><code>2020-10</code></td>
</tr>
</tbody></table>
<p><img data-src="https://img-blog.csdnimg.cn/20201114231138960.png#pic_center" alt=""></p>
<blockquote>
<p>注意：截止目前，Spring Cloud 2020的正式版还未正式发布，预计11月结束之前会正式推出，以支持Spring Boot 2.4.0</p>
</blockquote>
<h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><p>如上表所示，按照字母表排序作为版本号是存在如下问题的：</p>
<ol>
<li>按照字母排序，对于<strong>非英文</strong>国家有一定门槛难以记忆（比如天朝的程序员们）</li>
<li>如果排序字母到达<code>Z</code>了，就会出现命名上的难题了</li>
<li>从版本号上不能体现出向下兼容性，着让使用者（准备升级者）很难做出判断而做出风险预估</li>
<li>单词的拼写很困难（版本号都得靠复制，现在是降低效率的表现）</li>
</ol>
<h4 id="解决问题（改变后）"><a href="#解决问题（改变后）" class="headerlink" title="解决问题（改变后）"></a>解决问题（改变后）</h4><p>为了解决这些问题，Spring采用了<strong>日历化版本</strong>，并且使用的规则/公式是<code>YYYY.MINOR.MICRO[-MODIFIER]</code>，对各部分解释如下：</p>
<ul>
<li>YYYY：年份全称。eg：2020</li>
<li>MINOR：辅助版本号（一般升级些非主线功能），在当前年内从0递增</li>
<li>MICRO：补丁版本号（一般修复些bug），在当前年内从0递增</li>
<li>MODIFIER：<strong>非必填</strong>。后缀，它用于修饰一些关键节点，用这些字母表示 <ul>
<li>M数字：里程碑版本，如2020.0.0-M1、2020.0.0-M2</li>
<li>RC数字：发布候选版本，如2020.0.0-RC1、2020.0.0-RC2</li>
<li>SNAPSHOT：快照版本（后无数字哦），如2020.0.0-SNAPSHOT</li>
<li>啥都木有：正式版本（可放心使用，相当于之前的xxx-RELEASE），如<code>2020.0.0</code></li>
</ul>
</li>
</ul>
<p>通过新的版本命名方式，解决了向后兼容带来的问题（一看版本号就能清晰的知道向后兼容性如何），不再存在上限焦虑了，并且这种排序对<strong>非英语国家</strong>非常友好，点赞。<br><img data-src="https://img-blog.csdnimg.cn/20201114220129256.png#pic_center" alt=""><br>自此，对于Spring Cloud来说H版是它最后一个用英文单词命名的版本号了，下个版本将是<code>Spring Cloud 2020.0.0</code>，预计在本月正式发布。</p>
<h3 id="Project-Module版本规则改变"><a href="#Project-Module版本规则改变" class="headerlink" title="Project Module版本规则改变"></a>Project Module版本规则改变</h3><p>对于项目模块的版本号而言，其实Spring早在其<code>3.0.0.M1</code>版本（2008年）就使用了“语义化版本”规则进行发布管理。本可以不用做改动也行，但Spring官方觉得既然这次对Release Train做了修整，那就一起调整下是更好的。</p>
<p>项目模块的版本规则Spirng采用Semantic Versioning语义版本号规范，另外呢Spring还希望开发者很容易熟悉这个版本号，因此制定了这个模版：<code>MAJOR.MINOR.PATCH[-MODIFIER]</code>。前面三部分就不再解释啦，详情请看上面的关于<code>Semantic Versioning</code>的说明。对于最后面的MODIFIER部分保持了和Release Train一模一样的语义：</p>
<ul>
<li>MODIFIER：<strong>非必填</strong>。后缀，它用于修饰一些关键节点，用这些字母表示 <ul>
<li>M数字：里程碑版本，如2.4.0-M1、2.4.0-M2</li>
<li>RC数字：发布候选版本，如2.4.0-RC1、2.4.0-RC2</li>
<li>SNAPSHOT：快照版本（后无数字哦），如2.4.0-SNAPSHOT</li>
<li>啥都木有：正式版本（可放心使用，相当于之前的xxx-RELEASE），如<code>2.4.0</code></li>
</ul>
</li>
</ul>
<p>总的来说此部分规则改变并不大，简单对比就是这样：<br>改变前     | 改变后<br>——– | —–<br>3.0.0.M1  | 3.0.0-M1</p>
<p>以最新发布的Spirng Framework版本为例，它应用了最新的发版规则：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 5.2.0.RELEASE --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对比新旧版本号可知，新规则最大的区别是<strong>干掉了</strong> <code>.RELEASE</code>，因此书写时请稍加注意。</p>
<h1 id="✍总结"><a href="#✍总结" class="headerlink" title="✍总结"></a>✍总结</h1><p>本次Spring做出版本号规则的调整，更加彰显活力。喜闻乐见的是这名称对于处于天朝的我们是利好啊，毕竟SC的那些英文单词你能记住几个？现在书写其版本号终于可以<strong>盲写</strong>了，并且通过版本号能<strong>非常直观</strong>的知晓到当前使用版本的新旧程度，从而做出相关判断/预估，非常便捷。</p>
<p>另外，截止稿前，Spring Boot 2.4.0（注意木有.RELEASE了哦）以及Spring Framework 5.3.0均已重磅发布，为了给马上到来的Spring Cloud 2020.0.0做好铺垫，接下来几篇文章将对它俩进行阐述，欢迎持续关注。</p>
<h5 id="✔推荐阅读："><a href="#✔推荐阅读：" class="headerlink" title="✔推荐阅读："></a>✔推荐阅读：</h5><ul>
<li><a href="https://mp.weixin.qq.com/s/3QaiUGzj5nW2N4Aipm47PQ" target="_blank" rel="noopener">JDK15正式发布，划时代的ZGC同时宣布转正</a></li>
<li><a href="https://mp.weixin.qq.com/s/8voJSbmcBbdfNUCUBIcKcA" target="_blank" rel="noopener">IntelliJ IDEA 2020.2正式发布，诸多亮点总有几款能助你提效</a></li>
<li><a href="https://mp.weixin.qq.com/s/ikI9c3XyR_czOSmsu6FLMw" target="_blank" rel="noopener">Spring Boot 2.3.0正式发布：优雅停机、配置文件位置通配符新特性一览</a></li>
<li><a href="https://mp.weixin.qq.com/s/nb4oT02dlU4pxINZw9aLLw" target="_blank" rel="noopener">搞事情？Spring Boot今天一口气发布三个版本</a></li>
</ul>]]></content>
      <categories>
        <category>新特性</category>
      </categories>
      <tags>
        <tag>Spring Framework</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>5. Bean Validation声明式验证四大级别：字段、属性、容器元素、类</title>
    <url>/x2y/a0e8d910.html</url>
    <content><![CDATA[<blockquote>
<p>1024，代码改变世界。本文已被 <a href="https://www.yourbatman.cn"><strong>https://www.yourbatman.cn</strong></a> 收录，里面一并有Spring技术栈、MyBatis、JVM、中间件等小而美的<strong>专栏</strong>供以免费学习。关注公众号【<strong>BAT的乌托邦</strong>】逐个击破，深入掌握，拒绝浅尝辄止。</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20201023161125192.jpg" alt=""></p>
<h1 id="✍前言"><a href="#✍前言" class="headerlink" title="✍前言"></a>✍前言</h1><p>你好，我是YourBatman。又一年1024程序员节，你快乐吗？还是在加班上线呢？</p>
<p><a href="https://mp.weixin.qq.com/s/jzOv67ZTSx2rByj0aeUTgw" target="_blank" rel="noopener">上篇文章</a> 介绍了Validator校验器的五大核心组件，在结合前面几篇所讲，相信你对Bean Validation已有了一个整体认识了。</p>
<p>本文将<strong>非常实用</strong>，因为将要讲述的是Bean Validation在4个层级上的验证方式，它将覆盖你使用过程中的方方面面，不信你看。</p>
<h2 id="版本约定"><a href="#版本约定" class="headerlink" title="版本约定"></a>版本约定</h2><ul>
<li>Bean Validation版本：<code>2.0.2</code></li>
<li>Hibernate Validator版本：<code>6.1.5.Final</code></li>
</ul>
<h1 id="✍正文"><a href="#✍正文" class="headerlink" title="✍正文"></a>✍正文</h1><p>Jakarta Bean它的验证约束是通过声明式方式（注解）来表达的，我们知道Java注解几乎可以标注在任何地方（package上都可标注注解你敢信？），那么Jakarta Bean支持哪些呢？</p>
<p><strong>Jakarta Bean</strong>共支持四个级别的约束：</p>
<ol>
<li>字段约束（Field）</li>
<li>属性约束（Property）</li>
<li>容器<strong>元素</strong>约束（Container Element）</li>
<li>类约束（Class）</li>
</ol>
<p>值得注意的是，并不是所有的<strong>约束注解</strong>都能够标注在上面四种级别上。现实情况是：Bean Validation自带的22个标准约束全部支持1/2/3级别，且全部<strong>不支持</strong>第4级别（类级别）约束。当然喽，作为补充的<code>Hibernate-Validator</code>它提供了一些专门用于类级别的约束注解，如<code>org.hibernate.validator.constraints.@ScriptAssert</code>就是一常用案例。</p>
<p>说明：为简化接下来示例代码，共用工具代码提前展示如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidatorUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ValidatorFactory <span class="title">obtainValidatorFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Validation.buildDefaultValidatorFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Validator <span class="title">obtainValidator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obtainValidatorFactory().getValidator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutableValidator <span class="title">obtainExecutableValidator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obtainValidator().forExecutables();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printViolations</span><span class="params">(Set&lt;ConstraintViolation&lt;T&gt;&gt; violations)</span> </span>&#123;</span><br><span class="line">        violations.stream().map(v -&gt; v.getPropertyPath()  + v.getMessage() + <span class="string">"，但你的值是： "</span> + v.getInvalidValue()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1、字段级别约束（Field）"><a href="#1、字段级别约束（Field）" class="headerlink" title="1、字段级别约束（Field）"></a>1、字段级别约束（Field）</h2><p>这是我们<strong>最为常用</strong>的一种约束方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Room</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="meta">@AssertTrue</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> finished;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>书写测试用例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Room bean = <span class="keyword">new</span> Room();</span><br><span class="line">    bean.finished = <span class="keyword">false</span>;</span><br><span class="line">    ValidatorUtil.printViolations(ValidatorUtil.obtainValidator().validate(bean));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">finished只能为<span class="keyword">true</span>，但你的值是： <span class="keyword">false</span></span><br><span class="line">name不能为<span class="keyword">null</span>，但你的值是： <span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<p>当把约束标注在Field字段上时，Bean Validation将使用字段的访问策略来校验，<strong>不会调用任何方法</strong>，即使你提供了对应的get/set方法也不会触碰。</p>
<blockquote>
<p>话外音：使用<code>Field#get()</code>得到字段的值</p>
</blockquote>
<h3 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h3><ol>
<li>字段约束可以应用于<strong>任何访问修饰符</strong>的字段</li>
<li>不支持对静态字段的约束（static静态字段使用约束无效）</li>
</ol>
<p>若你的对象会被<strong>字节码增强</strong>，那么请不要使用Field约束，而是使用下面介绍的属性级别约束更为合适。</p>
<blockquote>
<p>原因：增强过的类并不一定能通过字段反射去获取到它的值</p>
</blockquote>
<p>绝大多数情况下，对Field字段做约束的话均是POJO，被增强的可能性极小，因此此种方式是<strong>被推荐的</strong>，看着清爽。</p>
<h2 id="2、属性级别约束（Property）"><a href="#2、属性级别约束（Property）" class="headerlink" title="2、属性级别约束（Property）"></a>2、属性级别约束（Property）</h2><p>若一个Bean遵循<strong>Java Bean规范</strong>，那么也可以使用属性约束来代替字段约束。比如上例可改写为如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Room</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> finished;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AssertTrue</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> finished;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行上面相同的测试用例，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">finished只能为<span class="keyword">true</span>，但你的值是： <span class="keyword">false</span></span><br><span class="line">name不能为<span class="keyword">null</span>，但你的值是： <span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<p>效果“完全”一样。</p>
<p>当把约束标注在Property属性上时，将采用属性访问策略来获取要验证的值。说白了：会调用你的Method来获取待校验的值。</p>
<h3 id="使用细节-1"><a href="#使用细节-1" class="headerlink" title="使用细节"></a>使用细节</h3><ol>
<li>约束放在get方法上<strong>优于</strong>放在set方法上，这样只读属性（没有get方法）依然可以执行约束逻辑</li>
<li>不要在<strong>属性和字段</strong>上都标注注解，否则会重复执行约束逻辑（有多少个注解就执行多少次）</li>
<li>不要既在属性的get方法上又在set方法上标注约束注解</li>
</ol>
<h2 id="3、容器元素级别约束（Container-Element）"><a href="#3、容器元素级别约束（Container-Element）" class="headerlink" title="3、容器元素级别约束（Container Element）"></a>3、容器元素级别约束（Container Element）</h2><p>还有一种非常非常常见的验证场景：验证容器内（每个）元素，也就验证参数化类型<code>parameterized type</code>。形如<code>List&lt;Room&gt;</code>希望里面装的每个Room都是合法的，传统的做法是在for循环里对每个room进行验证：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Room&gt; beans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Room bean : beans) &#123;</span><br><span class="line">    validate(bean);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显这么做至少存在下面两个不足：</p>
<ol>
<li>验证逻辑具有侵入性</li>
<li>验证逻辑是黑匣子（不看内部源码无法知道你有哪些约束），非声明式</li>
</ol>
<p>在本专栏<a href="https://mp.weixin.qq.com/s/g04HMhrjbvbPn1Mb9JYa5g" target="_blank" rel="noopener">第一篇</a>知道了从Bean Validation 2.0开始就支持容器元素校验了（本专栏使用版本为：<code>2.02</code>），下面我们来体验一把：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Room</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="meta">@AssertTrue</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> finished;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>书写测试用例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;<span class="meta">@NotNull</span> Room&gt; rooms = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    rooms.add(<span class="keyword">null</span>);</span><br><span class="line">    rooms.add(<span class="keyword">new</span> Room());</span><br><span class="line"></span><br><span class="line">    Room room = <span class="keyword">new</span> Room();</span><br><span class="line">    room.name = <span class="string">"YourBatman"</span>;</span><br><span class="line">    rooms.add(room);</span><br><span class="line"></span><br><span class="line">    ValidatorUtil.printViolations(ValidatorUtil.obtainValidator().validate(rooms));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，<strong>没有任何输出</strong>，也就是说并没有对rooms立面的元素进行验证。这里有一个误区：Bean Validator是基于<strong>Java Bean</strong>进行验证的，而此处你的<code>rooms</code>仅仅只是一个容器类型的变量而已，因此不会验证。</p>
<blockquote>
<p>其实它是把List当作一个Bean，去验证List里面的标注有约束注解的属性/方法。很显然，List里面不可能标注有约束注解嘛，所以什么都不输出喽</p>
</blockquote>
<p>为了让验证生效，我们只需这么做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rooms</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;<span class="meta">@Valid</span> <span class="meta">@NotNull</span> Room&gt; rooms;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;<span class="meta">@NotNull</span> Room&gt; beans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    beans.add(<span class="keyword">null</span>);</span><br><span class="line">    beans.add(<span class="keyword">new</span> Room());</span><br><span class="line"></span><br><span class="line">    Room room = <span class="keyword">new</span> Room();</span><br><span class="line">    room.name = <span class="string">"YourBatman"</span>;</span><br><span class="line">    beans.add(room);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须基于Java Bean，验证才会生效</span></span><br><span class="line">    Rooms rooms = <span class="keyword">new</span> Rooms(beans);</span><br><span class="line">    ValidatorUtil.printViolations(ValidatorUtil.obtainValidator().validate(rooms));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rooms[<span class="number">0</span>].&lt;list element&gt;不能为<span class="keyword">null</span>，但你的值是： <span class="keyword">null</span></span><br><span class="line">rooms[<span class="number">2</span>].finished只能为<span class="keyword">true</span>，但你的值是： <span class="keyword">false</span></span><br><span class="line">rooms[<span class="number">1</span>].name不能为<span class="keyword">null</span>，但你的值是： <span class="keyword">null</span></span><br><span class="line">rooms[<span class="number">1</span>].finished只能为<span class="keyword">true</span>，但你的值是： <span class="keyword">false</span></span><br><span class="line">rooms[<span class="number">1</span>].finished只能为<span class="keyword">true</span>，但你的值是： <span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<p>从日志中可以看出，元素的验证顺序是不保证的。</p>
<blockquote>
<p>小贴士：在HV 6.0 <strong>之前</strong>的版本中，验证容器元素时@Valid是必须，也就是必须写成这样：<code>List&lt;@Valid @NotNull Room&gt; rooms</code>才有效。在HV 6.0之后@Valid这个注解就不是必须的了</p>
</blockquote>
<h3 id="使用细节-2"><a href="#使用细节-2" class="headerlink" title="使用细节"></a>使用细节</h3><ol>
<li>若约束注解想标注在容器元素上，那么注解定义的<code>@Target</code>里必须包含<code>TYPE_USE</code>（Java8新增）这个类型<ol>
<li>BV和HV（除了Class级别）的<strong>所有注解</strong>均能标注在容器元素上</li>
</ol>
</li>
<li>BV规定了可以验证容器内元素，HV提供实现。它默认支持如下容器类型：<ol>
<li><code>java.util.Iterable</code>的实现（如List、Set）</li>
<li><code>java.util.Map</code>的实现，支持key和value</li>
<li><code>java.util.Optional/OptionalInt/OptionalDouble...</code></li>
<li>JavaFX的<code>javafx.beans.observable.ObservableValue</code></li>
<li>自定义容器类型（自定义很重要，详见下篇文章）</li>
</ol>
</li>
</ol>
<h2 id="4、类级别约束（Class）"><a href="#4、类级别约束（Class）" class="headerlink" title="4、类级别约束（Class）"></a>4、类级别约束（Class）</h2><p>类级别的约束验证是很多同学不太熟悉的一块，但它却很是重要。</p>
<p>其实Hibernate-Validator已内置提供了一部分能力，但可能还不够，很多场景需要自己动手优雅解决。为了体现此part的重要性，我决定专门撰文描述，当然还有<strong>自定义容器类型</strong>类型的校验喽，我们下文见。</p>
<h2 id="字段约束和属性约束的区别"><a href="#字段约束和属性约束的区别" class="headerlink" title="字段约束和属性约束的区别"></a>字段约束和属性约束的区别</h2><p>字段（Field）   VS   属性（Property）本身就属于一对“近义词”，很多时候口头上我们并不做区分，是因为<strong>在POJO里</strong>他俩一般都同时存在，因此大多数情况下可以对等沟通。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Room</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@AssertTrue</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> finished;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字段和属性的区别"><a href="#字段和属性的区别" class="headerlink" title="字段和属性的区别"></a>字段和属性的区别</h3><ol>
<li>字段具有存储功能：字段是类的一个成员，值在内存中真实存在；而属性它不具有存储功能，属于Java Bean规范抽象出来的一个叫法</li>
<li>字段一般用于类<strong>内部</strong>（一般是private），而属性可供外部访问（get/set一般是public）<ol>
<li>这指的是一般情况下的规律</li>
</ol>
</li>
<li>字段的本质是Field，属性的本质是Method</li>
<li>属性并<strong>不依赖于</strong>字段而存在，只是他们一般都成双成对出现<ol>
<li>如<code>getClass()</code>你可认为它有名为class的属性，但是它并没有名为class的字段</li>
</ol>
</li>
</ol>
<p>知晓了字段和属性的区别，再去理解<strong>字段约束</strong>和<strong>属性约束</strong>的差异就简单了，它俩的差异仅仅体现在<strong>待验证值</strong>访问策略上的区别：</p>
<ul>
<li>字段约束：直接反射访问字段的值 -&gt; Field#get（不会执行get方法体）</li>
<li>属性约束：调用属性get方法 -&gt; getXXX（会执行get方法体）</li>
</ul>
<blockquote>
<p>小贴士：如果你希望执行了验证就输出一句日志，又或者你的POJO被字节码增强了，那么属性约束更适合你。否则，推荐使用字段约束</p>
</blockquote>
<h1 id="✍总结"><a href="#✍总结" class="headerlink" title="✍总结"></a>✍总结</h1><p>嗯，这篇文章还不错吧，总体浏览下来行文简单，但内容还是挺干的哈，毕竟1024节嘛，不来点的干的心里有愧。</p>
<p>作为此part姊妹篇的<strong>上篇</strong>，它是每个同学都有必要掌握的使用方式。而<strong>下篇</strong>我觉得应该更为兴奋些，毕竟那里才能加分。1024，撸起袖子继续干。</p>
<h5 id="✔推荐阅读："><a href="#✔推荐阅读：" class="headerlink" title="✔推荐阅读："></a>✔推荐阅读：</h5><ul>
<li><a href="https://mp.weixin.qq.com/s/g04HMhrjbvbPn1Mb9JYa5g" target="_blank" rel="noopener">1. 不吹不擂，第一篇就能提升你对Bean Validation数据校验的认知</a></li>
<li><a href="https://mp.weixin.qq.com/s/-KeOCq2rsXCvrqD8HYHSpQ" target="_blank" rel="noopener">2. Bean Validation声明式校验方法的参数、返回值</a></li>
<li><a href="https://mp.weixin.qq.com/s/MQjXG0cg8domRtwf3ArvHw" target="_blank" rel="noopener">3. 站在使用层面，Bean Validation这些标准接口你需要烂熟于胸</a></li>
<li><a href="https://mp.weixin.qq.com/s/jzOv67ZTSx2rByj0aeUTgw" target="_blank" rel="noopener">4. Validator校验器的五大核心组件，一个都不能少</a></li>
</ul>]]></content>
      <categories>
        <category>A哥学数据校验</category>
      </categories>
      <tags>
        <tag>Bean Validation</tag>
        <tag>Hibernate Validator</tag>
        <tag>数据校验</tag>
        <tag>JSR380</tag>
      </tags>
  </entry>
  <entry>
    <title>4. Validator校验器的五大核心组件，一个都不能少</title>
    <url>/x2y/c8011cdb.html</url>
    <content><![CDATA[<blockquote>
<p>困难是弹簧，你弱它就强。本文已被 <a href="https://www.yourbatman.cn"><strong>https://www.yourbatman.cn</strong></a> 收录，里面一并有Spring技术栈、MyBatis、JVM、中间件等小而美的<strong>专栏</strong>供以免费学习。关注公众号【<strong>BAT的乌托邦</strong>】逐个击破，深入掌握，拒绝浅尝辄止。</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/2020090218282143.png#pic_center" alt=""></p>
<h1 id="✍前言"><a href="#✍前言" class="headerlink" title="✍前言"></a>✍前言</h1><p>你好，我是YourBatman。</p>
<p><a href="">上篇文章</a>介绍了校验器上下文ValidatorContext，知道它可以对校验器Validator的核心五大组件分别进行定制化设置，那么这些核心组件在校验过程中到底扮演着什么样的角色呢，本文一探究竟。</p>
<p>作为核心组件，是有必要多探究一分的。以此为基，再扩散开了解和使用其它功能模块便将如鱼得水。但是过程枯燥是真的，所以需要坚持呀。</p>
<h2 id="版本约定"><a href="#版本约定" class="headerlink" title="版本约定"></a>版本约定</h2><ul>
<li>Bean Validation版本：<code>2.0.2</code></li>
<li>Hibernate Validator版本：<code>6.1.5.Final</code></li>
</ul>
<h1 id="✍正文"><a href="#✍正文" class="headerlink" title="✍正文"></a>✍正文</h1><p>Bean Validation校验器的这五大核心组件通过ValidatorContext可以分别设置：若没设置（或为null），那就回退到使用ValidatorFactory默认的组件。</p>
<p>准备好的组件，统一通过ValidatorFactory暴露出来予以访问：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ValidatorFactory</span> <span class="keyword">extends</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="function">MessageInterpolator <span class="title">getMessageInterpolator</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">TraversableResolver <span class="title">getTraversableResolver</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">ConstraintValidatorFactory <span class="title">getConstraintValidatorFactory</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">ParameterNameProvider <span class="title">getParameterNameProvider</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="meta">@since</span> <span class="number">2.0</span></span><br><span class="line">	<span class="function">ClockProvider <span class="title">getClockProvider</span><span class="params">()</span></span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MessageInterpolator"><a href="#MessageInterpolator" class="headerlink" title="MessageInterpolator"></a>MessageInterpolator</h2><p>直译为：消息插值器。按字面不太好理解：简单的说就是对message内容进行<strong>格式化</strong>，若有占位符<code>{}</code>或者el表达式<code>${}</code>就执行替换和计算。对于语法错误应该尽量的宽容。</p>
<p>校验失败的消息模版交给它处理就成为了<strong>人能看得懂</strong>的消息格式，因此它能够处理<strong>消息的国际化</strong>：消息的key是同一个，但根据不同的Locale展示不同的消息模版。最后在替换/技术模版里面的占位符即可~</p>
<p>这是Bean Validation的标准接口，Hibernate Validator提供了实现：<br><img data-src="https://img-blog.csdnimg.cn/20200901214251873.png#pic_center" alt=""><br>Hibernate Validation它使用的是ResourceBundleMessageInterpolator来既支持参数，也支持EL表达式。内部使用了<strong>javax.el.ExpressionFactory</strong>这个API来支持EL表达式<code>${}</code>的，形如这样：<code>must be greater than ${inclusive == true ? &#39;or equal to &#39; : &#39;&#39;}{value}</code>它是能够动态计算出<code>${inclusive == true ? &#39;or equal to &#39; : &#39;&#39;}</code>这部分的值的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageInterpolator</span> </span>&#123;</span><br><span class="line">	<span class="function">String <span class="title">interpolate</span><span class="params">(String messageTemplate, Context context)</span></span>;</span><br><span class="line">	<span class="function">String <span class="title">interpolate</span><span class="params">(String messageTemplate, Context context,  Locale locale)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口方法直接了当：根据上下文Context填充消息模版messageTemplate。它的具体工作流程我用图示如下：<br><img data-src="https://img-blog.csdnimg.cn/20200902103551768.png#pic_center" alt=""><br><code>context</code>上下文里一般是拥有需要被替换的key的键值对的，如下图所示：<br><img data-src="https://img-blog.csdnimg.cn/20200902104023147.png#pic_center" alt=""><br>Hibernate对Context的实现中<strong>扩展出</strong>了如图的两个Map（非JSR标准），可以让你<strong>优先于</strong> constraintDescriptor取值，取不到再fallback到标准模式的<code>ConstraintDescriptor</code>里取值，也就是注解的属性值。具体取值代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ParameterTermResolver：</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Object <span class="title">getVariable</span><span class="params">(Context context, String parameter)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 先从hibernate扩展出来的方式取值</span></span><br><span class="line">		<span class="keyword">if</span> (context <span class="keyword">instanceof</span> HibernateMessageInterpolatorContext) &#123;</span><br><span class="line">			Object variable = ( (HibernateMessageInterpolatorContext) context ).getMessageParameters().get( parameter );</span><br><span class="line">			<span class="keyword">if</span> ( variable != <span class="keyword">null</span> ) &#123;</span><br><span class="line">				<span class="keyword">return</span> variable;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// fallback到标准模式：从注解属性里取值</span></span><br><span class="line">		<span class="keyword">return</span> context.getConstraintDescriptor().getAttributes().get( parameter );</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>大部分情况下我们只用得到注解属性里面的值，也就是错误消息里可以使用<code>{注解属性名}</code>这种方式动态获取到注解属性值，给与友好错误提示。</p>
<p>上下文里的Message参数和Expression参数如何放进去的？在后续高级使用部分，会自定义k-v替换参数，也就会使用到本部分的高级应用知识，后文见。</p>
<h2 id="TraversableResolver"><a href="#TraversableResolver" class="headerlink" title="TraversableResolver"></a>TraversableResolver</h2><p>能跨越的处理器。从字面是非常不好理解，用粗暴的语言解释为：<strong>确定某个属性是否能被ValidationProvider访问</strong>，当妹访问一个属性时都会通过它来判断一下子，提供两个判断方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TraversableResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是否是可达的</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isReachable</span><span class="params">(Object traversableObject,</span></span></span><br><span class="line"><span class="function"><span class="params">						Node traversableProperty,</span></span></span><br><span class="line"><span class="function"><span class="params">						Class&lt;?&gt; rootBeanType,</span></span></span><br><span class="line"><span class="function"><span class="params">						Path pathToTraversableObject,</span></span></span><br><span class="line"><span class="function"><span class="params">						ElementType elementType)</span></span>;</span><br><span class="line">						</span><br><span class="line">	<span class="comment">// 是否是可级联的（是否标注有@Valid注解）</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isCascadable</span><span class="params">(Object traversableObject,</span></span></span><br><span class="line"><span class="function"><span class="params">						 Node traversableProperty,</span></span></span><br><span class="line"><span class="function"><span class="params">						 Class&lt;?&gt; rootBeanType,</span></span></span><br><span class="line"><span class="function"><span class="params">						 Path pathToTraversableObject,</span></span></span><br><span class="line"><span class="function"><span class="params">						 ElementType elementType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该接口主要根据配置项来进行判断，并不负责。内部使用，调用者基本无需关心，也不见更改其默认机制，暂且略过。</p>
<h2 id="ConstraintValidatorFactory"><a href="#ConstraintValidatorFactory" class="headerlink" title="ConstraintValidatorFactory"></a>ConstraintValidatorFactory</h2><p>约束校验器工厂。ConstraintValidator约束校验器我们应该不陌生：每个约束注解都得指定一个/多个约束校验器，形如这样：<code>@Constraint(validatedBy = { xxx.class })</code>。</p>
<p>ConstraintValidatorFactory就是工厂：可以根据Class生成对象实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConstraintValidatorFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 生成实例：接口并不规定你的生成方式</span></span><br><span class="line">	&lt;T extends ConstraintValidator&lt;?, ?&gt;&gt; <span class="function">T <span class="title">getInstance</span><span class="params">(Class&lt;T&gt; key)</span></span>;</span><br><span class="line">	<span class="comment">// 释放实例。标记此实例不需要再使用，一般为空实现</span></span><br><span class="line">	<span class="comment">// 和Spring容器集成时 .destroyBean(instance)时会调用此方法</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">releaseInstance</span><span class="params">(ConstraintValidator&lt;?, ?&gt; instance)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Hibernate提供了唯一实现ConstraintValidatorFactoryImpl：使用空构造器生成实例 <code>clazz.getConstructor().newInstance();</code>。</p>
<blockquote>
<p>小贴士：接口并没规定你如何生成实例，Hibernate Validator是使用空构造这么实现的而已~</p>
</blockquote>
<h2 id="ParameterNameProvider"><a href="#ParameterNameProvider" class="headerlink" title="ParameterNameProvider"></a>ParameterNameProvider</h2><p>参数名提供器。这个组件和Spring的<code>ParameterNameDiscoverer</code>作用是一毛一样的：获取方法/构造器的<strong>参数名</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ParameterNameProvider</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function">List&lt;String&gt; <span class="title">getParameterNames</span><span class="params">(Constructor&lt;?&gt; constructor)</span></span>;</span><br><span class="line">	<span class="function">List&lt;String&gt; <span class="title">getParameterNames</span><span class="params">(Method method)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提供的实现：<br><img data-src="https://img-blog.csdnimg.cn/20200902163234854.png#pic_center" alt=""></p>
<ul>
<li><code>DefaultParameterNameProvider</code>：基于Java反射API <code>Executable#getParameters()</code>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ParameterNameProvider parameterNameProvider = <span class="keyword">new</span> DefaultParameterNameProvider();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到Person的无参构造和有参构造（@NoArgsConstructor和@AllArgsConstructor）</span></span><br><span class="line">    Arrays.stream(Person<span class="class">.<span class="keyword">class</span>.<span class="title">getConstructors</span>()).<span class="title">forEach</span>(<span class="title">c</span> -&gt; <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span>(<span class="title">parameterNameProvider</span>.<span class="title">getParameterNames</span>(<span class="title">c</span>)))</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[arg0, arg1, arg2, arg3]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<p>一样的，若你想要打印出<strong>明确的</strong>参数名，请在编译参数上加上<code>-parameters</code>参数。</p>
<ul>
<li><code>ReflectionParameterNameProvider</code>：<strong>已过期</strong>。请使用上面的default代替</li>
<li><code>ParanamerParameterNameProvider</code>：基于<code>com.thoughtworks.paranamer.Paranamer</code>实现参数名的获取，需要额外导入相应的包才行。嗯，这里我就不试了哈~</li>
</ul>
<h2 id="ClockProvider"><a href="#ClockProvider" class="headerlink" title="ClockProvider"></a>ClockProvider</h2><p>时钟提供器。这个接口很简单，就是提供一个Clock，给<code>@Past、@Future</code>等阅读判断提供参考。唯一实现为DefaultClockProvider：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultClockProvider</span> <span class="keyword">implements</span> <span class="title">ClockProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultClockProvider INSTANCE = <span class="keyword">new</span> DefaultClockProvider();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">DefaultClockProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 默认是系统时钟</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Clock <span class="title">getClock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Clock.systemDefaultZone();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认使用当前系统时钟作为参考。若你的系统有全局统一的参考标准，比如<strong>统一时钟</strong>，那就可以通过此接口实现自己的Clock时钟，毕竟每台服务器的时间并不能保证是完全一样的不是，这对于时间敏感的应用场景（如竞标）需要这么做。</p>
<p>以上就是对Validator校验器的五个核心组件的一个描述，总体上还是比较简单。其中第一个组件：MessageInterpolator插值器我认为是最为重要的，需要理解好了。对后面做自定义消息模版、国际化消息都有用。</p>
<h2 id="加餐：ValueExtractor"><a href="#加餐：ValueExtractor" class="headerlink" title="加餐：ValueExtractor"></a>加餐：ValueExtractor</h2><p>值提取器。2.0版本新增一个比较重要的组件API，作用：把值从容器内提取出来。这里的容器包括：数组、集合、Map、Optional等等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// T：待提取的容器类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ValueExtractor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从原始值originalValue提取到receiver里</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">extractValues</span><span class="params">(T originalValue, ValueReceiver receiver)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 提供一组方法，用于接收ValueExtractor提取出来的值</span></span><br><span class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">ValueReceiver</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// 接收从对象中提取的值</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">value</span><span class="params">(String nodeName, Object object)</span></span>;</span><br><span class="line">		<span class="comment">// 接收可以迭代的值，如List、Map、Iterable等</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">iterableValue</span><span class="params">(String nodeName, Object object)</span></span>;</span><br><span class="line">		<span class="comment">// 接收有索引的值，如List Array</span></span><br><span class="line">		<span class="comment">// i：索引值</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">indexedValue</span><span class="params">(String nodeName, <span class="keyword">int</span> i, Object object)</span></span>;</span><br><span class="line">		<span class="comment">// 接收键值对的值，如Map</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">keyedValue</span><span class="params">(String nodeName, Object key, Object object)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>容易想到，ValueExtractor的实现类就非常之多（所有的实现类都是内建的，非public的，这就是默认情况下支持的容器类型）：<br><img data-src="https://img-blog.csdnimg.cn/20200902165457234.png#pic_center" alt=""><br>举例两个典型实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提取List里的值   LIST_ELEMENT_NODE_NAME -&gt; &lt;list element&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListValueExtractor</span> <span class="keyword">implements</span> <span class="title">ValueExtractor</span>&lt;<span class="title">List</span>&lt;@<span class="title">ExtractedValue</span> ?&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> ValueExtractorDescriptor DESCRIPTOR = <span class="keyword">new</span> ValueExtractorDescriptor( <span class="keyword">new</span> ListValueExtractor() );</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">ListValueExtractor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extractValues</span><span class="params">(List&lt;?&gt; originalValue, ValueReceiver receiver)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; originalValue.size(); i++ ) &#123;</span><br><span class="line">			receiver.indexedValue( NodeImpl.LIST_ELEMENT_NODE_NAME, i, originalValue.get( i ) );</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取Optional里的值</span></span><br><span class="line"><span class="meta">@UnwrapByDefault</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OptionalLongValueExtractor</span> <span class="keyword">implements</span> <span class="title">ValueExtractor</span>&lt;@<span class="title">ExtractedValue</span>(<span class="title">type</span> </span>= Long<span class="class">.<span class="keyword">class</span>) <span class="title">OptionalLong</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> ValueExtractorDescriptor DESCRIPTOR = <span class="keyword">new</span> ValueExtractorDescriptor( <span class="keyword">new</span> OptionalLongValueExtractor() );</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extractValues</span><span class="params">(OptionalLong originalValue, ValueReceiver receiver)</span> </span>&#123;</span><br><span class="line">		receiver.value( <span class="keyword">null</span>, originalValue.isPresent() ? originalValue.getAsLong() : <span class="keyword">null</span> );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>校验器Validator通过它把值从容器内<strong>提取出来</strong>参与校验，从这你应该就能理解为毛从Bean Validation2.0开始就支持验证<strong>容器内</strong>的元素了吧，形如这样：<code>List&lt;@NotNull @Valid Person&gt;、Optional&lt;@NotNull @Valid Person&gt;</code>，可谓大大的方便了使用。</p>
<blockquote>
<p>若你有自定义容器，需要提取的需求，那么你可以自定义一个<code>ValueExtractor</code>实现，然后通过<code>ValidatorContext#addValueExtractor()</code>添加进去即可</p>
</blockquote>
<h1 id="✍总结"><a href="#✍总结" class="headerlink" title="✍总结"></a>✍总结</h1><p>本文主要介绍了Validator校验器的五大核心组件的作用，Bean Validation2.0提供了ValueExtractor组件来实现<strong>容器内</strong>元素的校验，大大简化了对容器元素的校验复杂性，值得点赞。</p>
<h5 id="✔推荐阅读："><a href="#✔推荐阅读：" class="headerlink" title="✔推荐阅读："></a>✔推荐阅读：</h5><ul>
<li><a href="https://mp.weixin.qq.com/s/g04HMhrjbvbPn1Mb9JYa5g" target="_blank" rel="noopener">1. 不吹不擂，第一篇就能提升你对Bean Validation数据校验的认知</a></li>
<li><a href="https://mp.weixin.qq.com/s/-KeOCq2rsXCvrqD8HYHSpQ" target="_blank" rel="noopener">2. Bean Validation声明式校验方法的参数、返回值</a></li>
<li><a href="https://mp.weixin.qq.com/s/MQjXG0cg8domRtwf3ArvHw" target="_blank" rel="noopener">3. 站在使用层面，Bean Validation这些标准接口你需要烂熟于胸</a></li>
</ul>]]></content>
      <categories>
        <category>A哥学数据校验</category>
      </categories>
      <tags>
        <tag>Bean Validation</tag>
        <tag>Hibernate Validator</tag>
        <tag>数据校验</tag>
        <tag>JSR380</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK15正式发布，划时代的ZGC同时宣布转正</title>
    <url>/x2y/52aa588e.html</url>
    <content><![CDATA[<blockquote>
<p>你发任你发，我用Java8。本文已被 <a href="https://www.yourbatman.cn"><strong>https://www.yourbatman.cn</strong></a> 收录，里面一并有Spring技术栈、MyBatis、JVM、中间件等小而美的<strong>专栏</strong>供以免费学习。关注公众号【<strong>BAT的乌托邦</strong>】逐个击破，深入掌握，拒绝浅尝辄止。</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20200916140714904.png#pic_center" alt=""></p>
<h1 id="✍前言"><a href="#✍前言" class="headerlink" title="✍前言"></a>✍前言</h1><p>2020年9月15日，JDK15正式发布，可谓如约而至。按照Java SE的发展路线图，JDK14自此停止更新。值得注意的是JDK15并非<strong>LTS</strong>版本，Oracle官方对Java SE的支持路线图如下：<br><img data-src="https://img-blog.csdnimg.cn/20200916142447336.png#pic_center" alt=""><br>JDK8的扩展支持时间超过了JDK11，Oracle你是认真的吗？开个玩笑~</p>
<p>那么自Java11之后，哪个版本才是LTS版本呢？Oracle官方并没给出具体参考路线图，但可参考OpenJDK的这张：<br><img data-src="https://img-blog.csdnimg.cn/20200916141534643.png#pic_center" alt=""><br>可以看到<strong>JDK17</strong>将是下一个LTS版本，预计发版日期是2021年9月份。当然喽这只是OpenJDK的发版线路图，并不代表Oracle官方，因此仅供参考，不过一般八九不离十。</p>
<blockquote>
<p>小贴士：OpenJDK和Oracle JDK自从JDK11后，就共享了绝大部分代码了，节奏基本保持一致。</p>
</blockquote>
<p>从JDK9之后，Oracle采用了新的发布周期：每6个月发布一个版本，每3年发布一个LTS版本。JDK14是继JDK9之后发布的第四个版本， 该版本为非LTS版本，<strong>最新的LTS版本为JDK11</strong>。因为是小鹿快跑，快速迭代，因此此处解释下这两个词：孵化器模块（Incubator）和预览特性（Preview）。</p>
<h3 id="孵化器模块（孵化版-实验版）"><a href="#孵化器模块（孵化版-实验版）" class="headerlink" title="孵化器模块（孵化版/实验版）"></a>孵化器模块（孵化版/实验版）</h3><p>尚未定稿的API/工具，主要用于从Java社区收集使用反馈，稳定性无保障，后期有较大可能性移除</p>
<h3 id="预览特性（预览版）"><a href="#预览特性（预览版）" class="headerlink" title="预览特性（预览版）"></a>预览特性（预览版）</h3><p>规格已成型，实现已确定，但还未最终定稿。这些特性还是存在被移除的可能性，但一般来说最后都会被固定下来。</p>
<h1 id="✍正文"><a href="#✍正文" class="headerlink" title="✍正文"></a>✍正文</h1><p>JDK15是Java SE平台的第15个版本，由<strong>JSR 390</strong>在Java社区进程中指定。</p>
<blockquote>
<p>OpenJDK 15是9-15发布的，Oracle同步跟上。其它厂商的对应JDK版本也会随后跟上</p>
</blockquote>
<p>该版本共提供14个新特性，通过这些JEP来表示，截图如下：<br><img data-src="https://img-blog.csdnimg.cn/20200916143406758.png#pic_center" alt=""><br>下面针对其中对开发者日常编程关系较大的特性拉出来解释，并给出对应的使用示例（其实就是JEP 378喽）。</p>
<h2 id="JDK14新特性回顾"><a href="#JDK14新特性回顾" class="headerlink" title="JDK14新特性回顾"></a>JDK14新特性回顾</h2><p>老规矩，在进行JDK15的新特性介绍之前，先回顾下JDK14的主要特性有哪些。JDK 14于2020年3月17日发布。</p>
<h3 id="一、Switch表达式"><a href="#一、Switch表达式" class="headerlink" title="一、Switch表达式"></a>一、Switch表达式</h3><p>新的Switch表达式其实早在JDK 12、13中都已存在了，但只是<strong>预览版</strong>，到了JDK 14就彻底变为稳定版了，可以放心商用。</p>
<blockquote>
<p>小贴士：预览版特性是有可能在后续版本中被移除的，但稳定版后几乎不可能被移除</p>
</blockquote>
<p>switch新的表达式有两个显著的特点：</p>
<ul>
<li>支持箭头表达式返回</li>
<li>支持yield和return返回值。</li>
</ul>
<h4 id="1、箭头表达式返回"><a href="#1、箭头表达式返回" class="headerlink" title="1、箭头表达式返回"></a>1、箭头表达式返回</h4><p>JDK14之前写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printLetterCount</span><span class="params">(DayOfWeek dayOfWeek)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (dayOfWeek) &#123;</span><br><span class="line">        <span class="keyword">case</span> MONDAY:</span><br><span class="line">        <span class="keyword">case</span> FRIDAY:</span><br><span class="line">        <span class="keyword">case</span> SUNDAY:</span><br><span class="line">            System.out.println(<span class="number">6</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TUESDAY:</span><br><span class="line">            System.out.println(<span class="number">7</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> THURSDAY:</span><br><span class="line">        <span class="keyword">case</span> SATURDAY:</span><br><span class="line">            System.out.println(<span class="number">8</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WEDNESDAY:</span><br><span class="line">            System.out.println(<span class="number">9</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要点：break可千万别忘记写，否则就是个大bug，并且还比较<strong>隐蔽</strong>，定位起来稍显困难。</p>
<p>JDK14等效的新写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printLetterCount</span><span class="params">(DayOfWeek dayOfWeek)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (dayOfWeek) &#123;</span><br><span class="line">        <span class="keyword">case</span> MONDAY, FRIDAY, SUNDAY -&gt; System.out.println(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">case</span> TUESDAY                -&gt; System.out.println(<span class="number">7</span>);</span><br><span class="line">        <span class="keyword">case</span> THURSDAY, SATURDAY     -&gt; System.out.println(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">case</span> WEDNESDAY              -&gt; System.out.println(<span class="number">9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可明显看到新写法不需要一个个break了，从<strong>语法层面</strong>规避了我们犯错的可能性。</p>
<h4 id="2、yield返回"><a href="#2、yield返回" class="headerlink" title="2、yield返回"></a>2、yield返回</h4><p>JDK14之前写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLetterCount</span><span class="params">(DayOfWeek dayOfWeek)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> letterCount;</span><br><span class="line">    <span class="keyword">switch</span> (dayOfWeek) &#123;</span><br><span class="line">        <span class="keyword">case</span> MONDAY:</span><br><span class="line">        <span class="keyword">case</span> FRIDAY:</span><br><span class="line">        <span class="keyword">case</span> SUNDAY:</span><br><span class="line">            letterCount = <span class="number">6</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TUESDAY:</span><br><span class="line">            letterCount = <span class="number">7</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> THURSDAY:</span><br><span class="line">        <span class="keyword">case</span> SATURDAY:</span><br><span class="line">            letterCount = <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WEDNESDAY:</span><br><span class="line">            letterCount = <span class="number">9</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"非法: "</span> + dayOfWeek);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> letterCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK14等效的新写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLetterCount</span><span class="params">(DayOfWeek dayOfWeek)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">switch</span> (dayOfWeek) &#123;</span><br><span class="line">        <span class="keyword">case</span> MONDAY, FRIDAY, SUNDAY -&gt; <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">case</span> TUESDAY                -&gt; <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">case</span> THURSDAY, SATURDAY     -&gt; <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">case</span> WEDNESDAY              -&gt; <span class="number">9</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用箭头操作符操作效果立竿见影。当然，你还可以使用<code>yield</code>关键字返回：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLetterCount</span><span class="params">(DayOfWeek dayOfWeek)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">switch</span> (dayOfWeek) &#123;</span><br><span class="line">        <span class="keyword">case</span> MONDAY  -&gt; <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">default</span>      -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> letterCount = dayOfWeek.toString().length();</span><br><span class="line">            yield letterCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、instanceof的模式匹配（预览）"><a href="#二、instanceof的模式匹配（预览）" class="headerlink" title="二、instanceof的模式匹配（预览）"></a>二、instanceof的模式匹配（预览）</h3><p>该功能在JDK14中处理<strong>预览版</strong>。</p>
<p>JDK14之前写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Object o = <span class="string">"hello world"</span>;</span><br><span class="line">    <span class="keyword">if</span>(o <span class="keyword">instanceof</span> String )&#123;</span><br><span class="line">        String str = String<span class="class">.<span class="keyword">class</span>.<span class="title">cast</span>(<span class="title">o</span>)</span>;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK14等效的新写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Object o = <span class="string">"hello world"</span>;</span><br><span class="line">    <span class="comment">// 屁股里直接可写个变量名，不再需要强转了</span></span><br><span class="line">    <span class="keyword">if</span>(o <span class="keyword">instanceof</span> String str)&#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">再如：</span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String s &amp;&amp; s.length() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">	s.contains(..)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你运行时有如下错误：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java: <span class="keyword">instanceof</span> 中的模式匹配 是预览功能，默认情况下禁用。</span><br><span class="line">  （请使用 --enable-preview 以启用 <span class="keyword">instanceof</span> 中的模式匹配）</span><br></pre></td></tr></table></figure>
<p>那是因为此功能是<strong>预览特性</strong>，需要你主动开启，如下：<br><img data-src="https://img-blog.csdnimg.cn/20200916180320241.png#pic_center" alt=""><br>注意：此特性在<strong>JDK15</strong>中依旧为预览版。</p>
<h3 id="三、实用的NullPointerException"><a href="#三、实用的NullPointerException" class="headerlink" title="三、实用的NullPointerException"></a>三、实用的NullPointerException</h3><p>略。</p>
<h3 id="四、Record（预览）"><a href="#四、Record（预览）" class="headerlink" title="四、Record（预览）"></a>四、Record（预览）</h3><p>Java年纪太大，语法不够新潮，有时候确实太麻烦，因此有了Record的出现：干掉那些get/set、toString、equals等方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">Person</span><span class="params">(String name,Integer age)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Person person= <span class="keyword">new</span> Person(<span class="string">"YourBatman"</span>, <span class="number">18</span>);</span><br><span class="line">    System.out.println(person);</span><br><span class="line">    System.out.println(person.name());</span><br><span class="line">    System.out.println(person.age());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，结果打印：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person[name=YourBatman, age=<span class="number">18</span>]</span><br><span class="line">YourBatman</span><br><span class="line"><span class="number">18</span></span><br></pre></td></tr></table></figure>
<p>注意：此特性在<strong>JDK15</strong>中依旧为预览版。</p>
<h3 id="五、文本块Text-Blocks（二次预览）"><a href="#五、文本块Text-Blocks（二次预览）" class="headerlink" title="五、文本块Text Blocks（二次预览）"></a>五、文本块Text Blocks（二次预览）</h3><p>这个特性可是非常好用，它属于二次预览：已在JDK 13预览过一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String html = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">          &lt;html&gt;</span></span><br><span class="line"><span class="string">              &lt;body&gt;</span></span><br><span class="line"><span class="string">                  &lt;p&gt;hello world&lt;/p&gt;</span></span><br><span class="line"><span class="string">              &lt;/body&gt;</span></span><br><span class="line"><span class="string">          &lt;/html&gt;</span></span><br><span class="line"><span class="string">          "</span><span class="string">""</span>;</span><br><span class="line">    String query = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">           SELECT * from USER</span></span><br><span class="line"><span class="string">           WHERE `id` = 1</span></span><br><span class="line"><span class="string">           ORDER BY `id`, `name`;</span></span><br><span class="line"><span class="string">           "</span><span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在JDK13中，这种是<strong>有</strong>换行的。在JDK14中，可以加上一个符号让其不让换行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String query = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">           SELECT * from USER \</span></span><br><span class="line"><span class="string">           WHERE `id` = 1 \</span></span><br><span class="line"><span class="string">           ORDER BY `id`, `name`;\</span></span><br><span class="line"><span class="string">           "</span><span class="string">""</span>;</span><br><span class="line">    System.out.println(query);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出（可以看到展示为一行了）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SELECT * from USER WHERE `id` = <span class="number">1</span> ORDER BY `id`, `name`;</span><br></pre></td></tr></table></figure>
<p>注意：此特性在<strong>JDK15</strong>中已经为正式版。</p>
<h3 id="六、删除CMS垃圾收集器"><a href="#六、删除CMS垃圾收集器" class="headerlink" title="六、删除CMS垃圾收集器"></a>六、删除CMS垃圾收集器</h3><p>这款著名的垃圾回收器从这个版本就彻底被删除了。JDK9开始使用G1作为<strong>默认</strong>的垃圾回收器（JDK11中ZGC开始崭露头角），就已经把CMS标记为过期了，在此版本正式删除。</p>
<h3 id="七、ZGC垃圾回收器（实验）"><a href="#七、ZGC垃圾回收器（实验）" class="headerlink" title="七、ZGC垃圾回收器（实验）"></a>七、ZGC垃圾回收器（实验）</h3><p>革命性的ZGC：任意堆大小（TB级别）都能保证延迟在10ms以内，是以低延迟为首要目标的一款垃圾回收器。</p>
<blockquote>
<p>在JDK14之前，ZGC只能用于Linux上，现在也可使用在windows上了</p>
</blockquote>
<p>注意：此特性在<strong>JDK15</strong>中已经为正式版（JDK11开始出现）。</p>
<hr>
<h2 id="JDK15新特性"><a href="#JDK15新特性" class="headerlink" title="JDK15新特性"></a>JDK15新特性</h2><p>有了JDK14新特性回顾做铺垫，再来了解JDK15的新特性就方便很多了。</p>
<p>特别说明：运行JDK15需要IDEA 2020.2才能支持哦（JDK14要求IDEA 2020.1），然后关于IDEA 2020.2的使用教程（新特性），请移步我公众号前面发的这篇文章：<a href="https://mp.weixin.qq.com/s/8voJSbmcBbdfNUCUBIcKcA" target="_blank" rel="noopener">IntelliJ IDEA 2020.2正式发布，诸多亮点总有几款能助你提效</a></p>
<h3 id="一、文本块Text-Blocks"><a href="#一、文本块Text-Blocks" class="headerlink" title="一、文本块Text Blocks"></a>一、文本块Text Blocks</h3><p>Text Blocks首次是在JDK 13中以预览功能出现的，然后在JDK 14中又预览了一次，终于在JDK 15中被确定下来，可放心使用了（使用示例请参考文上）。</p>
<h3 id="二、ZGC转正"><a href="#二、ZGC转正" class="headerlink" title="二、ZGC转正"></a>二、ZGC转正</h3><p>ZGC是Java 11引入的新的垃圾收集器（JDK9以后默认的垃圾回收器是G1），经过了多个实验阶段，自此终于成为正式特性。</p>
<p>ZGC是一个重新设计的并发的垃圾回收器，可以极大的提升GC的性能。支持任意堆大小而保持稳定的低延迟（10ms以内），性能非常可观。</p>
<p>打开方式：使用-XX:+UseZGC命令行参数打开，相信不久的将来它必将成为<strong>默认的</strong>垃圾回收器。</p>
<h3 id="三、Shenandoah转正"><a href="#三、Shenandoah转正" class="headerlink" title="三、Shenandoah转正"></a>三、Shenandoah转正</h3><p>怎么形容Shenandoah和ZGC的关系呢？异同点大概如下：</p>
<ul>
<li>相同点：性能几乎可认为是相同的</li>
<li><strong>不同点</strong>：ZGC是Oracle JDK的，根正苗红。而Shenandoah只存在于OpenJDK中，因此使用时需注意你的JDK版本</li>
</ul>
<p>打开方式：使用-XX:+UseShenandoahGC命令行参数打开。</p>
<h3 id="四、删除Nashorn-JavaScript-Engine"><a href="#四、删除Nashorn-JavaScript-Engine" class="headerlink" title="四、删除Nashorn JavaScript Engine"></a>四、删除Nashorn JavaScript Engine</h3><p>Nashorn是在JDK提出的脚本执行引擎，早在JDK11就已经把它标记为过期了，JDK15完全移除。</p>
<p>在JDK11中取以代之的是GraalVM。GraalVM是一个运行时平台，它支持Java和其他基于Java字节码的语言，但也支持其他语言，如JavaScript，Ruby，Python或LLVM。<strong>性能是Nashorn的2倍以上</strong>。</p>
<h3 id="五、CharSequence新增isEmpty默认方法"><a href="#五、CharSequence新增isEmpty默认方法" class="headerlink" title="五、CharSequence新增isEmpty默认方法"></a>五、CharSequence新增isEmpty默认方法</h3><p>啥都不说，源码一看便知：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@since</span> <span class="number">15</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>String实现了CharSequence接口的，这应该地球人都知道吧。</p>
<h2 id="升级建议"><a href="#升级建议" class="headerlink" title="升级建议"></a>升级建议</h2><p>自己玩玩就行，毕竟不是LTS版本。</p>
<p><strong>但是</strong>，虽然说仅限于自己玩玩就行，但不代表就没有关注的意义哈。还是那个道理，如果JDK12、13、14、15…都不关注些的话，到时候突然来个JDK17的LTS版本，接受起来就会稍显困难。</p>
<h1 id="✍总结"><a href="#✍总结" class="headerlink" title="✍总结"></a>✍总结</h1><p>JDK15整体来看新特性方面并不算很亮眼，它主要是对之前版本<strong>预览特性</strong>的功能做了确定，如文本块、ZGC等，这么一来我们就可以放心大胆的使用啦。</p>
<p>半年一次的发版速度真心学不动了，不过还好我有我的坚持：<strong>你发任你发，我用Java8。</strong></p>
<blockquote>
<p>公众号后台回复：JDK15，一键打包获取IDEA2020.2.2 + JDK15安装包（mac + windows）</p>
</blockquote>
<h5 id="✔推荐阅读："><a href="#✔推荐阅读：" class="headerlink" title="✔推荐阅读："></a>✔推荐阅读：</h5><ul>
<li><a href="https://mp.weixin.qq.com/s/8voJSbmcBbdfNUCUBIcKcA" target="_blank" rel="noopener">IntelliJ IDEA 2020.2正式发布，诸多亮点总有几款能助你提效</a></li>
<li><a href="https://mp.weixin.qq.com/s/ikI9c3XyR_czOSmsu6FLMw" target="_blank" rel="noopener">Spring Boot 2.3.0正式发布：优雅停机、配置文件位置通配符新特性一览</a></li>
<li><a href="https://mp.weixin.qq.com/s/nb4oT02dlU4pxINZw9aLLw" target="_blank" rel="noopener">搞事情？Spring Boot今天一口气发布三个版本</a></li>
</ul>]]></content>
      <categories>
        <category>A哥学Java</category>
      </categories>
      <tags>
        <tag>JDK15</tag>
        <tag>ZGC</tag>
      </tags>
  </entry>
  <entry>
    <title>3. 站在使用层面，Bean Validation这些标准接口你需要烂熟于胸</title>
    <url>/x2y/4fe71a34.html</url>
    <content><![CDATA[<blockquote>
<p>乔丹是我听过的篮球之神，科比是我亲眼见过的篮球之神。本文已被 <a href="https://www.yourbatman.cn"><strong>https://www.yourbatman.cn</strong></a> 收录，里面一并有Spring技术栈、MyBatis、JVM、中间件等小而美的<strong>专栏</strong>供以免费学习。关注公众号【<strong>BAT的乌托邦</strong>】逐个击破，深入掌握，拒绝浅尝辄止。</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20200902115418572.jpg#pic_center" alt=""></p>
<h1 id="✍前言"><a href="#✍前言" class="headerlink" title="✍前言"></a>✍前言</h1><p>你好，我是YourBatman。</p>
<p>通过前两篇文章的叙述，相信能勾起你对<strong>Bean Validation</strong>的兴趣。那么本文就站在一个使用者的角度来看，要使用Bean Validation完成校验的话我们应该掌握、熟悉哪些接口、接口方法呢？</p>
<h2 id="版本约定"><a href="#版本约定" class="headerlink" title="版本约定"></a>版本约定</h2><ul>
<li>Bean Validation版本：<code>2.0.2</code></li>
<li>Hibernate Validator版本：<code>6.1.5.Final</code></li>
</ul>
<h1 id="✍正文"><a href="#✍正文" class="headerlink" title="✍正文"></a>✍正文</h1><p>Bean Validation属于Java EE标准技术，拥有对应的JSR抽象，因此我们实际使用过程中仅需要面向标准使用即可，并不需要关心具体实现（是hibernate实现，还是apache的实现并不重要），也就是我们常说的<strong>面向接口编程</strong>。</p>
<p>Tips：为了方便下面做示例讲解，对一些简单、公用的方法抽取如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidatorUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ValidatorFactory <span class="title">obtainValidatorFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Validation.buildDefaultValidatorFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Validator <span class="title">obtainValidator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obtainValidatorFactory().getValidator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutableValidator <span class="title">obtainExecutableValidator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obtainValidator().forExecutables();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printViolations</span><span class="params">(Set&lt;ConstraintViolation&lt;T&gt;&gt; violations)</span> </span>&#123;</span><br><span class="line">        violations.stream().map(v -&gt; v.getPropertyPath() + <span class="string">" "</span> + v.getMessage() + <span class="string">": "</span> + v.getInvalidValue()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Validator"><a href="#Validator" class="headerlink" title="Validator"></a>Validator</h2><p><strong>校验器接口：校验的入口</strong>，可实现对Java Bean、某个属性、方法、构造器等完成校验。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Validator</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它是使用者接触得<strong>最多</strong>的一个API，当然也是最重要的喽。因此下面对其每个方法做出解释+使用示例。</p>
<h3 id="validate：校验Java-Bean"><a href="#validate：校验Java-Bean" class="headerlink" title="validate：校验Java Bean"></a>validate：校验Java Bean</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validate(T object, Class&lt;?&gt;... groups);</span><br></pre></td></tr></table></figure>
<p>验证Java Bean对象上的<strong>所有</strong>约束。示例如下：</p>
<p>Java Bean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ScriptAssert</span>(script = <span class="string">"_this.name==_this.fullName"</span>, lang = <span class="string">"javascript"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Length</span>(min = <span class="number">20</span>)</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String fullName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">"YourBatman"</span>);</span><br><span class="line"></span><br><span class="line">    Set&lt;ConstraintViolation&lt;User&gt;&gt; result = ValidatorUtil.obtainValidator().validate(user);</span><br><span class="line">    ValidatorUtil.printViolations(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：<code>@ScriptAssert</code>是Hibernate Validator提供的一个脚本约束注解，可以实现垮字段逻辑校验，功能非常之强大，后面详解</p>
</blockquote>
<p>运行程序，控制台输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">执行脚本表达式<span class="string">"_this.name==_this.fullName"</span>没有返回期望结果: User(name=YourBatman, fullName=<span class="keyword">null</span>)</span><br><span class="line">fullName 不能为<span class="keyword">null</span>: <span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<p>符合预期。值得注意的是：针对fullName中的@Length约束来说，null是合法的哟，所以不会有相应日志输出的</p>
<p>校验Java Bean所有约束中的所有包括：<br>1、属性上的约束<br>2、<strong>类上的约束</strong></p>
<h3 id="validateProperty：校验指定属性"><a href="#validateProperty：校验指定属性" class="headerlink" title="validateProperty：校验指定属性"></a>validateProperty：校验指定属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateProperty(T object, String propertyName, Class&lt;?&gt;... groups);</span><br></pre></td></tr></table></figure>
<p>校验某个Java Bean中的<strong>某个属性</strong>上的所有约束。示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setFullName(<span class="string">"YourBatman"</span>);</span><br><span class="line"></span><br><span class="line">    Set&lt;ConstraintViolation&lt;User&gt;&gt; result = ValidatorUtil.obtainValidator().validateProperty(user, <span class="string">"fullName"</span>);</span><br><span class="line">    ValidatorUtil.printViolations(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，控制台输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fullName 长度需要在<span class="number">20</span>和<span class="number">2147483647</span>之间: YourBatman</span><br></pre></td></tr></table></figure>
<p>符合预期。它会校验属性上的<strong>所有</strong>约束，注意只是属性上的哦，其它地方的不管。</p>
<h3 id="validateValue：校验value值"><a href="#validateValue：校验value值" class="headerlink" title="validateValue：校验value值"></a>validateValue：校验value值</h3><p>校验某个value值，是否符合指定属性上的<strong>所有约束</strong>。可理解为：若我把这个value值赋值给这个属性，是否合法？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateValue(Class&lt;T&gt; beanType,</span><br><span class="line">										  	String propertyName,</span><br><span class="line">										  	Object value,</span><br><span class="line">										  	Class&lt;?&gt;... groups);</span><br></pre></td></tr></table></figure>
<p>这个校验方法比较特殊：<strong>不用先存在对象实例</strong>，直接校验某个值是否满足某个属性的所有约束，所以它可以做事钱校验判断，还是挺好用的。示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Set&lt;ConstraintViolation&lt;User&gt;&gt; result = ValidatorUtil.obtainValidator().validateValue(User.class, "fullName", "A哥");</span><br><span class="line">    ValidatorUtil.printViolations(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fullName 长度需要在<span class="number">20</span>和<span class="number">2147483647</span>之间: A哥</span><br></pre></td></tr></table></figure>
<p>若程序改为：<code>.validateValue(User.class, &quot;fullName&quot;, &quot;YourBatman-YourBatman&quot;);</code>，再次运行程序，控制台将不再输出（字符串长度超过20，合法了嘛）。</p>
<h3 id="获取Class类型描述信息"><a href="#获取Class类型描述信息" class="headerlink" title="获取Class类型描述信息"></a>获取Class类型描述信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">BeanDescriptor <span class="title">getConstraintsForClass</span><span class="params">(Class&lt;?&gt; clazz)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个clazz可以是类or接口类型。<code>BeanDescriptor</code>：描述受约束的Java Bean和与其关联的约束。示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BeanDescriptor beanDescriptor = obtainValidator().getConstraintsForClass(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(<span class="string">"此类是否需要校验："</span> + beanDescriptor.isBeanConstrained());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取属性、方法、构造器的约束</span></span><br><span class="line">    Set&lt;PropertyDescriptor&gt; constrainedProperties = beanDescriptor.getConstrainedProperties();</span><br><span class="line">    Set&lt;MethodDescriptor&gt; constrainedMethods = beanDescriptor.getConstrainedMethods(MethodType.GETTER);</span><br><span class="line">    Set&lt;ConstructorDescriptor&gt; constrainedConstructors = beanDescriptor.getConstrainedConstructors();</span><br><span class="line">    System.out.println(<span class="string">"需要校验的属性："</span> + constrainedProperties);</span><br><span class="line">    System.out.println(<span class="string">"需要校验的方法："</span> + constrainedMethods);</span><br><span class="line">    System.out.println(<span class="string">"需要校验的构造器："</span> + constrainedConstructors);</span><br><span class="line"></span><br><span class="line">    PropertyDescriptor fullNameDesc = beanDescriptor.getConstraintsForProperty(<span class="string">"fullName"</span>);</span><br><span class="line">    System.out.println(fullNameDesc);</span><br><span class="line">    System.out.println(<span class="string">"fullName属性的约束注解个数："</span>fullNameDesc.getConstraintDescriptors().size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">此类是否需要校验：<span class="keyword">true</span></span><br><span class="line">需要校验的属性：[PropertyDescriptorImpl&#123;propertyName=name, cascaded=<span class="keyword">false</span>&#125;, PropertyDescriptorImpl&#123;propertyName=fullName, cascaded=<span class="keyword">false</span>&#125;]</span><br><span class="line">需要校验的方法：[]</span><br><span class="line">需要校验的构造器：[]</span><br><span class="line">PropertyDescriptorImpl&#123;propertyName=fullName, cascaded=<span class="keyword">false</span>&#125;</span><br><span class="line">fullName属性的约束注解个数：<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="获得Executable校验器"><a href="#获得Executable校验器" class="headerlink" title="获得Executable校验器"></a>获得Executable校验器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@since</span> <span class="number">1.1</span></span><br><span class="line"><span class="function">ExecutableValidator <span class="title">forExecutables</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>Validator这个API是1.0就提出的，它只能校验Java Bean，对于方法、构造器的参数、返回值等校验还无能为力。</p>
<p>这不1.1版本就提供了<code>ExecutableValidator</code>这个API解决这类需求，它的实例可通过调用Validator的该方法获得，非常方便。关于<code>ExecutableValidator</code>的具体使用请移步<a href="https://mp.weixin.qq.com/s/-KeOCq2rsXCvrqD8HYHSpQ" target="_blank" rel="noopener">上篇文章</a>。</p>
<h2 id="ConstraintViolation"><a href="#ConstraintViolation" class="headerlink" title="ConstraintViolation"></a>ConstraintViolation</h2><p><strong>约束违反详情</strong>。此对象保存了<strong>违反约束的上下文</strong>以及描述消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;T&gt;：root bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConstraintViolation</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的说，它保存着执行完所有约束后（不管是Java Bean约束、方法约束等等）的结果，提供了访问结果的API，比较简单：</p>
<blockquote>
<p>小贴士：只有违反的约束才会生成此对象哦。违反一个约束对应一个实例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 已经插值（interpolated）的消息</span></span><br><span class="line"><span class="function">String <span class="title">getMessage</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 未插值的消息模版（里面变量还未替换，若存在的话）</span></span><br><span class="line"><span class="function">String <span class="title">getMessageTemplate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从rootBean开始的属性路径。如：parent.fullName</span></span><br><span class="line"><span class="function">Path <span class="title">getPropertyPath</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 告诉是哪个约束没有通过（的详情）</span></span><br><span class="line">ConstraintDescriptor&lt;?&gt; getConstraintDescriptor();</span><br></pre></td></tr></table></figure>
<p>示例：略。</p>
<h2 id="ValidatorContext"><a href="#ValidatorContext" class="headerlink" title="ValidatorContext"></a>ValidatorContext</h2><p>校验器上下文，根据此上下文创建Validator实例。不同的上下文可以创建出不同实例（这里的不同指的是内部组件不同），满足各种个性化的定制需求。</p>
<p>ValidatorContext接口提供设置方法可以定制校验器的核心组件，它们就是Validator校验器的五大核心组件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ValidatorContext</span> </span>&#123;</span><br><span class="line">	<span class="function">ValidatorContext <span class="title">messageInterpolator</span><span class="params">(MessageInterpolator messageInterpolator)</span></span>;</span><br><span class="line">	<span class="function">ValidatorContext <span class="title">traversableResolver</span><span class="params">(TraversableResolver traversableResolver)</span></span>;</span><br><span class="line">	<span class="function">ValidatorContext <span class="title">constraintValidatorFactory</span><span class="params">(ConstraintValidatorFactory factory)</span></span>;</span><br><span class="line">	<span class="function">ValidatorContext <span class="title">parameterNameProvider</span><span class="params">(ParameterNameProvider parameterNameProvider)</span></span>;</span><br><span class="line">	<span class="function">ValidatorContext <span class="title">clockProvider</span><span class="params">(ClockProvider clockProvider)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// @since 2.0 值提取器。</span></span><br><span class="line">	<span class="comment">// 注意：它是add方法，属于添加哦</span></span><br><span class="line">	<span class="function">ValidatorContext <span class="title">addValueExtractor</span><span class="params">(ValueExtractor&lt;?&gt; extractor)</span></span>;</span><br><span class="line">	<span class="function">Validator <span class="title">getValidator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过这些方法设置不同的组件实现，设置好后再来个<code>getValidator()</code>就得到一个定制化的校验器，不再千篇一律喽。所以呢，首先就是要得到ValidatorContext实例，下面介绍两种方法。</p>
<h3 id="方式一：自己new"><a href="#方式一：自己new" class="headerlink" title="方式一：自己new"></a>方式一：自己new</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ValidatorFactoryImpl validatorFactory = (ValidatorFactoryImpl) ValidatorUtil.obtainValidatorFactory();</span><br><span class="line">    <span class="comment">// 使用默认的Context上下文，并且初始化一个Validator实例</span></span><br><span class="line">    <span class="comment">// 必须传入一个校验器工厂实例哦</span></span><br><span class="line">    ValidatorContext validatorContext = <span class="keyword">new</span> ValidatorContextImpl(validatorFactory)</span><br><span class="line">            .parameterNameProvider(<span class="keyword">new</span> DefaultParameterNameProvider())</span><br><span class="line">            .clockProvider(DefaultClockProvider.INSTANCE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过该上下文，生成校验器实例（注意：调用多次，生成实例是多个哟）</span></span><br><span class="line">    System.out.println(validatorContext.getValidator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，控制台输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.hibernate.validator.internal.engine.ValidatorImpl@<span class="number">1757</span>cd72</span><br></pre></td></tr></table></figure>
<p>这种是<strong>最直接</strong>的方式，想要啥就new啥嘛。不过这么使用是有缺陷的，主要体现在这两个方面：</p>
<ol>
<li>不够抽象。new的方式嘛，和抽象谈不上关系</li>
<li>强耦合了Hibernate Validator的API，如：<code>org.hibernate.validator.internal.engine.ValidatorContextImpl#ValidatorContextImpl</code></li>
</ol>
<h3 id="方式二：工厂生成"><a href="#方式二：工厂生成" class="headerlink" title="方式二：工厂生成"></a>方式二：工厂生成</h3><p>上面即使通过自己new的方式得到<code>ValidatorContext</code>实例也需要传入校验器工厂，那还不如直接使用工厂生成呢。恰好<code>ValidatorFactory</code>也提供了对应的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ValidatorContext <span class="title">usingContext</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>该方法用于得到一个ValidatorContext实例，它具有高度抽象、与底层API无关的特点，<strong>是推荐的获取方式</strong>，并且使用起来有流式编程的效果，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Validator validator = ValidatorUtil.obtainValidatorFactory().usingContext()</span><br><span class="line">            .parameterNameProvider(<span class="keyword">new</span> DefaultParameterNameProvider())</span><br><span class="line">            .clockProvider(DefaultClockProvider.INSTANCE)</span><br><span class="line">            .getValidator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，这种方式是被<strong>推荐</strong>的。</p>
<h2 id="获得Validator实例的两种姿势"><a href="#获得Validator实例的两种姿势" class="headerlink" title="获得Validator实例的两种姿势"></a>获得Validator实例的两种姿势</h2><p>在文章最后，再回头看看Validator实例获取的两种姿势。<code>Validator</code>校验器接口是完成数据校验（Java Bean校验、方法校验等）最主要API，经过了上面的讲述，下面可以来个获取方式的小总结了。</p>
<h3 id="方式一：工厂直接获取"><a href="#方式一：工厂直接获取" class="headerlink" title="方式一：工厂直接获取"></a>方式一：工厂直接获取</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Validator validator = ValidatorUtil.obtainValidatorFactory().getValidator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式十分简单、简约，对初学者十分的友好，入门简单，优点明显。各组件全部使用默认方式，省心。如果要挑缺点那肯定也是有的：无法满足个性化、定制化需求，说白了：无法自定义五大组件 + 值提取器的实现。</p>
<p>作为这么优秀的Java EE标准技术，怎么少得了对扩展的开放呢？继续方式二吧~</p>
<h3 id="方式二：从上下文获取"><a href="#方式二：从上下文获取" class="headerlink" title="方式二：从上下文获取"></a>方式二：从上下文获取</h3><p>校验器上下文也就是ValidatorContext喽，它的步骤是先得到上下文实例，然后做定制，再通过上下文实例创建出Validator校验器实例了。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Validator validator = ValidatorUtil.obtainValidatorFactory().usingContext()</span><br><span class="line">            .parameterNameProvider(<span class="keyword">new</span> DefaultParameterNameProvider())</span><br><span class="line">            .clockProvider(DefaultClockProvider.INSTANCE)</span><br><span class="line">            .getValidator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式给与了极大的定制性，你可以任意指定核心组件实现，来达到自己的要求。</p>
<p>这两种方式结合起来，不就是典型的<strong>默认 + 定制扩展</strong>的搭配麽？另外，Validator是线程安全的，一般来说一个应用只需要初始化<strong>一个</strong> Validator实例即可，所以推荐使用方式二进行初始化，对个性扩展更友好。</p>
<h1 id="✍总结"><a href="#✍总结" class="headerlink" title="✍总结"></a>✍总结</h1><p>本文站在一个使用者的角度去看如何使用Bean Validation，以及哪些<strong>标准的</strong>接口API是必须掌握了，有了这些知识点在平时绝大部分case都能应对自如了。</p>
<blockquote>
<p>规范接口/标准接口一般能解决绝大多数问题，这就是规范的边界，有些可为，有些不为</p>
</blockquote>
<p>当然喽，这些是基本功。要想深入理解Bean Validation的功能，必须深入了解Hibernate Validator实现，因为有些比较常用的case它做了很好的补充，咱们下文见。</p>
<h5 id="✔推荐阅读："><a href="#✔推荐阅读：" class="headerlink" title="✔推荐阅读："></a>✔推荐阅读：</h5><ul>
<li><a href="https://mp.weixin.qq.com/s/g04HMhrjbvbPn1Mb9JYa5g" target="_blank" rel="noopener">1. 不吹不擂，第一篇就能提升你对Bean Validation数据校验的认知</a></li>
<li><a href="https://mp.weixin.qq.com/s/-KeOCq2rsXCvrqD8HYHSpQ" target="_blank" rel="noopener">2. Bean Validation声明式校验方法的参数、返回值</a></li>
</ul>]]></content>
      <categories>
        <category>A哥学数据校验</category>
      </categories>
      <tags>
        <tag>Bean Validation</tag>
        <tag>Hibernate Validator</tag>
        <tag>数据校验</tag>
        <tag>JSR380</tag>
      </tags>
  </entry>
  <entry>
    <title>再爆安全漏洞，这次轮到Jackson了，竟由阿里云上报</title>
    <url>/x2y/56130cb.html</url>
    <content><![CDATA[<blockquote>
<p>冤冤相报何时了，得饶人处且饶人。本文已被 <a href="https://www.yourbatman.cn"><strong>https://www.yourbatman.cn</strong></a> 收录，里面一并有Spring技术栈、MyBatis、JVM、中间件等小而美的<strong>专栏</strong>供以免费学习。关注公众号【<strong>BAT的乌托邦</strong>】逐个击破，深入掌握，拒绝浅尝辄止。</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20200903160133765.png#pic_center" alt=""></p>
<h1 id="✍前言"><a href="#✍前言" class="headerlink" title="✍前言"></a>✍前言</h1><p>你好，我是YourBatman。</p>
<p>今天中午收到我司安全部发了一封邮件：Jackson存在安全漏洞。查了一下，这件事并不算很新鲜了（已经过了10天的样子），本文来聊聊吧。</p>
<p>说起来还蛮戏剧化：阿里云向Jackson官方提交了一个Jackson序列化安全漏洞。众所周知，在国内关于JSON库使用有两大主要阵营：<strong>国际著名的Jackson库</strong>和<strong>国内阿里巴巴出品的Fastjson</strong>。</p>
<p>同样的功能定位，不存在竞争想想也觉得不可能嘛。所以当我看到这个漏洞竟是阿里云上报的，就觉得这关系还蛮微妙呢，默默的腹黑了3秒钟，哈哈。</p>
<p>附：FasterXML/jackson-databind是一个简单基于Java应用库，Jackson可以轻松的将Java对象转换成json对象和xml文档，同样也可以将json、xml转换成Java对象。Jackson是美国FasterXML公司的一款适用于Java的数据处理工具。jackson-databind是其中的一个具有数据绑定功能的组件。<br><img data-src="https://img-blog.csdnimg.cn/20200903161041763.png#pic_center" alt=""></p>
<h1 id="✍正文"><a href="#✍正文" class="headerlink" title="✍正文"></a>✍正文</h1><p>熟悉A哥的小伙伴知道，自从Fastjson上次爆出重大安全漏洞之后，我彻底的投入到了Jackson的阵营，工作中也慢慢去Fastjson化。这不还专门撰写了一篇文章来说明此事：<a href="https://mp.weixin.qq.com/s/z6T9n9YvwjmDwuj-YTa0_w" target="_blank" rel="noopener">Fastjson到了说再见的时候了</a>。为了顺利完成“迁移”，我还专门写了一个，也有可能是全网唯一一个Jackson专栏，虽然很小众但就是干了~</p>
<h2 id="关于本次漏洞"><a href="#关于本次漏洞" class="headerlink" title="关于本次漏洞"></a>关于本次漏洞</h2><p>2020年8月25日，jackson-databind（官方）发布了Jackson-databind序列化漏洞的安全通告，漏洞编号为CVE-2020-24616。</p>
<h3 id="漏洞详情"><a href="#漏洞详情" class="headerlink" title="漏洞详情"></a>漏洞详情</h3><p>该漏洞源于不安全的反序列化。远程攻击者可通过精心构造的恶意载荷利用该漏洞在系统执行任意代码。</p>
<p>其实上它的底层原理是利用某些类的反序列化<strong>利用链</strong>，可以绕过 jackson-databind <strong>黑名单限制</strong>，远程攻击者通过向<strong>使用该组件</strong>的web服务接口发送特制请求包（精心构造的JSON），可以造成远程代码执行影响。</p>
<h3 id="漏洞评级"><a href="#漏洞评级" class="headerlink" title="漏洞评级"></a>漏洞评级</h3><table>
<thead>
<tr>
<th>评定方式</th>
<th>等级</th>
</tr>
</thead>
<tbody><tr>
<td>威胁等级</td>
<td>高危</td>
</tr>
<tr>
<td>影响面</td>
<td><strong>有限</strong></td>
</tr>
<tr>
<td>漏洞评分</td>
<td>75</td>
</tr>
</tbody></table>
<p>对此评级没有概念？那就来个参照物比一比嘛，我把Fastjson上次（2020-05）的安全漏洞评级给你做对比：<br>评定方式     | 等级<br>——– | —–<br>威胁等级  | 高危<br>影响面  | <strong>广泛</strong><br>漏洞评分  | 75</p>
<p>有限和广泛的的区别到底有多大，用文字不太好描述。打个比方，我觉得可类比<strong>艾滋病和新冠病毒</strong>的区别，前者对社会生态影响并不大，而后者恨不得让全球都停摆了，即使它致死率还远没有前者那么高，这就是影响范围的“力量”。</p>
<h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>jackson-databind &lt; 2.9.10.6</p>
<p>因为现在大家都基于Spring Boot开发，针对版本号我<strong>扩展一下</strong>，方便你对号入座哈：<br>Spring Boot版本    | Jackson版本<br>——– | —–<br>1.5.22.RELEASE  | 2.8.x<br>2.0.9.RELEASE  | 2.9.x<br><strong>2.1.16.RELEASE</strong>  | 2.9.10.5<br>2.2.9.RELEASE | 2.10.x<br>2.3.3.RELEASE | 2.11.x</p>
<p>Spring Boot2.1.x应该是现行主流使用版本，因此从版本号上来看，大概率都在此次漏洞的射程范围内。</p>
<h3 id="安全版本"><a href="#安全版本" class="headerlink" title="安全版本"></a>安全版本</h3><p>jackson-databind 2.9.10.6或者2.10.x及以后版本</p>
<h3 id="故事时间轴"><a href="#故事时间轴" class="headerlink" title="故事时间轴"></a>故事时间轴</h3><p>2020-08-05，<strong>阿里云安全组</strong>同学向Jackson官方上报了这个安全漏洞：<br><img data-src="https://img-blog.csdnimg.cn/2020090316440136.png#pic_center" alt=""><br>当天，官方回复预计会在8-15左右发布bug修复版本修复次问题（waht？知道问题了还得10后修复？）：<br><img data-src="https://img-blog.csdnimg.cn/20200903164802786.png#pic_center" alt=""><br>可结果是10天都不止。直到8.25这天，Jackson发布2.9.10.6版本修复了此问题，并向外界发公告公布此漏洞：<br><img data-src="https://img-blog.csdnimg.cn/20200903164918154.png#pic_center" alt=""></p>
<p>从8.5号Jackson官方知晓此漏洞，到8.25号最终发版解决此问题，<strong>整整20天</strong>，为何需要这么久？我想真像只有一个：此漏洞影响真的不大，或者说影响范围较窄。回忆下上次Fastjson出现的那个安全漏洞，24h内就给与了修复版本，并不是因为我们反映迅速，而是因为影响重大等不了…</p>
<h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><p>一股脑的全部升级到2.9.10.6或以上版本当然能规避此安全问题，但是你是否想过，你负责多少个服务？你团队、公司一共有多少个服务？你品，你细品，头大吗？</p>
<p>从官方对此次漏洞做出的反射弧时间来看，本次漏洞影响是相对较小的，因此我总结了下修复建议，倘若你<strong>同时满足</strong>如下三个条件，那么需要立马修复，否则可暂不理会：</p>
<ol>
<li>对公网提供API接口</li>
<li>Jackson版本小于2.9.10.6</li>
<li>工程内<strong>有</strong>使用（或者引入）如下4个类任意一个：<ol>
<li>br.com.anteros.dbcp.AnterosDBCPDataSource</li>
<li>com.pastdev.httpcomponents.configuration.JndiConfiguration</li>
<li>com.nqadmin.rowset.JdbcRowSetImpl</li>
<li>org.arrah.framework.rdbms.UpdatableJdbcRowsetImpl</li>
</ol>
</li>
</ol>
<p>条件3的理论支撑是我对比2.9.10.6版本release改动源码 + 我和我司安全组人员的讨论结果。修复方案也仅仅是在黑名单里新增了这4个类，截图如下：<br><img data-src="https://img-blog.csdnimg.cn/20200903170343262.png#pic_center" alt=""></p>
<h1 id="✍总结"><a href="#✍总结" class="headerlink" title="✍总结"></a>✍总结</h1><p>外行看热闹，内行看门道。千万不能说Fastjson出了个漏洞，Jackson也来一个就得出结论说打平手了，那会稍显外行。正所谓假设可以大胆，但小心求证，下结论需要谨慎。</p>
<p>总的来说，此次漏洞影响甚小，不用大惊小怪，我就继续我的Jackson之旅啦。</p>
<h5 id="✔推荐阅读："><a href="#✔推荐阅读：" class="headerlink" title="✔推荐阅读："></a>✔推荐阅读：</h5><ul>
<li><a href="https://mp.weixin.qq.com/s/z6T9n9YvwjmDwuj-YTa0_w" target="_blank" rel="noopener">Fastjson到了说再见的时候了</a></li>
<li><a href="https://mp.weixin.qq.com/s/iqSN4HUoIdX0kGcSdnD7EA" target="_blank" rel="noopener">1. 初识Jackson – 世界上最好的JSON库</a></li>
<li><a href="https://mp.weixin.qq.com/s/p6cwP2BVrC8VxkN-T3uAxg" target="_blank" rel="noopener">2. 妈呀，Jackson原来是这样写JSON的</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZHb3P06IC4xElHwJqDepxw" target="_blank" rel="noopener">3. 懂了这些，方敢在简历上说会用Jackson写JSON</a></li>
<li><a href="https://mp.weixin.qq.com/s/syAOETfEawiGItaQO35mLA" target="_blank" rel="noopener">4. JSON字符串是如何被解析的？JsonParser了解一下</a></li>
<li><a href="https://mp.weixin.qq.com/s/0ZaDYb_ueFLbvOf3FbetfQ" target="_blank" rel="noopener">5. JsonFactory工厂而已，还蛮有料，这是我没想到的</a></li>
<li><a href="https://mp.weixin.qq.com/s/VYy1QVeFLRkciymFHueb5w" target="_blank" rel="noopener">6. 二十不惑，ObjectMapper使用也不再迷惑</a></li>
<li><a href="https://mp.weixin.qq.com/s/hPRdt-6sHt4rZaW2_jhdWQ" target="_blank" rel="noopener">7. Jackson用树模型处理JSON是必备技能，不信你看</a></li>
</ul>]]></content>
      <categories>
        <category>缺省</category>
      </categories>
      <tags>
        <tag>Jackson</tag>
        <tag>Fastjson</tag>
        <tag>安全漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>2. Bean Validation声明式校验方法的参数、返回值</title>
    <url>/x2y/9088caa6.html</url>
    <content><![CDATA[<blockquote>
<p>你必须非常努力，才能干起来毫不费力。本文已被 <a href="https://www.yourbatman.cn"><strong>https://www.yourbatman.cn</strong></a> 收录，里面一并有Spring技术栈、MyBatis、JVM、中间件等小而美的<strong>专栏</strong>供以免费学习。关注公众号【<strong>BAT的乌托邦</strong>】逐个击破，深入掌握，拒绝浅尝辄止。</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20200827172656560.png#pic_center" alt=""></p>
<h1 id="✍前言"><a href="#✍前言" class="headerlink" title="✍前言"></a>✍前言</h1><p>你好，我是YourBatman。</p>
<p><a href="https://mp.weixin.qq.com/s/g04HMhrjbvbPn1Mb9JYa5g" target="_blank" rel="noopener">上篇文章</a> 完整的介绍了JSR、Bean Validation、Hibernate Validator的联系和区别，并且代码演示了如何进行基于注解的Java Bean校验，自此我们可以在Java世界进行更完美的<strong>契约式编程</strong>了，不可谓不方便。</p>
<p>但是你是否考虑过这个问题：很多时候，我们只是一些简单的独立参数（比如方法入参int age），并不需要大动干戈的弄个Java Bean装起来，比如我希望像这样写达到相应约束效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@NotNull</span> <span class="function">Person <span class="title">getOne</span><span class="params">(@NotNull @Min(<span class="number">1</span>)</span> Integer id, String name) </span>&#123; ... &#125;;</span><br></pre></td></tr></table></figure>
<p>本文就来探讨探讨如何借助Bean Validation <strong>优雅的、声明式的</strong>实现方法参数、返回值以及构造器参数、返回值的校验。</p>
<blockquote>
<p><strong>声明式</strong>除了有代码优雅、无侵入的好处之外，还有一个不可忽视的优点是：任何一个人只需要看声明就知道语义，而并不需要了解你的实现，这样使用起来也更有<strong>安全感</strong>。</p>
</blockquote>
<h2 id="版本约定"><a href="#版本约定" class="headerlink" title="版本约定"></a>版本约定</h2><ul>
<li>Bean Validation版本：<code>2.0.2</code></li>
<li>Hibernate Validator版本：<code>6.1.5.Final</code></li>
</ul>
<h1 id="✍正文"><a href="#✍正文" class="headerlink" title="✍正文"></a>✍正文</h1><p>Bean Validation 1.0版本只支持对Java Bean进行校验，到1.1版本就已支持到了对方法/构造方法的校验，使用的校验器便是1.1版本新增的<code>ExecutableValidator</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutableValidator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 方法校验：参数+返回值</span></span><br><span class="line">	&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateParameters(T object,</span><br><span class="line">													   Method method,</span><br><span class="line">													   Object[] parameterValues,</span><br><span class="line">													   Class&lt;?&gt;... groups);</span><br><span class="line">	&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateReturnValue(T object,</span><br><span class="line">														Method method,</span><br><span class="line">														Object returnValue,</span><br><span class="line">														Class&lt;?&gt;... groups);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造器校验：参数+返回值</span></span><br><span class="line">	&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateConstructorParameters(Constructor&lt;? extends T&gt; constructor,</span><br><span class="line">																  Object[] parameterValues,</span><br><span class="line">																  Class&lt;?&gt;... groups);</span><br><span class="line">	&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateConstructorReturnValue(Constructor&lt;? extends T&gt; constructor,</span><br><span class="line">																   T createdObject,</span><br><span class="line">																   Class&lt;?&gt;... groups);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实我们对<code>Executable</code>这个字眼并不陌生，向JDK的接口<code>java.lang.reflect.Executable</code>它的唯二两个实现便是Method和Constructor，刚好和这里相呼应。</p>
<p>在下面的代码示例之前，先提供两个方法用于获取校验器（使用默认配置），方便后续使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于Java Bean校验的校验器</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Validator <span class="title">obtainValidator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1、使用【默认配置】得到一个校验工厂  这个配置可以来自于provider、SPI提供</span></span><br><span class="line">    ValidatorFactory validatorFactory = Validation.buildDefaultValidatorFactory();</span><br><span class="line">    <span class="comment">// 2、得到一个校验器</span></span><br><span class="line">    <span class="keyword">return</span> validatorFactory.getValidator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于方法校验的校验器</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ExecutableValidator <span class="title">obtainExecutableValidator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obtainValidator().forExecutables();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为Validator等校验器是线程安全的，因此一般来说一个应用全局仅需一份即可，因此只需要初始化一次。</p>
<h2 id="校验Java-Bean"><a href="#校验Java-Bean" class="headerlink" title="校验Java Bean"></a>校验Java Bean</h2><p>先来回顾下对Java Bean的校验方式。书写JavaBean和校验程序（全部使用JSR标准API），声明上约束注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Min</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">public</span> Integer age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Validator validator = obtainValidator();</span><br><span class="line"></span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    person.setAge(-<span class="number">1</span>);</span><br><span class="line">    Set&lt;ConstraintViolation&lt;Person&gt;&gt; result = validator.validate(person);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出校验结果</span></span><br><span class="line">    result.stream().map(v -&gt; v.getPropertyPath() + <span class="string">" "</span> + v.getMessage() + <span class="string">": "</span> + v.getInvalidValue()).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，控制台输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">name 不能为<span class="keyword">null</span>: <span class="keyword">null</span></span><br><span class="line">age 需要在<span class="number">1</span>和<span class="number">18</span>之间: -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>这是最经典的应用了。那么问题来了，如果你的方法参数就是个Java Bean，你该如何对它进行校验呢？</p>
<blockquote>
<p>小贴士：有的人认为把约束注解标注在属性上，和标注在set方法上效果是一样的，<strong>其实不然</strong>，你有这种错觉全是因为Spring帮你处理了写东西，至于原因将在后面和Spring整合使用时展开</p>
</blockquote>
<h2 id="校验方法"><a href="#校验方法" class="headerlink" title="校验方法"></a>校验方法</h2><p>对方法的校验是本文的重点。比如我有个Service如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">getOne</span><span class="params">(Integer id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在对该方法的执行，有如下<strong>约束</strong>要求：</p>
<ol>
<li>id是<strong>必传</strong>（不为null）且<strong>最小值为1</strong>，但对name没有要求</li>
<li>返回值不能为null</li>
</ol>
<p>下面分为校验方法参数和校验返回值两部分分别展开。</p>
<h3 id="校验方法参数"><a href="#校验方法参数" class="headerlink" title="校验方法参数"></a>校验方法参数</h3><p>如上，getOne方法有两个入参，我们需要对id这个参数做校验。如果不使用Bean Validation的话代码就需要这么写校验逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">getOne</span><span class="params">(Integer id, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"id不能为null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"id必须大于等于1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这么写固然是没毛病的，但是它的弊端也非常明显：</p>
<ol>
<li>这类代码没啥营养，如果校验逻辑稍微多点就会显得臭长臭长的</li>
<li>不看你的执行逻辑，调用者无法知道你的语义。比如它并不知道id是传还是不传也行，<strong>没有形成契约</strong></li>
<li>代码侵入性强</li>
</ol>
<h4 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h4><p>既然学习了Bean Validation，关于校验方面的工作交给更专业的它当然更加优雅：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">getOne</span><span class="params">(@NotNull @Min(<span class="number">1</span>)</span> Integer id, String name) <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">    <span class="comment">// 校验逻辑</span></span><br><span class="line">    Method currMethod = <span class="keyword">this</span>.getClass().getMethod(<span class="string">"getOne"</span>, Integer<span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    Set&lt;ConstraintViolation&lt;PersonService&gt;&gt; validResult = obtainExecutableValidator().validateParameters(<span class="keyword">this</span>, currMethod, <span class="keyword">new</span> Object[]&#123;id, name&#125;);</span><br><span class="line">    <span class="keyword">if</span> (!validResult.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// ... 输出错误详情validResult</span></span><br><span class="line">        validResult.stream().map(v -&gt; v.getPropertyPath() + <span class="string">" "</span> + v.getMessage() + <span class="string">": "</span> + v.getInvalidValue()).forEach(System.out::println);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试程序就很简单喽：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> PersonService().getOne(<span class="number">0</span>, <span class="string">"A哥"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，控制台输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getOne.arg0 最小不能小于<span class="number">1</span>: <span class="number">0</span></span><br><span class="line">java.lang.IllegalArgumentException: 参数错误</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p><strong>完美</strong>的符合预期。不过，arg0是什么鬼？如果你有兴趣可以自行加上编译参数<code>-parameters</code>再运行试试，有惊喜哦~</p>
<p>通过把约束规则用注解写上去，成功的解决上面3个问题中的两个，特别是声明式约束解决问题3，这对于平时开发效率的提升是很有帮助的，因为<strong>契约已形成</strong>。</p>
<p>此外还剩一个问题：<strong>代码侵入性强</strong>。是的，相比起来校验的逻辑依旧写在了方法体里面，但一聊到如何解决代码侵入问题，相信不用我说都能想到<strong>AOP</strong>。一般来说，我们有两种AOP方式供以使用：</p>
<ol>
<li>基于Java EE的@Inteceptors实现</li>
<li>基于Spring Framework实现</li>
</ol>
<p>显然，前者是Java官方的标准技术，而后者是<strong>实际的</strong>标准，所以这个小问题先mark下来，等到后面讲到Bean Validation和Spring整合使用时再杀回来吧。</p>
<h3 id="校验方法返回值"><a href="#校验方法返回值" class="headerlink" title="校验方法返回值"></a>校验方法返回值</h3><p>相较于方法参数，返回值的校验可能很多人没听过没用过，或者接触得非常少。其实从原则上来讲，一个方法理应对其输入输出负责的：<strong>有效的输入，明确的输出</strong>，这种明确就<strong>最好</strong>是有约束的。</p>
<p>上面的<code>getOne</code>方法题目要求返回值不能为null。若通过硬编码方式校验，无非就是在<strong>return之前</strong>来个<code>if(result == null)</code>的判断嘛：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">getOne</span><span class="params">(Integer id, String name)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 模拟逻辑执行，得到一个result结果，准备返回</span></span><br><span class="line">    Person result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在结果返回之前校验</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"返回结果不能为null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，这种代码依旧有如下三个问题：</p>
<ol>
<li>这类代码没啥营养，如果校验逻辑稍微多点就会显得臭长臭长的</li>
<li>不看你的执行逻辑，调用者无法知道你的语义。比如调用者不知道返回是是否可能为null，<strong>没有形成契约</strong></li>
<li>代码侵入性强</li>
</ol>
<h4 id="优化方案-1"><a href="#优化方案-1" class="headerlink" title="优化方案"></a>优化方案</h4><p>话不多说，直接上代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@NotNull</span> <span class="function">Person <span class="title">getOne</span><span class="params">(@NotNull @Min(<span class="number">1</span>)</span> Integer id, String name) <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 模拟逻辑执行，得到一个result</span></span><br><span class="line">    Person result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在结果返回之前校验</span></span><br><span class="line">    Method currMethod = <span class="keyword">this</span>.getClass().getMethod(<span class="string">"getOne"</span>, Integer<span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    Set&lt;ConstraintViolation&lt;PersonService&gt;&gt; validResult = obtainExecutableValidator().validateReturnValue(<span class="keyword">this</span>, currMethod, result);</span><br><span class="line">    <span class="keyword">if</span> (!validResult.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// ... 输出错误详情validResult</span></span><br><span class="line">        validResult.stream().map(v -&gt; v.getPropertyPath() + <span class="string">" "</span> + v.getMessage() + <span class="string">": "</span> + v.getInvalidValue()).forEach(System.out::println);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>书写测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">    <span class="comment">// 看到没 IDEA自动帮你前面加了个notNull</span></span><br><span class="line">    <span class="meta">@NotNull</span> Person result = <span class="keyword">new</span> PersonService().getOne(<span class="number">1</span>, <span class="string">"A哥"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，控制台输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getOne.&lt;<span class="keyword">return</span> value&gt; 不能为<span class="keyword">null</span>: <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">java.lang.IllegalArgumentException: 参数错误</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>这里面有个小细节：当你调用getOne方法，让IDEA自动帮你填充返回值时，前面把校验规则也给你显示出来了，这就是<strong>契约</strong>。明明白白的，拿到这样的result你是不是可以非常放心的使用，不再战战兢兢的啥都来个<code>if(xxx !=null)</code>的判断了呢？这就是契约编程的力量，在团队内能指数级的提升编程效率，试试吧~</p>
<h2 id="校验构造方法"><a href="#校验构造方法" class="headerlink" title="校验构造方法"></a>校验构造方法</h2><p>这个，呃，(⊙o⊙)……自己动手玩玩吧，记得牢~</p>
<h2 id="加餐：Java-Bean作为入参如何校验？"><a href="#加餐：Java-Bean作为入参如何校验？" class="headerlink" title="加餐：Java Bean作为入参如何校验？"></a>加餐：Java Bean作为入参如何校验？</h2><p>如果一个Java Bean当方法参数，你该如何使用Bean Validation校验呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>约束上可以提出如下合理要求：</p>
<ol>
<li>person不能为null</li>
<li>是个合法的person模型。换句话说：person里面的那些校验规则你都得遵守喽</li>
</ol>
<p>对save方法加上校验如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(@NotNull Person person)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">    Method currMethod = <span class="keyword">this</span>.getClass().getMethod(<span class="string">"save"</span>, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    Set&lt;ConstraintViolation&lt;PersonService&gt;&gt; validResult = obtainExecutableValidator().validateParameters(<span class="keyword">this</span>, currMethod, <span class="keyword">new</span> Object[]&#123;person&#125;);</span><br><span class="line">    <span class="keyword">if</span> (!validResult.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// ... 输出错误详情validResult</span></span><br><span class="line">        validResult.stream().map(v -&gt; v.getPropertyPath() + <span class="string">" "</span> + v.getMessage() + <span class="string">": "</span> + v.getInvalidValue()).forEach(System.out::println);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>书写测试程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">    <span class="comment">// save.arg0 不能为null: null</span></span><br><span class="line">    <span class="comment">// new PersonService().save(null);</span></span><br><span class="line">    <span class="keyword">new</span> PersonService().save(<span class="keyword">new</span> Person());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，控制台<strong>没有输出</strong>，也就是说校验通过。很明显，刚new出来的Person不是一个合法的模型对象，所以可以断定<strong>没有执行</strong>模型里面的校验逻辑，怎么办呢？难道仍要自己用Validator去用API校验麽？</p>
<p>好拉，不卖关子了，这个时候就清楚大名鼎鼎的<code>@Valid</code>注解喽，标注如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(@NotNull @Valid Person person)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>再次运行测试程序，控制台输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">save.arg0.name 不能为<span class="keyword">null</span>: <span class="keyword">null</span></span><br><span class="line">save.arg0.age 不能为<span class="keyword">null</span>: <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">java.lang.IllegalArgumentException: 参数错误</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>这才是真的完美了。</p>
<blockquote>
<p>小贴士：<code>@Valid</code>注解用于验证<strong>级联</strong>的属性、方法参数或方法返回类型。比如你的属性仍旧是个Java Bean，你想深入进入校验它里面的约束，那就在此属性头上标注此注解即可。另外，通过使用@Valid可以实现<strong>递归验证</strong>，因此可以标注在List上，对它里面的每个对象都执行校验</p>
</blockquote>
<p>题外话一句：相信有小伙伴想问@Valid和Spring提供的@Validated有啥区别，我给的答案是：<strong>完全不是一回事，纯巧合而已</strong>。至于为何这么说，后面和Spring整合使用时给你讲得明明白白的。</p>
<h2 id="加餐2：注解应该写在接口上还是实现上？"><a href="#加餐2：注解应该写在接口上还是实现上？" class="headerlink" title="加餐2：注解应该写在接口上还是实现上？"></a>加餐2：注解应该写在接口上还是实现上？</h2><p>这是之前我面试时比较喜欢问的一个面试题，因为我认为这个题目的实用性还是比较大的。下面我们针对上面的save方法做个例子，提取一个接口出来，并且写上<strong>所有的</strong>约束注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(@NotNull @Valid Person person)</span> <span class="keyword">throws</span> NoSuchMethodException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类实现，一个注解都不写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonService</span> <span class="keyword">implements</span> <span class="title">PersonInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Person person)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">    	... <span class="comment">// 方法体代码同上，略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试程序也同上，为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">    <span class="comment">// save.arg0 不能为null: null</span></span><br><span class="line">    <span class="comment">// new PersonService().save(null);</span></span><br><span class="line">    <span class="keyword">new</span> PersonService().save(<span class="keyword">new</span> Person());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，控制台输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">save.arg0.name 不能为<span class="keyword">null</span>: <span class="keyword">null</span></span><br><span class="line">save.arg0.age 不能为<span class="keyword">null</span>: <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">java.lang.IllegalArgumentException: 参数错误</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>符合预期，没有任何问题。这还没完，还有很多组合方式呢，比如：约束注解全写在实现类上；实现类比接口少；比接口多……</p>
<p>限于篇幅，文章里对试验过程我就不贴出来了，直接给你扔结论吧：</p>
<ul>
<li>如果该方法<strong>是接口方法</strong>的实现，那么可存在如下两种case（这两种case的公用逻辑：约束规则以接口为准，有几个就生效几个，没有就没有）：<ul>
<li>保持和接口方法<strong>一毛一样</strong>的约束条件（极限情况：接口没约束注解，那你也不能有）</li>
<li>实现类<strong>一个都不写</strong>约束条件，结果就是接口里有约束就有，没约束就没有</li>
</ul>
</li>
<li>如果该方法不是接口方法的实现，那就很简单了：该咋地就咋地</li>
</ul>
<p>值得注意的是，在和Spring整合使用中还会涉及到一个问题：@Validated注解应该放在接口（方法）上，还是实现类（方法）上？你不妨可以自己先想想呢，答案那必然是后面分享喽。</p>
<h1 id="✍总结"><a href="#✍总结" class="headerlink" title="✍总结"></a>✍总结</h1><p>本文讲述的是Bean Validation又一经典实用场景：校验方法的参数、返回值。后面加上和Spring的AOP整合将释放出更大的能量。</p>
<p>另外，通过本文你应该能再次感受到<strong>契约编程</strong>带来的好处吧，总之：能通过契约约定解决的就不要去硬编码，人生苦短，少编码多行乐。</p>
<p>最后，提个小问题哈：你觉得是代码量越多越安全，还是越少越健壮呢？被验证过100次的代码能不要每次都还需要重复去验证吗？</p>
<h5 id="✔推荐阅读："><a href="#✔推荐阅读：" class="headerlink" title="✔推荐阅读："></a>✔推荐阅读：</h5><ul>
<li><a href="https://mp.weixin.qq.com/s/g04HMhrjbvbPn1Mb9JYa5g" target="_blank" rel="noopener">1. 不吹不擂，第一篇就能提升你对Bean Validation数据校验的认知</a></li>
</ul>]]></content>
      <categories>
        <category>A哥学数据校验</category>
      </categories>
      <tags>
        <tag>Bean Validation</tag>
        <tag>Hibernate Validator</tag>
        <tag>数据校验</tag>
        <tag>JSR380</tag>
      </tags>
  </entry>
  <entry>
    <title>1. 不吹不擂，第一篇就能提升你对Bean Validation数据校验的认知</title>
    <url>/x2y/55d56c0b.html</url>
    <content><![CDATA[<blockquote>
<p>乔丹是我听过的篮球之神，科比是我亲眼见过的篮球之神。本文已被 <a href="https://www.yourbatman.cn"><strong>https://www.yourbatman.cn</strong></a> 收录，里面一并有Spring技术栈、MyBatis、JVM、中间件等小而美的<strong>专栏</strong>供以免费学习。关注公众号【<strong>BAT的乌托邦</strong>】逐个击破，深入掌握，拒绝浅尝辄止。</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20200826163523464.png#pic_center" alt=""></p>
<h1 id="✍前言"><a href="#✍前言" class="headerlink" title="✍前言"></a>✍前言</h1><p>你好，我是YourBatman。</p>
<p>作为一个开发者，聊起数据校验（Bean Validation），不管是前、中、后端都耳熟能详，并且心里暗爽：so easy。</p>
<p>的确，对数据做校验是一个程序员的基本素质，它不难但发生在我们程序的几乎每个角落，就像下面这幅图所示：<strong>每一层都需要做校验</strong>。<br><img data-src="https://img-blog.csdnimg.cn/20200823222913467.png#pic_center" alt=""><br>如果你真的这么去写代码的话（每一层都写一份），肯定是不太合适的，良好的状态应该如下图所示：<br><img data-src="https://img-blog.csdnimg.cn/20200826173214449.png#pic_center" alt=""></p>
<p>作为一个Java开发者，在Spring大行其道的今天，很多小伙伴了解数据校验来自于<code>Spring MVC</code>场景，甚至<strong>止步于此</strong>。殊不知，Java EE早已把它抽象成了JSR标准技术，并且Spring还是借助整合它完成了自我救赎呢。</p>
<p>在我看来，按<strong>Spring的3C战略</strong>标准来比，Bean Validation数据校验这块是没有能够完成对传统Java EE的超越，自身设计存在过重、过度设计等特点。</p>
<p>本专栏命名为Bean Validation（数据校验），将先从JSR标准开始，再逐渐深入到具体实现Hibernate Validation、整合Spring使用场景等等。因此本专栏将让你将得到一份系统数据校验的知识。</p>
<h1 id="✍正文"><a href="#✍正文" class="headerlink" title="✍正文"></a>✍正文</h1><p><strong>在任何时候</strong>，当你要处理一个应用程序的业务逻辑，数据校验是你必须要考虑和面对的事情。应用程序必须通过<strong>某种手段</strong>来确保输入进来的数据从语义上来讲是正确的，比如生日必须是过去时，年龄必须&gt;0等等。<br><img data-src="https://img-blog.csdnimg.cn/20200825210148248.png#pic_center" alt=""></p>
<h2 id="为什么要有数据校验？"><a href="#为什么要有数据校验？" class="headerlink" title="为什么要有数据校验？"></a>为什么要有数据校验？</h2><p>数据校验是非常常见的工作，在日常的开发中贯穿于代码的<strong>各个层次</strong>，从上层的View层到后端业务处理层，甚至底层的数据层。</p>
<p>我们知道通常情况下程序肯定是分层的，不同的层可能由不同的人来开发或者调用。若你是一个有经验的程序员，我相信你肯定见过在<strong>不同的层了都出现了相同的校验代码</strong>，这就是某种意义上的<strong>垃圾代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">queryValueByKey</span><span class="params">(String zhName, String enName, Integer age)</span> </span>&#123;</span><br><span class="line">    checkNotNull(zhName, <span class="string">"zhName must be not null"</span>);</span><br><span class="line">    checkNotNull(enName, <span class="string">"enName must be not null"</span>);</span><br><span class="line">    checkNotNull(age, <span class="string">"age must be not null"</span>);</span><br><span class="line">    validAge(age, <span class="string">"age must be positive"</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个简单的方法入参校验至少能发现如下问题：</p>
<ol>
<li>需要写大量的代码来进行参数基本验证（这种代码多了就算垃圾代码）</li>
<li>需要通过文字注释来知道每个入参的约束是什么（否则别人咋看得懂）</li>
<li>每个程序员做参数验证的方式可能不一样，参数验证抛出的异常也不一样，导致后期几乎没法维护</li>
</ol>
<p>如上会导致代码冗余和一些管理的问题（代码量越大，管理起来维护起来就越困难），比如说语义的一致性问题。为了避免这样的情况发生，最好是将<strong>验证逻辑与相应的域模型进行绑定</strong>，这就是本文将要提供的一个新思路：<code>Bean Validation</code>。</p>
<h2 id="关于Jakarta-EE"><a href="#关于Jakarta-EE" class="headerlink" title="关于Jakarta EE"></a>关于Jakarta EE</h2><p>2018年03月， Oracle 决定把 JavaEE 移交给开源组织 <strong>Eclipse 基金会</strong>，并且不再使用Java EE这个名称。这是它的新logo：<br><img data-src="https://img-blog.csdnimg.cn/20200825212646977.png#pic_center" alt=""></p>
<p>对应的名称修改还包括：<br>旧名称     | 新名称<br>——– | —–<br><strong>Java EE</strong>  | Jakarta EE<br><strong>Glassfish</strong>  | Eclipse Glassfish<br><strong>Java Community Process (JCP)</strong>  | Eclipse EE.next Working Group (EE.next)<br><strong>Oracle development management</strong> | Eclipse Enterprise for Java (EE4J)  和 Project Management Committee (PMC)</p>
<p>JCP 将继续支持 Java SE社区。 但是，<strong>Jakarta EE规范自此将不会在JCP下开发</strong>。Jakarta EE标准大概由Eclipse Glassfish、Apache TomEE、Wildfly、Oracle WebLogic、JBoss、IBM、Websphere Liberty等组织来制定</p>
<h3 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h3><p>既然名字都改了，那接下来就是迁移喽，毕竟Java EE这个名称（javax包名）不能再用了嘛。Eclipse接手后发布的首个<code>Enterprise Java</code>将是 Jakarta EE 9，该版本将以Java EE 8作为其基准版本（最低版本要求是Java8）。</p>
<p>有个意思的现象是：Java EE 8是<code>2019.09.10</code>发布的，但实际上官方名称是<code>Jakarta EE 8</code>了。很明显该版本并非由新组织设计和制定的，不是它们的产物。但是，彼时平台已更名为Jakarta有几个月了，因此对于一些Jar你在maven市场上经常能看见两种坐标：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.validation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>validation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.validation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.validation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>虽然坐标不一样，但是<strong>内容是100%一样的</strong>（包名均还为javax.*），很明显这是更名的过度期，为后期全面更名做准备呢。</p>
<blockquote>
<p>严格来讲：只要大版本号（第一个数字）还一样，包名是<strong>不可能</strong>变化的，因此一般来说均具有向下兼容性</p>
</blockquote>
<p>既然Jakarta释放出了更名信号，那么下一步就是彻彻底底的改变喽。果不其然，这些都在<code>Jakarta EE 9</code>里得到实施。</p>
<h3 id="Jakarta-EE-9"><a href="#Jakarta-EE-9" class="headerlink" title="Jakarta EE 9"></a>Jakarta EE 9</h3><p><strong>2020.08.31</strong>，Jakarta后的第一个企业级平台Jakarta EE 9正式发布。如果说Jakarta EE 8只是冠了个名，那么这个就名正言顺了。</p>
<blockquote>
<p>小贴士：我写本文时还没到2020.08.31呢，这个时间是我在官网趴来的，因此肯定准确</p>
</blockquote>
<p>这次企业平台的升级最大的亮点是：</p>
<ol>
<li>把旗下30于种技术的<strong>大版本号</strong>全部+1（Jakarta RESTful Web Services除外）</li>
<li>包名<strong>全部</strong>去<code>javax.*</code>化，全部改为<code>jakarta.*</code></li>
<li>JavaSE基准版本要求依旧保持为Java 8（而并非Java9哦）</li>
</ol>
<p>可以发现本次升级的主要目的并着眼于功能点，仍旧是名字的替换。虽然大家对Java EE的javax有较深的情节，但旧的不去新的不来。我们以后开发过中遇到<code>jakarta.*</code>这种包名就不用再感到惊讶了，提前准备总是好的。</p>
<h2 id="Jakarta-Bean-Validation"><a href="#Jakarta-Bean-Validation" class="headerlink" title="Jakarta Bean Validation"></a>Jakarta Bean Validation</h2><p>Jakarta Bean Validation不仅仅是一个规范，它还是一个生态。</p>
<p>之前名为Java Bean Validation，2018年03月之后就得改名叫Jakarta Bean Validation<br>喽，这不官网早已这么称呼了：<br><img data-src="https://img-blog.csdnimg.cn/2020082609460389.png#pic_center" alt=""></p>
<p>Bean Validation技术隶属于Java EE规范，期间有多个JSR（<code>Java Specification Requests</code>）支持，截止到稿前共有三次JSR标准发布：<br><img data-src="https://img-blog.csdnimg.cn/20200826094826549.png#pic_center" alt=""><br>说明：JCP这个组织就是来定义Java标准的，在Java行业鼎鼎有名的公司大都是JCP的成员，可以共同参与Java标准的制定，影响着世界。包括掌门人Oracle以及Eclipse、Redhat、JetBrains等等。值得天朝人自豪的是：2018年5月17日<strong>阿里巴巴作为一员正式加入JCP组织，成为唯一一家中国公司</strong>。</p>
<p>Bean Validation是标准，它的参考实现除了有我们熟悉的<code>Hibernate Validator</code>外还有<code>Apache BVal</code>，但是后者使用非常小众，忘了它吧。实际使用中，基本可以认为Hibernate Validator是Bean Validation规范的唯一参考实现，是对等的。</p>
<blockquote>
<p>小贴士：Apache BVal胜在轻量级上，只有不到1m空间所以非常轻量，有些选手还是忠爱的（此项目还在发展中，并未停更哦，有兴趣你可以自己使用试试）</p>
</blockquote>
<h3 id="JSR303"><a href="#JSR303" class="headerlink" title="JSR303"></a>JSR303</h3><p>这个JSR提出很早了（2009年），它为 <strong>基于注解的</strong> JavaBean验证定义元数据模型和API，通过使用XML验证描述符覆盖和扩展元数据。JSR-303主要是对JavaBean进行验证，如方法级别（方法参数/返回值）、依赖注入等的验证是没有指定的。</p>
<p>作为开山之作，它规定了Java数据校验的模型和API，<strong>这就是Java Bean Validation 1.0版本</strong>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.validation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>validation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0.GA<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>该版本提供了常见的校验注解（共计13个）：<br>注解     | 支持类型 | 含义 | null值是否校验<br>——– | —– | —– | —–<br>@AssertFalse  | bool | 元素必须是false | 否<br>@AssertTrue  | bool | 元素必须是true | 否<br>@DecimalMax  | Number的子类型（浮点数除外）以及String | 元素必须是一个数字，且值必须&lt;=最大值 | 否<br>@DecimalMin  | 同上 | 元素必须是一个数字，且值必须&gt;=最大值 | 否<br>@Max  | 同上  | 同上 | 否<br>@Min | 同上  | 同上 | 否<br>@Digits  |  同上  | 元素构成是否合法（整数部分和小数部分） | 否<br>@Future  | 时间类型(包括JSR310) |  元素必须为一个<strong>将来</strong>（不包含相等）的日期(比较精确到毫秒) | 否<br>@Past |  同上 | 元素必须为一个<strong>过去</strong>（不包含相等）的日期(比较精确到毫秒) | 否<br>@NotNull | any | 元素不能为null | 是<br>@Null | any | 元素必须为null | 是<br>@Pattern | 字符串 | 元素需符合指定的正则表达式 | 否<br>@Size | String/Collection/Map/Array | 元素<strong>大小</strong>需在指定范围中 | 否</p>
<blockquote>
<p>所有注解均可标注在：方法、字段、注解、构造器、入参等几乎任何地方</p>
</blockquote>
<p>可以看到这些注解均为平时开发中比较常用的注解，但是在使用过程中有如下事项你仍旧需要注意：</p>
<ol>
<li><strong>以上所有注解对null是免疫的</strong>，也就是说如果你的值是null，是不会触发对应的校验逻辑的（也就说null是合法的），当然喽@NotNull / @Null除外</li>
<li>对于时间类型的校验注解（@Future/@Past），是开区间（不包含相等）。也就是说：如果相等就是不合法的，必须是大于或者小于<ol>
<li>这种case比较容易出现在LocalDate这种只有日期上面，必须是将来/过去日期，<strong>当天属于非法日期</strong></li>
</ol>
</li>
<li><code>@Digits</code>它并不规定数字的范围，只规定了数字的结构。如：整数位最多多少位，小数位最多多少位</li>
<li><code>@Size</code>规定了集合类型的范围（包括字符串），这个范围是<strong>闭区间</strong></li>
<li><code>@DecimalMax和@Max</code>作用基本类似，大部分情况下可通用。不同点在于：@DecimalMax设置最大值是用字符串形式表示（只要合法都行，比如科学计数法），而@Max最大值设置是个long值<ol>
<li>我个人一般用@Max即可，因为够用了~ </li>
</ol>
</li>
</ol>
<p>另外可能有人会问：为毛没看见<code>@NotEmpty、@Email、@Positive</code>等常用注解？那么带着兴趣和疑问，继续往下看吧~</p>
<h3 id="JSR349"><a href="#JSR349" class="headerlink" title="JSR349"></a>JSR349</h3><p>该规范是2013年完成的，伴随着<code>Java EE 7</code>一起发布，它就是我们比较熟悉的Bean Validation 1.1。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.validation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>validation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>相较于1.0版本，它主要的改进/优化有如下几点：</p>
<ol>
<li>标准化了Java平台的约束定义、描述、和验证</li>
<li><strong>支持方法级验证(入参或返回值的验证)</strong></li>
<li>Bean验证组件的依赖注入</li>
<li>与上下文和DI依赖注入集成</li>
<li>使用<strong>EL表达式</strong>的错误消息插值，让错误消息动态化起来（强依赖于ElManager）</li>
<li>跨参数验证。比如密码和验证密码必须相同</li>
</ol>
<blockquote>
<p>小贴士：注解个数上，相较于1.0版本并没新增~</p>
</blockquote>
<p>它的官方参考实现如下：<br><img data-src="https://img-blog.csdnimg.cn/20200826132517420.png#pic_center" alt=""><br>可以看到，Java Bean Validation 1.1版本实现对应的是Hibernate Validator 5.x(1.0版本对应的是4.x)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.4.3.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当你导入了<code>hibernate-validator</code>后，无需再显示导入<code>javax.validation</code>。hibernate-validator 5.x版本基本已停更，只有严重bug才会修复。因此若非特殊情况，不再建议你使用此版本，也就是不建议再使用Bean Validation 1.1版本，更别谈1.0版本喽。</p>
<blockquote>
<p>小贴士：Spring Boot1.5.x默认集成的还是Bean Validation 1.1哦，但到了Boot 2.x后就彻底摒弃了老旧版本</p>
</blockquote>
<h3 id="JSR380"><a href="#JSR380" class="headerlink" title="JSR380"></a>JSR380</h3><p>当下主流版本，也就是我们所说的<strong>Java Bean Validation 2.0</strong>和<strong>Jakarta Bean Validation 2.0</strong>版本。关于这两种版本的差异，官方做出了解释：<br><img data-src="https://img-blog.csdnimg.cn/20200826135712644.png#pic_center" alt=""><br>他俩除了叫法不一样、除了GAV上有变化，其它地方没任何改变。它们各自的GAV如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.validation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>validation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.validation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.validation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在应该不能再叫<code>Java EE</code>了，而应该是<code>Jakarta EE</code>。两者是一样的意思，你懂的。<code>Jakarta Bean Validation 2.0</code>是在2019年8月发布的，属于<code>Jakarta EE 8</code>的一部分。它的官方参考实现只有唯一的Hibernate validator了：<br><img data-src="https://img-blog.csdnimg.cn/20200826144936989.png#pic_center" alt=""></p>
<p>此版本具有很重要的现实意义，它主要提供如下亮点：</p>
<ol>
<li>支持通过注解参数化类型（泛型类型）参数来验证容器内的元素，如：<code>List&lt;@Positive Integer&gt; positiveNumbers</code><ol>
<li>更灵活的集合类型级联验证;例如，现在可以验证映射的值和键，如：<code>Map&lt;@Valid CustomerType, @Valid Customer&gt; customersByType</code></li>
<li>支持java.util.Optional类型，并且支持通过插入额外的值提取器来支持自定义容器类型</li>
</ol>
</li>
<li>让@Past/@Future注解支持注解在JSR310时间上</li>
<li>新增内建的注解类型（共9个）：@Email, @NotEmpty, @NotBlank, @Positive, @PositiveOrZero, @Negative, @NegativeOrZero, @PastOrPresent和@FutureOrPresent</li>
<li>所有内置的约束现在都支持<strong>重复标记</strong></li>
<li>使用反射检索参数名称，也就是入参名，详见这个API：ParameterNameProvider<ol>
<li>很明显这是需要Java 8的启动参数支持的 </li>
</ol>
</li>
<li>Bean验证XML描述符的名称空间已更改为：<ol>
<li><code>META-INF/validation.xml</code> -&gt;  <a href="http://xmlns.jcp.org/xml/ns/validation/configuration" target="_blank" rel="noopener">http://xmlns.jcp.org/xml/ns/validation/configuration</a></li>
<li><code>mapping files</code> -&gt; <a href="http://xmlns.jcp.org/xml/ns/validation/mapping" target="_blank" rel="noopener">http://xmlns.jcp.org/xml/ns/validation/mapping</a></li>
</ol>
</li>
<li>JDK最低版本要求：JDK 8</li>
</ol>
<p><code>Hibernate Validator</code>自6.x版本开始对<code>JSR 380</code>规范提供完整支持，除了支持标准外，自己也做了相应的优化，比如性能改进、减少内存占用等等，因此用最新的版本肯定是没错的，毕竟只会越来越好嘛。</p>
<h4 id="新增注解"><a href="#新增注解" class="headerlink" title="新增注解"></a>新增注解</h4><p>相较于1.x版本，2.0版本在其基础上新增了9个实用注解，总数到了22个。现对新增的9个注解解释如下：<br>注解     | 支持类型 | 含义 | null值是否校验<br>——– | —– | —– | —–<br>@Email | 字符串 |  元素必须为电子邮箱地址 | 否<br>@NotEmpty | 容器类型 | 集合的Size必须大于0  | <strong>是</strong><br>@NotBlank | 字符串 | 字符串必须包含至少一个非空白的字符  | <strong>是</strong><br>@Positive | 数字类型 | 元素必须为正数（不包括0）  | 否<br>@PositiveOrZero | 同上 | 同上（包括0）  | 否<br>@Negative | 同上 |  元素必须为负数（不包括0） | 否<br>@NegativeOrZero | 同上 | 同上（包括0）  | 否<br>@PastOrPresent | 时间类型 |  在@Past基础上包括相等  | 否<br>@FutureOrPresent | 时间类型 | 在@Futrue基础上包括相等  | 否</p>
<p>像<code>@Email、@NotEmpty、@NotBlank</code>之前是Hibernate额外提供的，2.0标准后hibernate自动<strong>退位让贤</strong>并且标注为过期了。Bean Validation 2.0的JSR规范制定负责人就职于Hibernate，所以这么做就很自然了。就是他：<br><img data-src="https://img-blog.csdnimg.cn/20200826154306198.png#pic_center" alt=""></p>
<blockquote>
<p>小贴士：除了JSR标准提供的这22个注解外，Hibernate Validator还提供了一些非常实用的注解，这在后面讲述Hibernate Validator时再解释吧</p>
</blockquote>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>导入实现包：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.5.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="校验Java-Bean"><a href="#校验Java-Bean" class="headerlink" title="校验Java Bean"></a>校验Java Bean</h4><p>书写JavaBean和校验程序（全部使用JSR标准API哦）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Min</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">public</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    person.setAge(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、使用【默认配置】得到一个校验工厂  这个配置可以来自于provider、SPI提供</span></span><br><span class="line">    ValidatorFactory validatorFactory = Validation.buildDefaultValidatorFactory();</span><br><span class="line">    <span class="comment">// 2、得到一个校验器</span></span><br><span class="line">    Validator validator = validatorFactory.getValidator();</span><br><span class="line">    <span class="comment">// 3、校验Java Bean（解析注解） 返回校验结果</span></span><br><span class="line">    Set&lt;ConstraintViolation&lt;Person&gt;&gt; result = validator.validate(person);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出校验结果</span></span><br><span class="line">    result.stream().map(v -&gt; v.getPropertyPath() + <span class="string">" "</span> + v.getMessage() + <span class="string">": "</span> + v.getInvalidValue()).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，不幸抛错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.ClassNotFoundException: javax.el.ELManager</span><br><span class="line">	at java.net.URLClassLoader.findClass(URLClassLoader.java:<span class="number">382</span>)</span><br><span class="line">	at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">418</span>)</span><br><span class="line">	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:<span class="number">355</span>)</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>上面说了，从1.1版本起就需要El管理器支持用于错误消息动态插值，因此需要自己额外导入EL的实现。</p>
<blockquote>
<p>小贴士：EL也属于Java EE标准技术，可认为是一种表达式语言工具，它并不仅仅是只能用于Web（即使你绝大部分情况下都是用于web的jsp里），可以用于任意地方（类比Spring的SpEL）</p>
</blockquote>
<p>这是EL技术规范的API：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 规范API --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.el<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.el-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Expression Language 3.0表达式语言规范发版于2013-4-29发布的，Tomcat 8、Jetty 9、GlasshFish 4都已经支持<strong>实现</strong>了EL 3.0，因此随意导入一个都可（如果你是web环境，根本就不用自己手动导入这玩意了）。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-el<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.0.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>添加好后，再次运行程序，控制台正常输出校验失败的消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">age 最小不能小于<span class="number">0</span>: -<span class="number">1</span></span><br><span class="line">name 不能为<span class="keyword">null</span>: <span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<h4 id="校验方法-校验构造器"><a href="#校验方法-校验构造器" class="headerlink" title="校验方法/校验构造器"></a>校验方法/校验构造器</h4><p>请移步下文详解。</p>
<h2 id="加餐：Bean-Validation-3-0"><a href="#加餐：Bean-Validation-3-0" class="headerlink" title="加餐：Bean Validation 3.0"></a>加餐：Bean Validation 3.0</h2><p>伴随着<code>Jakarta EE 9</code>的发布，<code>Jakarta Bean Validation 3.0</code>也正式公诸于世。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.validation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.validation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>它最大的改变，甚至可以说<strong>唯一</strong>的改变就是包名的变化：<br><img data-src="https://img-blog.csdnimg.cn/20200826171201515.png#pic_center" alt=""><br>至此不仅GAV上实现了更名，对代码执行有重要影响的包名也彻彻底底的去<code>javax.*</code>化了。因为实际的类并没有改变，因此仍旧可以认为它是JSR380的实现（虽然不再由JCP组织制定标准了）。</p>
<h3 id="参考实现"><a href="#参考实现" class="headerlink" title="参考实现"></a>参考实现</h3><p>毫无疑问，参考实现那必然是<code>Hibernate Validator</code>。它的步伐也跟得非常的紧，退出了7.x版本用于支持<code>Jakarta Bean Validation 3.0</code>。虽然是大版本号的升级，但是在新特性方面你可认为是<strong>无</strong>：<br><img data-src="https://img-blog.csdnimg.cn/20200826171630270.png#pic_center" alt=""></p>
<h1 id="✍总结"><a href="#✍总结" class="headerlink" title="✍总结"></a>✍总结</h1><p>本文着眼于讲解<strong>JSR规范、Bean Validation校验标准、官方参考实现Hibernate Validator</strong>，把它们之间的关系进行了关联，并且对差异进行了鉴别。我认为这篇文章对一般读者来说是能够刷新对数据校验的认知的。</p>
<blockquote>
<p>wow，数据校验背后还有这么广阔的天地</p>
</blockquote>
<p>数据校验是日常工组中接触非常非常频繁的一块知识点，我认为掌握它并且熟练运用于实际工作中，能起到事半功倍的效果，让代码更加的优雅，甚至还能实现别人加班你加薪呢。<strong>所以又是一个投出产出比颇高的小而美专栏在路上……</strong></p>
<p>作为本专栏的第一篇文章以JSR标准作为切入点进行讲解，是希望理论和实践能结合起来学习，毕竟理论的指导作用不可或缺。有了理论铺垫的基石，后面实践将更加流畅，正所谓着地走路更加踏实嘛。</p>
<h5 id="✔推荐阅读："><a href="#✔推荐阅读：" class="headerlink" title="✔推荐阅读："></a>✔推荐阅读：</h5><ul>
<li><a href="https://mp.weixin.qq.com/s/z6T9n9YvwjmDwuj-YTa0_w" target="_blank" rel="noopener">Fastjson到了说再见的时候了</a></li>
<li><a href="https://mp.weixin.qq.com/s/iqSN4HUoIdX0kGcSdnD7EA" target="_blank" rel="noopener">1. 初识Jackson – 世界上最好的JSON库</a></li>
<li><a href="https://mp.weixin.qq.com/s/p6cwP2BVrC8VxkN-T3uAxg" target="_blank" rel="noopener">2. 妈呀，Jackson原来是这样写JSON的</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZHb3P06IC4xElHwJqDepxw" target="_blank" rel="noopener">3. 懂了这些，方敢在简历上说会用Jackson写JSON</a></li>
<li><a href="https://mp.weixin.qq.com/s/syAOETfEawiGItaQO35mLA" target="_blank" rel="noopener">4. JSON字符串是如何被解析的？JsonParser了解一下</a></li>
<li><a href="https://mp.weixin.qq.com/s/0ZaDYb_ueFLbvOf3FbetfQ" target="_blank" rel="noopener">5. JsonFactory工厂而已，还蛮有料，这是我没想到的</a></li>
<li><a href="https://mp.weixin.qq.com/s/VYy1QVeFLRkciymFHueb5w" target="_blank" rel="noopener">6. 二十不惑，ObjectMapper使用也不再迷惑</a></li>
<li><a href="https://mp.weixin.qq.com/s/hPRdt-6sHt4rZaW2_jhdWQ" target="_blank" rel="noopener">7. Jackson用树模型处理JSON是必备技能，不信你看</a></li>
</ul>]]></content>
      <categories>
        <category>A哥学数据校验</category>
      </categories>
      <tags>
        <tag>Bean Validation</tag>
        <tag>Hibernate Validator</tag>
        <tag>数据校验</tag>
        <tag>JSR380</tag>
      </tags>
  </entry>
  <entry>
    <title>Java二进制和位运算，这一万字准能喂饱你</title>
    <url>/x2y/dbefe51a.html</url>
    <content><![CDATA[<blockquote>
<p>基础不牢，地动山摇。本文已被 <a href="https://www.yourbatman.cn"><strong>https://www.yourbatman.cn</strong></a> 收录，里面一并有Spring技术栈、MyBatis、JVM、中间件等小而美的<strong>专栏</strong>供以免费学习。关注公众号【<strong>BAT的乌托邦</strong>】逐个击破，深入掌握，拒绝浅尝辄止。</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20200821210454439.png#pic_center" alt=""></p>
<h1 id="✍前言"><a href="#✍前言" class="headerlink" title="✍前言"></a>✍前言</h1><p>你好，我是YourBatman。</p>
<p>本号正在连载Jackson深度解析系列，虽然目前还只讲到了其<strong>流式API</strong>层面，但已接触到其多个<code>Feature</code>特征。更为重要的是我在文章里赞其设计精妙，处理优雅，因此就有小伙伴私信给我问这样的话：<br><img data-src="https://img-blog.csdnimg.cn/20200726214507375.png#pic_center" alt=""><br>题外话：Jackson这个话题本就非常小众，看着阅读量我自己都快没信心写下去。但自己说过的话就是<strong>欠下的债</strong>，熬夜也得把承诺的付费内容给公开完了，毕竟还有那么几个人在白嫖不是😄。</p>
<blockquote>
<p>话外音：以后闷头做事，少吹牛逼┭┮﹏┭┮</p>
</blockquote>
<p>虽然小众，竟然还有想深入了解一波的小伙伴，确实让我为之振奋了那么三秒。既然如此那就干吧，本文就先行来认识认识<strong>Java中的位运算</strong>。位运算在Java中很少被使用，那么为何Jackson里爱不释手呢？一切就为两字：<strong>性能</strong>/<strong>高效</strong>。用计算机能直接看懂的语言跟它打交道，你说快不快，不用多想嘛。<br><img data-src="https://img-blog.csdnimg.cn/20200726235730266.png#pic_center" alt=""></p>
<h1 id="✍正文"><a href="#✍正文" class="headerlink" title="✍正文"></a>✍正文</h1><p>提及位运算，对绝大多数Java程序员来说，是一种<strong>既熟悉又陌生</strong>的感觉。熟悉是因为你在学JavaSE时肯定学过，并且在看一些开源框架（特别是JDK源码）时都能看到它的身影；陌生是因为大概率我们不会去使用它。当然，不能“流行”起来是有原因的：不好理解，不符合人类的思维，阅读性差……</p>
<blockquote>
<p>小贴士：一般来说，程序让人看懂远比被机器看懂来得更重要些</p>
</blockquote>
<p>位运算它在<code>low-level</code>的语言里使用得比较多，但是对于Java这种高级语言它就很少被提及了。虽然我们使用得很少但Java也是支持的，毕竟很多时候使用位运算才是<strong>最佳实践</strong>。</p>
<p>位运算在日常开发中使用得较少，但是巧妙的使用位运算可以大量减少运行开销，优化算法。<strong>一条语句可能对代码没什么影响，但是在高重复，大数据量的情况下将会节省很多开销。</strong></p>
<h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p>在了解什么是位运算之前，十分有必要先科普下二进制的概念。</p>
<p>二进制是计算技术中广泛采用的一种数制。二进制数据是用0和1两个数码来表示的数。它的基数为2，进位规则是<strong>逢二进一</strong>，借位规则是<strong>借一当二</strong>。因为它只使用0、1两个数字符号，非常简单方便，易于用电子方式实现。</p>
<blockquote>
<p>小贴士：半导体开代表1，关代表0，这也就是CPU计算的最底层原理😄</p>
</blockquote>
<p>先看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">求 <span class="number">1011</span>（二进制）+ <span class="number">11</span>（二进制） 的和？</span><br><span class="line">结果为：<span class="number">1110</span>（二进制）</span><br></pre></td></tr></table></figure>
<p>二进制理解起来非常非常的简单，比10进制简单多了。你可能还会思考二进制怎么和十进制互转呢？毕竟1110这个也看不到啊。有或者往深了继续思考：如何转为八进制、十六进制、三十二进制……进制转换并非本文所想讲述的内容，请有兴趣者自行度娘。</p>
<h3 id="二进制与编码"><a href="#二进制与编码" class="headerlink" title="二进制与编码"></a>二进制与编码</h3><p>这个虽然和本文内容关联系并不是很大，但顺带捞一捞，毕竟编码问题在开发中还是比较常见的。</p>
<p>计算机能识别的只有1和0，也就是二进制，1和0可以表达出全世界的<strong>所有</strong>文字和语言符号。那如何表达文字和符号呢？这就涉及到<strong>字符编码</strong>了。字符编码强行将每一个字符对应一个十进制数字（请注意字符和数字的区别，比如<code>0</code>字符对应的十进制数字是<code>48</code>），再将十进制数字转换成计算机理解的二进制，而计算机读到这些1和0之后就会显示出对应的文字或符号。</p>
<ul>
<li>一般对<strong>英文字符</strong>而言，一个字节表示一个字符，但是对汉字而言，由于低位的编码已经被使用(早期计算机并不支持中文，因此为了扩展支持，唯一的办法就是采用更多的字节数)只好向高位扩展</li>
<li>字符集编码的范围<code>utf-8&gt;gbk&gt;iso-8859-1(latin1)&gt;ascll</code>。ascll编码是美国标准信息交换码的英文缩写，包含了常用的字符，如阿拉伯数字，英文字母和一些打印符号共255个（一般说成共128个字符问题也不大）</li>
</ul>
<blockquote>
<p><code>UTF-8</code>：一套以 8 位为一个编码单位的<strong>可变长</strong>编码，会将一个码位（Unicode）编码为1到4个字节（英文1字节，大部分汉字3字节）。</p>
</blockquote>
<h2 id="Java中的二进制"><a href="#Java中的二进制" class="headerlink" title="Java中的二进制"></a>Java中的二进制</h2><p>在Java7版本以前，Java是不支持直接书写除十进制以外的其它进制字面量。但这在Java7以及以后版本就允许了：</p>
<ul>
<li>二进制：前置0b/0B</li>
<li>八进制：前置0</li>
<li>十进制：默认的，无需前置</li>
<li>十六进制：前置0x/0X</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//二进制</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0B101</span>;</span><br><span class="line">    System.out.println(i); <span class="comment">//5</span></span><br><span class="line">    System.out.println(Integer.toBinaryString(i));</span><br><span class="line">    <span class="comment">//八进制</span></span><br><span class="line">    i = <span class="number">0101</span>;</span><br><span class="line">    System.out.println(i); <span class="comment">//65</span></span><br><span class="line">    System.out.println(Integer.toBinaryString(i));</span><br><span class="line">    <span class="comment">//十进制</span></span><br><span class="line">    i = <span class="number">101</span>;</span><br><span class="line">    System.out.println(i); <span class="comment">//101</span></span><br><span class="line">    System.out.println(Integer.toBinaryString(i));</span><br><span class="line">    <span class="comment">//十六进制</span></span><br><span class="line">    i = <span class="number">0x101</span>;</span><br><span class="line">    System.out.println(i); <span class="comment">//257</span></span><br><span class="line">    System.out.println(Integer.toBinaryString(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">101</span></span><br><span class="line"><span class="number">65</span></span><br><span class="line"><span class="number">1000001</span></span><br><span class="line"><span class="number">101</span></span><br><span class="line"><span class="number">1100101</span></span><br><span class="line"><span class="number">257</span></span><br><span class="line"><span class="number">100000001</span></span><br></pre></td></tr></table></figure>
<p>说明：<code>System.out.println()</code>会先自动转为10进制后再输出的；<code>toBinaryString()</code>表示转换为二进制进行<strong>字符串</strong>进行输出。</p>
<h3 id="便捷的进制转换API"><a href="#便捷的进制转换API" class="headerlink" title="便捷的进制转换API"></a>便捷的进制转换API</h3><p>JDK自<code>1.0</code>开始便提供了非常便捷的进制转换的API，这在我们有需要时非常有用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">192</span>;</span><br><span class="line">    System.out.println(<span class="string">"---------------------------------"</span>);</span><br><span class="line">    System.out.println(<span class="string">"十进制转二进制："</span> + Integer.toBinaryString(i)); <span class="comment">//11000000</span></span><br><span class="line">    System.out.println(<span class="string">"十进制转八进制："</span> + Integer.toOctalString(i)); <span class="comment">//300</span></span><br><span class="line">    System.out.println(<span class="string">"十进制转十六进制："</span> + Integer.toHexString(i)); <span class="comment">//c0</span></span><br><span class="line">    System.out.println(<span class="string">"---------------------------------"</span>);</span><br><span class="line">    <span class="comment">// 统一利用的为Integer的valueOf()方法,parseInt方法也是ok的</span></span><br><span class="line">    System.out.println(<span class="string">"二进制转十进制："</span> + Integer.valueOf(<span class="string">"11000000"</span>, <span class="number">2</span>).toString()); <span class="comment">//192</span></span><br><span class="line">    System.out.println(<span class="string">"八进制转十进制："</span> + Integer.valueOf(<span class="string">"300"</span>, <span class="number">8</span>).toString()); <span class="comment">//192</span></span><br><span class="line">    System.out.println(<span class="string">"十六进制转十进制："</span> + Integer.valueOf(<span class="string">"c0"</span>, <span class="number">16</span>).toString()); <span class="comment">//192</span></span><br><span class="line">    System.out.println(<span class="string">"---------------------------------"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">---------------------------------</span><br><span class="line">十进制转二进制：<span class="number">11000000</span></span><br><span class="line">十进制转八进制：<span class="number">300</span></span><br><span class="line">十进制转十六进制：c0</span><br><span class="line">---------------------------------</span><br><span class="line">二进制转十进制：<span class="number">192</span></span><br><span class="line">八进制转十进制：<span class="number">192</span></span><br><span class="line">十六进制转十进制：<span class="number">192</span></span><br><span class="line">---------------------------------</span><br></pre></td></tr></table></figure>

<h3 id="如何证明Long是64位的？"><a href="#如何证明Long是64位的？" class="headerlink" title="如何证明Long是64位的？"></a>如何证明Long是64位的？</h3><p>我相信每个Javaer都知道Java中的Long类型占8个字节（64位），那如何证明呢？</p>
<blockquote>
<p>小贴士：这算是一道经典面试题，至少我提问过多次~</p>
</blockquote>
<p>有个最简单的方法：拿到Long类型的<strong>最大值</strong>，用2进制表示转换成字符串看看长度就行了，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> l = <span class="number">100L</span>;</span><br><span class="line">    <span class="comment">//如果不是最大值 前面都是0  输出的时候就不会有那么长了（所以下面使用最大/最小值示例）</span></span><br><span class="line">    System.out.println(Long.toBinaryString(l)); <span class="comment">//1100100</span></span><br><span class="line">    System.out.println(Long.toBinaryString(l).length()); <span class="comment">//7</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"---------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">    l = Long.MAX_VALUE; <span class="comment">// 2的63次方 - 1</span></span><br><span class="line">    <span class="comment">//正数长度为63为（首位为符号位，0代表正数，省略了所以长度是63）</span></span><br><span class="line">    <span class="comment">//111111111111111111111111111111111111111111111111111111111111111</span></span><br><span class="line">    System.out.println(Long.toBinaryString(l));</span><br><span class="line">    System.out.println(Long.toBinaryString(l).length()); <span class="comment">//63</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"---------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">    l = Long.MIN_VALUE; <span class="comment">// -2的63次方</span></span><br><span class="line">    <span class="comment">//负数长度为64位（首位为符号位，1代表负数）</span></span><br><span class="line">    <span class="comment">//1000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line">    System.out.println(Long.toBinaryString(l));</span><br><span class="line">    System.out.println(Long.toBinaryString(l).length()); <span class="comment">//64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1100100</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line">---------------------------------------</span><br><span class="line"><span class="number">111111111111111111111111111111111111111111111111111111111111111</span></span><br><span class="line"><span class="number">63</span></span><br><span class="line">---------------------------------------</span><br><span class="line"><span class="number">1000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="number">64</span></span><br></pre></td></tr></table></figure>
<p>说明：在计算机中，负数以其正值的<strong>补码</strong>的形式表达。因此，用同样的方法你可以自行证明Integer类型是32位的（占4个字节）。</p>
<h2 id="Java中的位运算"><a href="#Java中的位运算" class="headerlink" title="Java中的位运算"></a>Java中的位运算</h2><p><img data-src="https://img-blog.csdnimg.cn/20200726231533472.png" alt=""></p>
<p>Java语言支持的位运算符还是非常多的，列出如下：</p>
<ul>
<li><code>&amp;</code>：按位与</li>
<li><code>|</code>：按位或</li>
<li><code>~</code>：按位非</li>
<li><code>^</code>：按位异或</li>
<li><code>&lt;&lt;</code>：左位移运算符</li>
<li><code>&gt;&gt;</code>：右位移运算符</li>
<li><code>&gt;&gt;&gt;</code>：无符号右移运算符</li>
</ul>
<p>除<code>～</code>以 外，其余均为<strong>二元</strong>运算符，操作的数据只能是整型（长短均可）或者char字符型。针对这些运算类型，下面分别给出示例，一目了然。</p>
<p>既然是运算，依旧可以分为简单运算和复合运算两大类进行归类和讲解。</p>
<blockquote>
<p>小贴士：为了便于理解，字面量例子我就都使用二进制表示了，使用十进制（任何进制）不影响运算结果</p>
</blockquote>
<h3 id="简单运算"><a href="#简单运算" class="headerlink" title="简单运算"></a>简单运算</h3><p>简单运算，顾名思义，一次只用一个运算符。</p>
<h4 id="amp-：按位与"><a href="#amp-：按位与" class="headerlink" title="&amp;：按位与"></a>&amp;：按位与</h4><p>操作规则：<strong>同为1则1，否则为0</strong>。仅当两个操作数都为1时，输出结果才为1，否则为0。</p>
<blockquote>
<p>说明：1、本示例（下同）中所有的字面值使用的都是十进制表示的，理解的时候请用二进制思维去理解；2、关于负数之间的位运算本文章统一不做讲述</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0B100</span>; <span class="comment">// 十进制为4</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0B101</span>; <span class="comment">// 十进制为5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二进制结果：100</span></span><br><span class="line">    <span class="comment">// 十进制结果：4</span></span><br><span class="line">    System.out.println(<span class="string">"二进制结果："</span> + Integer.toBinaryString(i &amp; j));</span><br><span class="line">    System.out.println(<span class="string">"十进制结果："</span> + (i &amp; j));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="：按位或"><a href="#：按位或" class="headerlink" title="|：按位或"></a>|：按位或</h4><p>操作规则：<strong>同为0则0，否则为1</strong>。仅当两个操作数都为0时，输出的结果才为0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0B100</span>; <span class="comment">// 十进制为4</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0B101</span>; <span class="comment">// 十进制为5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二进制结果：101</span></span><br><span class="line">    <span class="comment">// 十进制结果：5</span></span><br><span class="line">    System.out.println(<span class="string">"二进制结果："</span> + Integer.toBinaryString(i | j));</span><br><span class="line">    System.out.println(<span class="string">"十进制结果："</span> + (i | j));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="：按位非"><a href="#：按位非" class="headerlink" title="~：按位非"></a>~：按位非</h4><p>操作规则：<strong>0为1，1为0</strong>。全部的0置为1，1置为0。</p>
<blockquote>
<p>小贴士：请务必注意是全部的，别忽略了正数前面的那些0哦~</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0B100</span>; <span class="comment">// 十进制为4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二进制结果：11111111111111111111111111111011</span></span><br><span class="line">    <span class="comment">// 十进制结果：-5</span></span><br><span class="line">    System.out.println(<span class="string">"二进制结果："</span> + Integer.toBinaryString(~i));</span><br><span class="line">    System.out.println(<span class="string">"十进制结果："</span> + (~i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="：按位异或"><a href="#：按位异或" class="headerlink" title="^：按位异或"></a>^：按位异或</h4><p>操作规则：<strong>相同为0，不同为1</strong>。操作数不同时（1遇上0，0遇上1）对应的输出结果才为1，否则为0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0B100</span>; <span class="comment">// 十进制为4</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0B101</span>; <span class="comment">// 十进制为5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二进制结果：1</span></span><br><span class="line">    <span class="comment">// 十进制结果：1</span></span><br><span class="line">    System.out.println(<span class="string">"二进制结果："</span> + Integer.toBinaryString(i ^ j));</span><br><span class="line">    System.out.println(<span class="string">"十进制结果："</span> + (i ^ j));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="lt-lt-：按位左移"><a href="#lt-lt-：按位左移" class="headerlink" title="&lt;&lt;：按位左移"></a>&lt;&lt;：按位左移</h4><p>操作规则：把一个数的<strong>全部位数</strong>都向左移动若干位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0B100</span>; <span class="comment">// 十进制为4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二进制结果：100000</span></span><br><span class="line">    <span class="comment">// 十进制结果：32 = 4 * (2的3次方)</span></span><br><span class="line">    System.out.println(<span class="string">"二进制结果："</span> + Integer.toBinaryString(i &lt;&lt; <span class="number">2</span>));</span><br><span class="line">    System.out.println(<span class="string">"十进制结果："</span> + (i &lt;&lt; <span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>左移<strong>用得非常多</strong>，理解起来并不费劲。x左移N位，效果同十进制里直接乘以2的N次方就行了，但是需要注意值<strong>溢出</strong>的情况，使用时稍加注意。</p>
<h4 id="gt-gt-：按位右移"><a href="#gt-gt-：按位右移" class="headerlink" title="&gt;&gt;：按位右移"></a>&gt;&gt;：按位右移</h4><p>操作规则：把一个数的<strong>全部位数</strong>都向右移动若干位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0B100</span>; <span class="comment">// 十进制为4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二进制结果：10</span></span><br><span class="line">    <span class="comment">// 十进制结果：2</span></span><br><span class="line">    System.out.println(<span class="string">"二进制结果："</span> + Integer.toBinaryString(i &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">"十进制结果："</span> + (i &gt;&gt; <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>负数右移：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = -<span class="number">0B100</span>; <span class="comment">// 十进制为-4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二进制结果：11111111111111111111111111111110</span></span><br><span class="line">    <span class="comment">// 十进制结果：-2</span></span><br><span class="line">    System.out.println(<span class="string">"二进制结果："</span> + Integer.toBinaryString(i &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">"十进制结果："</span> + (i &gt;&gt; <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>右移用得也比较多，也比较理解：操作其实就是把二进制数<strong>右边的N位</strong>直接<strong>砍掉</strong>，然后<code>正数右移高位补0，负数右移高位补1</code>。</p>
<h4 id="gt-gt-gt-：无符号右移"><a href="#gt-gt-gt-：无符号右移" class="headerlink" title="&gt;&gt;&gt;：无符号右移"></a>&gt;&gt;&gt;：无符号右移</h4><blockquote>
<p>注意：没有无符号左移，并没有<code>&lt;&lt;&lt;</code>这个符号的</p>
</blockquote>
<p>它和<code>&gt;&gt;</code>有符号右移的区别是：无论是正数还是负数，<strong>高位通通补0</strong>。所以说对于正数而言，没有区别；那么看看对于负数的表现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = -<span class="number">0B100</span>; <span class="comment">// 十进制为-4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二进制结果：11111111111111111111111111111110（&gt;&gt;的结果）</span></span><br><span class="line">	<span class="comment">// 二进制结果：1111111111111111111111111111110（&gt;&gt;&gt;的结果）</span></span><br><span class="line">    <span class="comment">// 十进制结果：2147483646</span></span><br><span class="line">    System.out.println(<span class="string">"二进制结果："</span> + Integer.toBinaryString(i &gt;&gt;&gt; <span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">"十进制结果："</span> + (i &gt;&gt;&gt; <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我特意把&gt;&gt;的结果放上面了，方便你对比。因为高位补的是0，所以就没有显示啦，但是你心里应该清楚是怎么回事。</p>
<h3 id="复合运算"><a href="#复合运算" class="headerlink" title="复合运算"></a>复合运算</h3><p>广义上的复合运算指的是多个运算<strong>嵌套起来</strong>，通常这些运算都是同种类型的。这里指的复合运算指的就是和=号一起来使用，类似于<code>+= -=</code>。本来这属于基础常识不用做单独解释，但谁让A哥管生管养，管杀管埋呢😄。</p>
<blockquote>
<p>混合运算：指同一个算式里包含了bai多种运算符，如加减乘除乘方开du方等。</p>
</blockquote>
<p>以&amp;与运算为例，其它类同：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0B110</span>; <span class="comment">// 十进制为6</span></span><br><span class="line">    i &amp;= <span class="number">0B11</span>; <span class="comment">// 效果同：i = i &amp; 3</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 二进制结果：10</span></span><br><span class="line">	<span class="comment">// 十进制结果：2</span></span><br><span class="line">    System.out.println(<span class="string">"二进制结果："</span> + Integer.toBinaryString(i));</span><br><span class="line">    System.out.println(<span class="string">"十进制结果："</span> + (i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复习一下<code>&amp;</code>的运算规则是：<strong>同为1则1，否则为0</strong>。</p>
<h2 id="位运算使用场景示例"><a href="#位运算使用场景示例" class="headerlink" title="位运算使用场景示例"></a>位运算使用场景示例</h2><p>位运算除了<strong>高效</strong>的特点，还有一个特点在应用场景下不容忽视：<strong>计算的可逆性</strong>。通过这个特点我们可以用来达到<strong>隐蔽数据</strong>的效果，并且还保证了效率。</p>
<p>在JDK的原码中。有很多初始值都是通过位运算计算的。最典型的如HashMap：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap:</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure>
<p>位运算有很多优良特性，能够在<strong>线性增长</strong>的数据中起到作用。且对于一些运算，位运算是最直接、最简便的方法。下面我安排一些具体示例（一般都是面试题），感受一把。</p>
<h3 id="判断两个数字符号是否相同"><a href="#判断两个数字符号是否相同" class="headerlink" title="判断两个数字符号是否相同"></a>判断两个数字符号是否相同</h3><p>同为正数or同为负数都表示相同，否则为不同。像这种小小case用十进制加上<code>&gt;/&lt;</code>比较符当然可以做，但用位运算符处理来得更加直接（效率最高）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> j = -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(((i &gt;&gt; <span class="number">31</span>) ^ (j &gt;&gt; <span class="number">31</span>)) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    j = <span class="number">10</span>;</span><br><span class="line">    System.out.println(((i &gt;&gt; <span class="number">31</span>) ^ (j &gt;&gt; <span class="number">31</span>)) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p>int类型共32bit，右移31位那么就只剩下1个符号位了（因为是<strong>带符号右移动</strong>，所以正数剩0负数剩1），再对两个符号位做<code>^</code>异或操作结果为0就表明二者一致。</p>
<blockquote>
<p>复习一下<code>^</code>异或操作规则：<strong>相同为0，不同为1</strong>。</p>
</blockquote>
<h3 id="判断一个数的奇偶性"><a href="#判断一个数的奇偶性" class="headerlink" title="判断一个数的奇偶性"></a>判断一个数的奇偶性</h3><p>在十进制数中可以通过和2取余来做，对于位运算有一个更为<strong>高效</strong>的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(isEvenNum(<span class="number">1</span>)); <span class="comment">//false</span></span><br><span class="line">    System.out.println(isEvenNum(<span class="number">2</span>)); <span class="comment">//true</span></span><br><span class="line">    System.out.println(isEvenNum(<span class="number">3</span>)); <span class="comment">//false</span></span><br><span class="line">    System.out.println(isEvenNum(<span class="number">4</span>)); <span class="comment">//true</span></span><br><span class="line">    System.out.println(isEvenNum(<span class="number">5</span>)); <span class="comment">//false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否为偶数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEvenNum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &amp; <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为何<code>&amp;1</code>能判断基偶性？因为在二进制下<strong>偶数的末位肯定是0，奇数的最低位肯定是1</strong>。<br>而二进制的1它的前31位均为0，所以在和其它数字的前31位<strong>与运算</strong>后肯定所有位数都是0（无论是1&amp;0还是0&amp;0结果都是0），那么唯一区别就是看最低位和1进行与运算的结果喽：结果为1表示奇数，反则结果为0就表示偶数。</p>
<h3 id="交换两个数的值（不借助第三方变量）"><a href="#交换两个数的值（不借助第三方变量）" class="headerlink" title="交换两个数的值（不借助第三方变量）"></a>交换两个数的值（不借助第三方变量）</h3><p>这是一个很古老的面试题了，交换A和B的值。本题如果没有括号里那几个字，是一道大家都会的题目，可以这么来解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line">    System.out.println(a + <span class="string">"-------"</span> + b);</span><br><span class="line">    a = a + b;</span><br><span class="line">    b = a - b;</span><br><span class="line">    a = a - b;</span><br><span class="line">    System.out.println(a + <span class="string">"-------"</span> + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出（成功交换）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>-------<span class="number">5</span></span><br><span class="line"><span class="number">5</span>-------<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>使用这种方式最大的好处是：容易理解。最大的坏处是：<strong>a+b,可能会超出int型的最大范围，造成精度丢失导致错误，造成非常隐蔽的bug</strong>。所以若你这样运用在生产环境的话，是有比较大的安全隐患的。</p>
<blockquote>
<p>小贴士：如果你们评估数字<strong>绝无可能</strong>超过最大值，这种做法尚可。当然如果你是字符串类型，请当我没说</p>
</blockquote>
<p>因为这种方式既引入了第三方变量，又存在重大安全隐患。所以本文介绍一种安全的替代方式，借助位运算的<strong>可逆性</strong>来完成操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里使用最大值演示，以证明这样方式是不会溢出的</span></span><br><span class="line">    <span class="keyword">int</span> a = Integer.MAX_VALUE, b = Integer.MAX_VALUE - <span class="number">10</span>;</span><br><span class="line">    System.out.println(a + <span class="string">"-------"</span> + b);</span><br><span class="line">    a = a ^ b;</span><br><span class="line">    b = a ^ b;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">    System.out.println(a + <span class="string">"-------"</span> + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出（成功完成交换）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2147483647</span>-------<span class="number">2147483637</span></span><br><span class="line"><span class="number">2147483637</span>-------<span class="number">2147483647</span></span><br></pre></td></tr></table></figure>
<p>由于全文都没有对a/b做加法运算，因此不能出现溢出现象，所以是安全的。这种做法的核心原理依据是：<strong>位运算的可逆性</strong>，使用异或来达成目的。</p>
<h3 id="位运算用在数据库字段上（重要）"><a href="#位运算用在数据库字段上（重要）" class="headerlink" title="位运算用在数据库字段上（重要）"></a>位运算用在数据库字段上（重要）</h3><p>这个使用case是<strong>极具</strong>实际应用意义的，因为在生产上我以用过多次，感觉不是一般的好。</p>
<p>业务系统中数据库设计的尴尬现象：通常我们的数据表中可能会包含各种状态属性， 例如 blog表中，我们需要有字段表示其是否公开，是否有设置密码，是否被管理员封锁，是否被置顶等等。 <strong>也会遇到在后期运维中，策划要求增加新的功能而造成你需要增加新的字段</strong>，这样会造成后期的维护困难，字段过多，索引增大的情况， 这时使用位运算就可以<strong>巧妙的</strong>解决。</p>
<p>举个例子：我们在网站上进行认证授权的时候，一般支持多种授权方式，比如：</p>
<ul>
<li>个人认证  0001 -&gt; 1</li>
<li>邮箱认证  0010 -&gt; 2</li>
<li>微信认证  0100 -&gt; 4</li>
<li>超管认证  1000 -&gt; 8</li>
</ul>
<p>这样我们就可以使用<code>1111</code>这四位来表达各自位置的认证与否。要查询通过微信认证的条件语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> xxx <span class="keyword">where</span> <span class="keyword">status</span> = <span class="keyword">status</span> &amp; <span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<p>要查询既通过了个人认证，又通过了微信认证的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> xxx <span class="keyword">where</span> <span class="keyword">status</span> = <span class="keyword">status</span> &amp; <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>当然你也可能有排序需求，形如这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> xxx <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">status</span> &amp; <span class="number">1</span> <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>

<p>这种case和每个人都熟悉的Linux权限控制一样，它就是使用位运算来控制的：权限分为 r 读, w 写, x 执行,其中它们的权值分别为4，2，1，你可以随意组合授权。比如 <code>chomd 7</code>，即7=4+2+1表明这个用户具有<strong>rwx</strong>权限，</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li>需要你的DB存储支持位运算，比如MySql是支持的</li>
<li>请确保你的字段类型不是char字符类型，而应该是<strong>数字类型</strong></li>
<li>这种方式它会导致<strong>索引失效</strong>，但是一般情况下状态值是不需要索引的</li>
<li>具体业务具体分析，别一味地为了show而用，若用错了容易遭对有喷的</li>
</ol>
<h3 id="流水号生成器（订单号生成器）"><a href="#流水号生成器（订单号生成器）" class="headerlink" title="流水号生成器（订单号生成器）"></a>流水号生成器（订单号生成器）</h3><p>生成订单流水号，当然这其实这并不是一个很难的功能，最直接的方式就是日期+主机Id+随机字符串来拼接一个流水号，甚至看到非常多的地方直接使用UUID，当然这是非常不推荐的。</p>
<blockquote>
<p>UUID是字符串，太长，无序，不能承载有效的信息从而不能给定位问题提供有效帮助，因此一般属于备选方案</p>
</blockquote>
<p>今天学了位运算，有个我认为比较优雅方式来实现。什么叫优雅：可以参考淘宝、京东的订单号，<strong>看似有规律，实则没规律</strong>：</p>
<ul>
<li>不想把相关信息直接暴露出去。</li>
<li>通过流水号可以快速得到相关业务信息，快速定位问题（这点非常重要，这是UUID不建议使用的最重要原因）。</li>
<li>使用AtomicInteger可提高并发量，降低了冲突（这是不使用UUID另一重要原因，因为数字的效率比字符串高）</li>
</ul>
<p><img data-src="https://img-blog.csdnimg.cn/20200727143227591.png" alt=""></p>
<h4 id="实现原理简介"><a href="#实现原理简介" class="headerlink" title="实现原理简介"></a>实现原理简介</h4><p>此流水号构成：日期+Long类型的值 组成的一个一长串数字，形如<code>2020010419492195304210432</code>。很显然前面是日期数据，后面的一长串就蕴含了不少的含义：当前秒数、商家ID（也可以是你其余的业务数据）、机器ID、一串随机码等等。</p>
<p>各部分介绍：</p>
<ol>
<li>第一部分为当前时间的毫秒值。最大999，所以占10位</li>
<li>第二部分为：serviceType表示业务类型。比如订单号、操作流水号、消费流水号等等。最大值定为30，<strong>足够用了吧</strong>。占5位</li>
<li>第三部分为：shortParam，表示用户自定义的短参数。可以放置比如订单类型、操作类型等等类别参数。最大值定为30，肯定也是足够用了的。占5位</li>
<li>第四部分为：longParam，同上。用户一般可放置id参数，如用户id、商家id等等，最大支持9.9999亿。绝大多数足够用了，占30位</li>
<li>第五部分：剩余的位数交给随机数，随机生成一个数，占满剩余位数。一般至少有15位剩余（<strong>此部分位数是浮动的</strong>），所以能支持2的15次方的并发，也是足够用了的</li>
<li>最后，在上面的long值前面加上日期时间（年月日时分秒）</li>
</ol>
<p>这是A哥编写的一个基于位运算实现的流水号生成工具，已用于生产环境。考虑到源码较长（一个文件，共200行左右，无任何其它依赖）就不贴了，若有需要，<strong>请到公众号后台回复<code>流水号生成器</code>免费获取</strong>。</p>
<h1 id="✍总结"><a href="#✍总结" class="headerlink" title="✍总结"></a>✍总结</h1><p>位运算在<strong>工程的角度</strong>里缺点还是蛮多的，在实际工作中，如果只是为了数字的计算，是不建议使用位运算符的，只有一些比较特殊的场景，使用位运算去做会给你柳暗花明的感觉，如：</p>
<ul>
<li>N多状态的控制，需要兼具扩展性。比如数据库<strong>是否状态</strong>的字段设计</li>
<li>对效率有极致要求。比如JDK</li>
<li>场景非常适合。比如Jackson的Feature特针值</li>
</ul>
<p>切忌为了炫（zhuang）技（bi）而使用，炫技一时爽，掉坑火葬场；小伙还年轻，还望你谨慎。代码在大多情况下，<strong>人能容易读懂比机器能读懂来得更重要</strong>。</p>
<h5 id="✔推荐阅读："><a href="#✔推荐阅读：" class="headerlink" title="✔推荐阅读："></a>✔推荐阅读：</h5><ul>
<li><a href="https://mp.weixin.qq.com/s/z6T9n9YvwjmDwuj-YTa0_w" target="_blank" rel="noopener">Fastjson到了说再见的时候了</a></li>
<li><a href="https://mp.weixin.qq.com/s/iqSN4HUoIdX0kGcSdnD7EA" target="_blank" rel="noopener">1. 初识Jackson – 世界上最好的JSON库</a></li>
<li><a href="https://mp.weixin.qq.com/s/p6cwP2BVrC8VxkN-T3uAxg" target="_blank" rel="noopener">2. 妈呀，Jackson原来是这样写JSON的</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZHb3P06IC4xElHwJqDepxw" target="_blank" rel="noopener">3. 懂了这些，方敢在简历上说会用Jackson写JSON</a></li>
<li><a href="https://mp.weixin.qq.com/s/syAOETfEawiGItaQO35mLA" target="_blank" rel="noopener">4. JSON字符串是如何被解析的？JsonParser了解一下</a></li>
<li><a href="https://mp.weixin.qq.com/s/0ZaDYb_ueFLbvOf3FbetfQ" target="_blank" rel="noopener">5. JsonFactory工厂而已，还蛮有料，这是我没想到的</a></li>
<li><a href="https://mp.weixin.qq.com/s/VYy1QVeFLRkciymFHueb5w" target="_blank" rel="noopener">6. 二十不惑，ObjectMapper使用也不再迷惑</a></li>
</ul>]]></content>
      <categories>
        <category>A哥学Java</category>
      </categories>
      <tags>
        <tag>二进制</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>7. Jackson用树模型处理JSON是必备技能，不信你看</title>
    <url>/x2y/edc7ba2a.html</url>
    <content><![CDATA[<blockquote>
<p>每棵大树，都曾只是一粒种子。本文已被 <a href="https://www.yourbatman.cn"><strong>https://www.yourbatman.cn</strong></a> 收录，里面一并有Spring技术栈、MyBatis、JVM、中间件等小而美的<strong>专栏</strong>供以免费学习。关注公众号【<strong>BAT的乌托邦</strong>】逐个击破，深入掌握，拒绝浅尝辄止。</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20200821210157583.png#pic_center" alt=""></p>
<h1 id="✍前言"><a href="#✍前言" class="headerlink" title="✍前言"></a>✍前言</h1><p>你好，我是YourBatman。</p>
<p><a href="https://mp.weixin.qq.com/s/VYy1QVeFLRkciymFHueb5w" target="_blank" rel="noopener">上篇文章</a> 体验了一把ObjectMapper在<strong>数据绑定</strong>方面的应用，用起来还是蛮方便的有木有，为啥不少人说它难用呢，着实费解。我群里问了问，主要原因是它不是静态方法调用，并且方法名取得不那么见名之意……</p>
<p>虽然<code>ObjectMapper</code>在数据绑定上既可以处理简单类型（如Integer、List、Map等），也能处理完全类型（如POJO），看似无所不能。但是，若有如下场景它依旧<strong>不太好实现</strong>：</p>
<ol>
<li>硕大的JSON串中我只想要<strong>某一个</strong>（某几个）属性的值而已</li>
<li>临时使用，我并不想创建一个POJO与之对应，只想直接使用<strong>值</strong>即可（类型转换什么的我自己来就好）</li>
<li>数据结构高度<strong>动态化</strong></li>
</ol>
<p>为了解决这些问题，Jackson提供了强大的<strong>树模型</strong> API供以使用，这也就是本文的主要的内容。</p>
<blockquote>
<p>小贴士：树模型虽然是jackson-core模块里定义的，但是是由jackson-databind高级模块提供的实现</p>
</blockquote>
<h2 id="版本约定"><a href="#版本约定" class="headerlink" title="版本约定"></a>版本约定</h2><ul>
<li>Jackson版本：<code>2.11.0</code></li>
<li>Spring Framework版本：<code>5.2.6.RELEASE</code></li>
<li>Spring Boot版本：<code>2.3.0.RELEASE</code></li>
</ul>
<h1 id="✍正文"><a href="#✍正文" class="headerlink" title="✍正文"></a>✍正文</h1><p>树模型可能比数据绑定<strong>更方便，更灵活</strong>。特别是在结构高度<strong>动态</strong>或者不能很好地映射到Java类的情况下，它就显得更有价值了。</p>
<h2 id="树模型"><a href="#树模型" class="headerlink" title="树模型"></a>树模型</h2><p>树模型是JSON数据内存树的表示形式，这是最灵活的方法，它就类似于XML的DOM解析器。Jackson提供了树模型API来<strong>生成和解析</strong> JSON串，主要用到如下三个核心类：</p>
<ul>
<li><code>JsonNodeFactory</code>：顾名思义，用来构造各种JsonNode节点的工厂。例如对象节点ObjectNode、数组节点ArrayNode等等</li>
<li><code>JsonNode</code>：表示json节点。可以往里面塞值，从而最终构造出一颗json树</li>
<li><code>ObjectMapper</code>：实现JsonNode和JSON字符串的互转</li>
</ul>
<p>这里有个萌新的概念：JsonNode。它贯穿于整个树模型中，所以有必要先来认识它。</p>
<h2 id="JsonNode"><a href="#JsonNode" class="headerlink" title="JsonNode"></a>JsonNode</h2><p>JSON节点，可类比XML的DOM树节点结构来辅助理解。JsonNode是所有JSON节点的基类，它是一个抽象类，它有一个较大的特点：绝大多数的get方法均放在了此抽象类里（即使它没有实现），目的是：<strong>在不进行类型强制转换的情况下遍历结构</strong>。但是，大多数的<strong>修改方法</strong>都必须通过特定的子类类型去调用，这其实是合理的。因为在构建/修改某个Node节点时，类型类型信息一般是明确的，而在读取Node节点时大多数时候并不    太关心节点类型。</p>
<p>多个JsonNode节点构成Jackson实现的JSON树模型的基础，它是流式API中<code>com.fasterxml.jackson.core.TreeNode</code>接口的实现，同时它还实现了<code>Iterable</code>迭代器接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonNode</span> <span class="keyword">extends</span> <span class="title">JsonSerializable</span>.<span class="title">Base</span> </span></span><br><span class="line"><span class="class">	<span class="keyword">implements</span> <span class="title">TreeNode</span>, <span class="title">Iterable</span>&lt;<span class="title">JsonNode</span>&gt; </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JsonNode的继承图谱如下（部分）：<br><img data-src="https://img-blog.csdnimg.cn/20200728214449119.png" alt=""><br>一目了然了吧，基本上每个数据类型都会有一个JsonNode的实现类型对应。譬如数组节点<code>ArrayNode</code>、数字节点<code>NumericNode</code>等等。</p>
<p>一般情况下，我们并不需要通过new关键字去构建一个JsonNode实例，而是借助<code>JsonNodeFactory</code>工厂来做。</p>
<h2 id="JsonNodeFactory"><a href="#JsonNodeFactory" class="headerlink" title="JsonNodeFactory"></a>JsonNodeFactory</h2><p>构建JsonNode工厂类。话不多说，用几个例子跑一跑。</p>
<h3 id="值类型节点（ValueNode）"><a href="#值类型节点（ValueNode）" class="headerlink" title="值类型节点（ValueNode）"></a>值类型节点（ValueNode）</h3><p>此类节点均为<code>ValueNode</code>的子类，特点是：一个节点表示一个值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JsonNodeFactory factory = JsonNodeFactory.instance;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"------ValueNode值节点示例------"</span>);</span><br><span class="line">    <span class="comment">// 数字节点</span></span><br><span class="line">    JsonNode node = factory.numberNode(<span class="number">1</span>);</span><br><span class="line">    System.out.println(node.isNumber() + <span class="string">":"</span> + node.intValue());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// null节点</span></span><br><span class="line">    node = factory.nullNode();</span><br><span class="line">    System.out.println(node.isNull() + <span class="string">":"</span> + node.asText());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// missing节点</span></span><br><span class="line">    node = factory.missingNode();</span><br><span class="line">    System.out.println(node.isMissingNode() + <span class="string">"_"</span> + node.asText());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// POJONode节点</span></span><br><span class="line">    node = factory.pojoNode(<span class="keyword">new</span> Person(<span class="string">"YourBatman"</span>, <span class="number">18</span>));</span><br><span class="line">    System.out.println(node.isPojo() + <span class="string">":"</span> + node.asText());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"---"</span> + node.isValueNode() + <span class="string">"---"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">------ValueNode值节点示例------</span><br><span class="line"><span class="keyword">true</span>:<span class="number">1</span></span><br><span class="line"><span class="keyword">true</span>:<span class="keyword">null</span></span><br><span class="line">true_</span><br><span class="line"><span class="keyword">true</span>:Person(name=YourBatman, age=<span class="number">18</span>)</span><br><span class="line">---<span class="keyword">true</span>---</span><br></pre></td></tr></table></figure>

<h3 id="容器类型节点（ContainerNode）"><a href="#容器类型节点（ContainerNode）" class="headerlink" title="容器类型节点（ContainerNode）"></a>容器类型节点（ContainerNode）</h3><p>此类节点均为<code>ContainerNode</code>的子类，特点是：本节点代表一个容器，里面可以装任何其它节点。</p>
<p>Java中容器有两种：Map和Collection。对应的Jackson也提供了两种容器节点用于表述此类数据结构：</p>
<ul>
<li><code>ObjectNode</code>：类比Map，采用K-V结构存储。比如一个JSON结构，<strong>根节点</strong> 就是一个ObjectNode</li>
<li><code>ArrayNode</code>：类比Collection、数组。里面可以放置任何节点</li>
</ul>
<p>下面用示例感受一下它们的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JsonNodeFactory factory = JsonNodeFactory.instance;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"------构建一个JSON结构数据------"</span>);</span><br><span class="line">    ObjectNode rootNode = factory.objectNode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加普通值节点</span></span><br><span class="line">    rootNode.put(<span class="string">"zhName"</span>, <span class="string">"A哥"</span>); <span class="comment">// 效果完全同：rootNode.set("zhName", factory.textNode("A哥"))</span></span><br><span class="line">    rootNode.put(<span class="string">"enName"</span>, <span class="string">"YourBatman"</span>);</span><br><span class="line">    rootNode.put(<span class="string">"age"</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加数组容器节点</span></span><br><span class="line">    ArrayNode arrayNode = factory.arrayNode();</span><br><span class="line">    arrayNode.add(<span class="string">"java"</span>)</span><br><span class="line">            .add(<span class="string">"javascript"</span>)</span><br><span class="line">            .add(<span class="string">"python"</span>);</span><br><span class="line">    rootNode.set(<span class="string">"languages"</span>, arrayNode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加对象节点</span></span><br><span class="line">    ObjectNode dogNode = factory.objectNode();</span><br><span class="line">    dogNode.put(<span class="string">"name"</span>, <span class="string">"大黄"</span>)</span><br><span class="line">            .put(<span class="string">"age"</span>, <span class="number">3</span>);</span><br><span class="line">    rootNode.set(<span class="string">"dog"</span>, dogNode);</span><br><span class="line"></span><br><span class="line">    System.out.println(rootNode);</span><br><span class="line">    System.out.println(rootNode.get(<span class="string">"dog"</span>).get(<span class="string">"name"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">------构建一个JSON结构数据------</span><br><span class="line">&#123;<span class="string">"zhName"</span>:<span class="string">"A哥"</span>,<span class="string">"enName"</span>:<span class="string">"YourBatman"</span>,<span class="string">"age"</span>:<span class="number">18</span>,<span class="string">"languages"</span>:[<span class="string">"java"</span>,<span class="string">"javascript"</span>,<span class="string">"python"</span>],<span class="string">"dog"</span>:&#123;<span class="string">"name"</span>:<span class="string">"大黄"</span>,<span class="string">"age"</span>:<span class="number">3</span>&#125;&#125;</span><br><span class="line"><span class="string">"大黄"</span></span><br></pre></td></tr></table></figure>

<h2 id="ObjectMapper中的树模型"><a href="#ObjectMapper中的树模型" class="headerlink" title="ObjectMapper中的树模型"></a>ObjectMapper中的树模型</h2><p>树模型其实是底层<strong>流式API</strong>所提出和支持的，典型API便是<code>com.fasterxml.jackson.core.TreeNode</code>。但通过前面文章的示例讲解可以知道：底层流式API仅定义了接口而并未提供任何实现，甚至半成品都算不上。所以说要使用Jackson的树模型还得看ObjectMapper，它提供了TreeNode等API的完整实现。</p>
<p>不乏很多小伙伴对<code>ObjectMapper</code>的树模型是一知半解的，甚至从来都没有用过，其实它是<strong>非常灵活</strong>和强大的。有了上面的基础示例做支撑，再来了解它的实现就得心应手多了。</p>
<p>ObjectMapper中提供了树模型(tree model) API 来生成和解析 json 字符串。如果你不想为你的 json 结构单独建类与之对应的话，则可以选择该 API，如下图所示：<br><img data-src="https://img-blog.csdnimg.cn/20200820212454191.png#pic_center" alt=""><br>ObjectMapper在读取JSON后提供指向树的根节点的指针， 根节点可用于<strong>遍历</strong>完整的树。 同样的，我们可从读（反序列化）、写（序列化）两个方面来展开。</p>
<h3 id="写（序列化）"><a href="#写（序列化）" class="headerlink" title="写（序列化）"></a>写（序列化）</h3><p>将Object写为JsonNode，ObjectMapper给我们提供了三个实用API俩操作它：<br><img data-src="https://img-blog.csdnimg.cn/20200821184426585.png#pic_center" alt=""></p>
<h4 id="1、valueToTree-Object"><a href="#1、valueToTree-Object" class="headerlink" title="1、valueToTree(Object)"></a>1、valueToTree(Object)</h4><p>该方法属相对较为常用：将任意对象（包括null）写为一个JsonNode树模型。功能上类似于先将Object序列化为JSON串，再读为JsonNode，但很明显这样一步到位更加高效。</p>
<blockquote>
<p>小贴士：高效不代表性能高，因为其内部实现好还是调用了<code>readTree()</code>方法的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    person.setName(<span class="string">"YourBatman"</span>);</span><br><span class="line">    person.setAge(<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    person.setDog(<span class="keyword">new</span> Person.Dog(<span class="string">"旺财"</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    JsonNode node = mapper.valueToTree(person);</span><br><span class="line"></span><br><span class="line">    System.out.println(person);</span><br><span class="line">    <span class="comment">// 遍历打印所有属性</span></span><br><span class="line">    Iterator&lt;JsonNode&gt; it = node.iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        JsonNode nextNode = it.next();</span><br><span class="line">        <span class="keyword">if</span> (nextNode.isContainerNode()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nextNode.isObject()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"狗的属性：：："</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(nextNode.get(<span class="string">"name"</span>));</span><br><span class="line">                System.out.println(nextNode.get(<span class="string">"age"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(nextNode.asText());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接获取</span></span><br><span class="line">    System.out.println(<span class="string">"---------------------------------------"</span>);</span><br><span class="line">    System.out.println(node.get(<span class="string">"dog"</span>).get(<span class="string">"name"</span>));</span><br><span class="line">    System.out.println(node.get(<span class="string">"dog"</span>).get(<span class="string">"age"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，控制台输出：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">Person(name=YourBatman, age=18, dog=Person.Dog(name=旺财, age=3))</span><br><span class="line">YourBatman</span><br><span class="line"><span class="number">18</span></span><br><span class="line">狗的属性：：：</span><br><span class="line"><span class="string">"旺财"</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">---------------------------------------</span><br><span class="line"><span class="string">"旺财"</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>对于JsonNode在这里补充一个要点：读取其属性，你既可以用迭代器遍历，也可以根据key（属性）直接获取，是不是和Map的使用几乎一毛一样？</p>
<h4 id="2、writeTree-JsonGenerator-JsonNode"><a href="#2、writeTree-JsonGenerator-JsonNode" class="headerlink" title="2、writeTree(JsonGenerator, JsonNode)"></a>2、writeTree(JsonGenerator, JsonNode)</h4><p>顾名思义：将一个JsonNode使用JsonGenerator写到输出流里，此方法直接使用到了JsonGenerator这个API，灵活度杠杠的，但相对偏底层，本处仍旧给个示例玩玩吧（底层API更多详解，请参见本系列前面几篇文章）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    <span class="keyword">try</span> (JsonGenerator jsonGenerator = factory.createGenerator(System.err, JsonEncoding.UTF8)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、得到一个jsonNode（为了方便我直接用上面API生成了哈）</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.setName(<span class="string">"YourBatman"</span>);</span><br><span class="line">        person.setAge(<span class="number">18</span>);</span><br><span class="line">        JsonNode jsonNode = mapper.valueToTree(person);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用JsonGenerator写到输出流</span></span><br><span class="line">        mapper.writeTree(jsonGenerator, jsonNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，控制台输出：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"YourBatman"</span>,<span class="attr">"age"</span>:<span class="number">18</span>,<span class="attr">"dog"</span>:<span class="literal">null</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、writeTree-JsonGenerator-TreeNode"><a href="#3、writeTree-JsonGenerator-TreeNode" class="headerlink" title="3、writeTree(JsonGenerator,TreeNode)"></a>3、writeTree(JsonGenerator,TreeNode)</h4><p>JsonNode是TreeNode的实现类，上面方法已经给出了使用示例，所以本方法不在赘述你应该不会有意见了吧。</p>
<h3 id="读（反序列化）"><a href="#读（反序列化）" class="headerlink" title="读（反序列化）"></a>读（反序列化）</h3><p>将一个资源（如字符串）读取为一个JsonNode树模型。<br><img data-src="https://img-blog.csdnimg.cn/2020082119261653.png#pic_center" alt=""><br>这是典型的方法重载设计，API更加友好，所有方法底层均为<code>_readTreeAndClose()</code>这个protected方法，可谓“万剑归宗”。</p>
<p>下面以最为常见的：读取JSON字符串为例，其它的举一反三即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    String jsonStr = <span class="string">"&#123;\"name\":\"YourBatman\",\"age\":18,\"dog\":null&#125;"</span>;</span><br><span class="line">    <span class="comment">// 直接映射为一个实体对象</span></span><br><span class="line">    <span class="comment">// mapper.readValue(jsonStr, Person.class);</span></span><br><span class="line">    <span class="comment">// 读取为一个树模型</span></span><br><span class="line">    JsonNode node = mapper.readTree(jsonStr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于底层<code>_readTreeAndClose(JsonParser)</code>方法的具体实现，就有得捞了。不过鉴于它过于枯燥和稍有些烧脑，后面撰有专文详解，有兴趣可持续关注。</p>
<h2 id="场景演练"><a href="#场景演练" class="headerlink" title="场景演练"></a>场景演练</h2><p>理论和示例讲完了，<strong>光说不练假把式</strong>，下面A哥根据经验，举两个树模型的实际使用示例供你参考。</p>
<h3 id="1、偌大JSON串中仅需1个值"><a href="#1、偌大JSON串中仅需1个值" class="headerlink" title="1、偌大JSON串中仅需1个值"></a>1、偌大JSON串中仅需1个值</h3><p>这种场景其实还蛮常见的，比如有个很经典的场景便是在MQ消费中：生产者一般会恨不得把它能吐出来的属性尽可能都扔出来，但对于不同的消费者而言它们的所需往往是不一样的：</p>
<ul>
<li>需要较多的属性值，这时候用<strong>完全数据绑定</strong>转换成POJO来操作更为方便和合理</li>
<li>需要1个(较少)的属性值，这时候“杀鸡岂能用牛刀”呢，这种case使用树模型来做就显得更为优雅和高效了</li>
</ul>
<p>譬如，生产者生产的消息JSON串如下（模拟数据，总之你就当做它属性很多、嵌套很深就对了）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"YourBatman"</span>,<span class="attr">"age"</span>:<span class="number">18</span>,<span class="attr">"dog"</span>:&#123;<span class="attr">"name"</span>:<span class="string">"旺财"</span>,<span class="attr">"color"</span>:<span class="string">"WHITE"</span>&#125;,<span class="attr">"hobbies"</span>:[<span class="string">"篮球"</span>,<span class="string">"football"</span>]&#125;</span><br></pre></td></tr></table></figure>
<p>这时候，我仅关心狗的颜色，肿么办呢？相信你已经想到了：树模型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    String jsonStr = <span class="string">"&#123;\"name\":\"YourBatman\",\"age\":18,\"dog\":&#123;\"name\":\"旺财\",\"color\":\"WHITE\"&#125;,\"hobbies\":[\"篮球\",\"football\"]&#125;"</span>;</span><br><span class="line">    JsonNode node = mapper.readTree(jsonStr);</span><br><span class="line"></span><br><span class="line">    System.out.println(node.get(<span class="string">"dog"</span>).get(<span class="string">"color"</span>).asText());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，控制台输出：<code>WHITE</code>，目标达成。值得注意的是：如果<code>node.get(&quot;dog&quot;)</code>没有这个节点(或者值为null)，是会抛出<code>NPE</code>异常的，因此请你自己保证代码的健壮性。</p>
<p>当你不想创建一个Java Bean与JSON属性相对应时，树模型的<strong>所见即所得</strong>特性就很好解决了这个问题。</p>
<h3 id="2、数据结构高度动态化"><a href="#2、数据结构高度动态化" class="headerlink" title="2、数据结构高度动态化"></a>2、数据结构高度动态化</h3><p>当数据结构高度动态化（随时可能新增、删除节点）时，使用树模型去处理是一个较好的方案（稳定之后再转为Java Bean即可）。这主要是利用了树模型它具有动态可扩展的特性，满足我们日益变化的结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    String jsonStr = <span class="string">"&#123;\"name\":\"YourBatman\",\"age\":18&#125;"</span>;</span><br><span class="line"></span><br><span class="line">    JsonNode node = <span class="keyword">new</span> ObjectMapper().readTree(jsonStr);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"-------------向结构里动态添加节点------------"</span>);</span><br><span class="line">    <span class="comment">// 动态添加一个myDiy节点，并且该节点还是ObjectNode节点</span></span><br><span class="line">    ((ObjectNode) node).with(<span class="string">"myDiy"</span>).put(<span class="string">"contry"</span>, <span class="string">"China"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，控制台输出：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">-------------向结构里动态添加节点------------</span><br><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"YourBatman"</span>,<span class="attr">"age"</span>:<span class="number">18</span>,<span class="attr">"myDiy"</span>:&#123;<span class="attr">"contry"</span>:<span class="string">"China"</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>说白了，也没啥特殊的。拿到一个<code>JsonNode</code>后你可以任意的造它，就像<code>Map&lt;Object,Object&gt;</code>一样~</p>
<h1 id="✍总结"><a href="#✍总结" class="headerlink" title="✍总结"></a>✍总结</h1><p>树模型(tree model) API比Jackson 流式(Streaming) API 简单了很多，不管是生成 json字符串还是解析json字符串。但是相对于<strong>自动化</strong>的数据绑定而言还是比较复杂的。</p>
<p>树模型(tree model) API在只需要取出一个大json串中的几个值时比较方便。如果json中每个（大部分）值都需要获得，那么这种方式便显得比较繁琐了。因此在实际应用中具体问题具体分析，<strong>但是，Jackson的树模型你必须得掌握</strong>。</p>
<h5 id="✔推荐阅读："><a href="#✔推荐阅读：" class="headerlink" title="✔推荐阅读："></a>✔推荐阅读：</h5><ul>
<li><a href="https://mp.weixin.qq.com/s/z6T9n9YvwjmDwuj-YTa0_w" target="_blank" rel="noopener">Fastjson到了说再见的时候了</a></li>
<li><a href="https://mp.weixin.qq.com/s/iqSN4HUoIdX0kGcSdnD7EA" target="_blank" rel="noopener">1. 初识Jackson – 世界上最好的JSON库</a></li>
<li><a href="https://mp.weixin.qq.com/s/p6cwP2BVrC8VxkN-T3uAxg" target="_blank" rel="noopener">2. 妈呀，Jackson原来是这样写JSON的</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZHb3P06IC4xElHwJqDepxw" target="_blank" rel="noopener">3. 懂了这些，方敢在简历上说会用Jackson写JSON</a></li>
<li><a href="https://mp.weixin.qq.com/s/syAOETfEawiGItaQO35mLA" target="_blank" rel="noopener">4. JSON字符串是如何被解析的？JsonParser了解一下</a></li>
<li><a href="https://mp.weixin.qq.com/s/0ZaDYb_ueFLbvOf3FbetfQ" target="_blank" rel="noopener">5. JsonFactory工厂而已，还蛮有料，这是我没想到的</a></li>
<li><a href="https://mp.weixin.qq.com/s/VYy1QVeFLRkciymFHueb5w" target="_blank" rel="noopener">6. 二十不惑，ObjectMapper使用也不再迷惑</a></li>
</ul>]]></content>
      <categories>
        <category>缺省</category>
      </categories>
      <tags>
        <tag>Jackson</tag>
        <tag>ObjectMapper</tag>
        <tag>树模型</tag>
      </tags>
  </entry>
  <entry>
    <title>6. 二十不惑，ObjectMapper使用也不再迷惑</title>
    <url>/x2y/4834a651.html</url>
    <content><![CDATA[<blockquote>
<p>一滴水，用显微镜看，也是一个大世界。本文已被 <a href="https://www.yourbatman.cn"><strong>https://www.yourbatman.cn</strong></a> 收录，里面一并有Spring技术栈、MyBatis、JVM、中间件等小而美的<strong>专栏</strong>供以免费学习。关注公众号【<strong>BAT的乌托邦</strong>】逐个击破，深入掌握，拒绝浅尝辄止。</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20200728184059505.png" alt=""></p>
<h1 id="✍前言"><a href="#✍前言" class="headerlink" title="✍前言"></a>✍前言</h1><p>各位好，我是YourBatman。从本文起，终于要和Jackson的“高级”部分打交道了，也就是数据绑定<code>jackson-databind</code>模块。通过接触它的高级API，你会持续的发现，前面花那么多篇幅讲的core核心部分是价值连城的。毕竟村上春树也告诉过我们：<strong>人生没有无用的经历</strong>嘛。</p>
<p><code>jackson-databind</code>包含用于Jackson数据处理器的通用 <strong>数据绑定功能</strong>和<strong>树模型</strong>。它构建在Streaming API之上，并使用<code>Jackson注解</code>进行配置。它就是Jackson提供的高层API，是开发者使用得最多的方式，因此重要程度可见一斑。</p>
<p>虽然Jackson最初的用例是JSON数据绑定，但现在它也可以用于其它数据格式，只要存在解析器和生成器实现即可。但需要注意的是：类的命名在很多地方仍旧使用了“JSON”这个词（比如JsonGenerator），尽管它与JSON格式没有实际的硬依赖关系。</p>
<blockquote>
<p>小贴士：底层流式API使用的I/O进行输入输出，因此理论上是支持任何格式的</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20200727172633700.png" alt=""></p>
<h2 id="版本约定"><a href="#版本约定" class="headerlink" title="版本约定"></a>版本约定</h2><ul>
<li>Jackson版本：<code>2.11.0</code></li>
<li>Spring Framework版本：<code>5.2.6.RELEASE</code></li>
<li>Spring Boot版本：<code>2.3.0.RELEASE</code></li>
</ul>
<p>从<strong>本文开始</strong>，新增导包：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Tips：<code>jackson-databind</code>模块它强依赖于jackson-core和jackson-annotations，只需要导入此包，另外两个它自动会帮带进来。</p>
<blockquote>
<p>这里需要说明几句：我们知道core包中还有个<code>jackson-annotations</code>，难道不讲了吗？其实不是，是因为单独讲<code>jackson-annotations</code>并无意义，毕竟注解还得靠数据绑定模块来解析，所以先搞定这个后再杀回去。</p>
</blockquote>
<h1 id="✍正文"><a href="#✍正文" class="headerlink" title="✍正文"></a>✍正文</h1><p>据我了解，很多小伙伴对Jackson的了解起源于<code>ObjectMapper</code>，止于<code>ObjectMapper</code>。那行，作为接触它的第一篇文章咱们就轻松点，以应用为主来整体的认识它。</p>
<h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><p>ObjectMapper是jackson-databind模块最为重要的一个类，它完成了coder对数据绑定的<strong>几乎所有功能</strong>。它是面向用户的高层API，底层依赖于Streaming API来实现读/写。ObjectMapper主要提供的功能点如下：</p>
<ul>
<li>它提供读取和写入JSON的功能（最重要的功能）<ul>
<li>普通POJO的序列化/反序列化</li>
<li>JSON树模型的读/写</li>
</ul>
</li>
<li>它可以被<strong>高度定制</strong>，以使用不同风格的JSON内容<ul>
<li>使用Feature进行定制</li>
<li>使用可插拔<code>com.fasterxml.jackson.databind.Module</code>模块来扩展/丰富功能</li>
</ul>
</li>
<li>它还支持<strong>更高级</strong>的对象概念：比如多态泛型、对象标识</li>
<li>它还充当了更为高级（更强大）的API：ObjectReader和ObjectWriter的<strong>工厂</strong><ul>
<li><code>ObjectReader</code>和<code>ObjectWriter</code>底层亦是依赖于Streaming API实现读写</li>
</ul>
</li>
</ul>
<p>尽管绝大部分的读/写API都通过ObjectMapper暴露出去了，但有些功能函数还是只放在了ObjectReader/ObjectWriter里，比如对于读/写 <strong>长序列</strong> 的能力你只能通过<code>ObjectReader#readValues(InputStream) / ObjectWriter#writeValues(OutputStream)</code>去处理，这是设计者有意为之，毕竟这种case很少很少，没必要和常用的凑合在一起嘛。</p>
<h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><p>数据绑定分为简单数据绑定和完全数据绑定：</p>
<ul>
<li><strong>简单数据绑定</strong>：比如绑定int类型、List、Map等…</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 绑定简单类型  和 Map类型</span></span><br><span class="line">    Integer age = objectMapper.readValue(<span class="string">"1"</span>, <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    Map map = objectMapper.readValue(<span class="string">"&#123;\"name\":  \"YourBatman\"&#125;"</span>, Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(age);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">&#123;name=YourBatman&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>完全数据绑定</strong>：绑定到任意的Java Bean对象…</li>
</ul>
<p>准备一个POJO：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>绑定数据到POJO：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    Person person = objectMapper.readValue(<span class="string">"&#123;\"name\":  \"YourBatman\", \"age\": 18&#125;"</span>, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person(name=YourBatman, age=<span class="number">18</span>)</span><br></pre></td></tr></table></figure>

<h2 id="ObjectMapper的使用"><a href="#ObjectMapper的使用" class="headerlink" title="ObjectMapper的使用"></a>ObjectMapper的使用</h2><p>在应用及开发中，ObjectMapper绝对是最常使用的，也是你使用Jackson的入口，本文就列列它的那些使用场景。</p>
<blockquote>
<p>小贴士：树模型会单独成文介绍，体现出它的重要性</p>
</blockquote>
<h3 id="写（序列化）"><a href="#写（序列化）" class="headerlink" title="写（序列化）"></a>写（序列化）</h3><p>提供<code>writeValue()</code>系列方法用于写数据（可写任何类型），也就是我们常说的<strong>序列化</strong>。<br><img data-src="https://img-blog.csdnimg.cn/20200728161107234.png" alt=""></p>
<ul>
<li>writeValue(File resultFile, Object value)：写到目标文件里</li>
<li>writeValue(OutputStream out, Object value)：写到输出流</li>
<li><strong>String writeValueAsString(Object value)：写成字符串形式，此方法最为常用</strong></li>
<li>writeValueAsBytes(Object value)：写成字节数组<code>byte[]</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"----------写简单类型----------"</span>);</span><br><span class="line">    System.out.println(objectMapper.writeValueAsString(<span class="number">18</span>));</span><br><span class="line">    System.out.println(objectMapper.writeValueAsString(<span class="string">"YourBatman"</span>));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"----------写集合类型----------"</span>);</span><br><span class="line">    System.out.println(objectMapper.writeValueAsString(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)));</span><br><span class="line">    System.out.println(objectMapper.writeValueAsString(<span class="keyword">new</span> HashMap&lt;String, String&gt;() &#123;&#123;</span><br><span class="line">        put(<span class="string">"zhName"</span>, <span class="string">"A哥"</span>);</span><br><span class="line">        put(<span class="string">"enName"</span>, <span class="string">"YourBatman"</span>);</span><br><span class="line">    &#125;&#125;));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"----------写POJO----------"</span>);</span><br><span class="line">    System.out.println(objectMapper.writeValueAsString(<span class="keyword">new</span> Person(<span class="string">"A哥"</span>, <span class="number">18</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">----------写简单类型----------</span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="string">"YourBatman"</span></span><br><span class="line">----------写集合类型----------</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#123;<span class="string">"zhName"</span>:<span class="string">"A哥"</span>,<span class="string">"enName"</span>:<span class="string">"YourBatman"</span>&#125;</span><br><span class="line">----------写POJO----------</span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"A哥"</span>,<span class="string">"age"</span>:<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读（反序列化）"><a href="#读（反序列化）" class="headerlink" title="读（反序列化）"></a>读（反序列化）</h3><p>提供<code>readValue()</code>系列方法用于读数据（一般读字符串类型），也就是我们常说的<strong>反序列化</strong>。<br><img data-src="https://img-blog.csdnimg.cn/2020072816260696.png" alt=""></p>
<ul>
<li><code>readValue(String content, Class&lt;T&gt; valueType)</code>：读为指定class类型的对象，此方法最常用</li>
<li><code>readValue(String content, TypeReference&lt;T&gt; valueTypeRef)</code>：T表示泛型类型，如<code>List&lt;T&gt;</code>这种类型，一般用于集合/Map的反序列化</li>
<li>readValue(String content, JavaType valueType)：Jackson内置的JavaType类型，后再详解（使用并不多）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"----------读简单类型----------"</span>);</span><br><span class="line">    System.out.println(objectMapper.readValue(<span class="string">"18"</span>, Integer<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    <span class="comment">// 抛错：JsonParseException  单独的一个串，解析会抛错</span></span><br><span class="line">    <span class="comment">// System.out.println(objectMapper.readValue("YourBatman", String.class));</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"----------读集合类型----------"</span>);</span><br><span class="line">    System.out.println(objectMapper.readValue(<span class="string">"[1,2,3]"</span>, List<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    System.out.println(objectMapper.readValue(<span class="string">"&#123;\"zhName\":\"A哥\",\"enName\":\"YourBatman\"&#125;"</span>, Map<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"----------读POJO----------"</span>);</span><br><span class="line">    System.out.println(objectMapper.readValue(<span class="string">"&#123;\"name\":\"A哥\",\"age\":18&#125;"</span>, Person<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">----------读简单类型----------</span><br><span class="line"><span class="number">18</span></span><br><span class="line">----------读集合类型----------</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#123;zhName=A哥, enName=YourBatman&#125;</span><br><span class="line">----------读POJO----------</span><br><span class="line">Person(name=A哥, age=<span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<p>不同于序列化，可以把“所有”写成为一个字符串。反序列化场景有它特殊的地方，比如例子中所示：不能反序列化一个“单纯的”字符串。</p>
<h3 id="泛型擦除问题"><a href="#泛型擦除问题" class="headerlink" title="泛型擦除问题"></a>泛型擦除问题</h3><p>从例举出来的三个read读方法中，就应该觉得事情还没完，比如这个带泛型的case：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"----------读集合类型----------"</span>);</span><br><span class="line">    List&lt;Long&gt; list = objectMapper.readValue(<span class="string">"[1,2,3]"</span>, List<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    Long id = list.get(<span class="number">0</span>);</span><br><span class="line">    System.out.println(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，抛错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">----------读集合类型----------</span><br><span class="line"></span><br><span class="line">java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.Long</span><br><span class="line"></span><br><span class="line">	at cn.yourbatman.jackson.core.ObjectMapperDemo.test5(ObjectMapperDemo.java:<span class="number">100</span>)</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>异常栈里指出：<code>Long id = list.get(0);</code>这一句出现了<strong>类型转换异常</strong>，这便是问题原因所在：泛型擦除，参考图示如下（明明泛型类型是Long，但实际装的是Integer类型）：<br><img data-src="https://img-blog.csdnimg.cn/20200728165827574.png" alt=""><br>对这种问题，你可能会“动脑筋”思考：写成<code>[1L,2L,3L]</code>这样行不行。思想很活跃，奈何现实依旧残酷，运行抛错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.fasterxml.jackson.core.JsonParseException: <span class="function">Unexpected <span class="title">character</span> <span class="params">(<span class="string">'L'</span> (code <span class="number">76</span>)</span>): was expecting comma to separate Array entries</span></span><br><span class="line"><span class="function"> at [Source: <span class="params">(String)</span>"[1L,2L,3L]"</span>; line: <span class="number">1</span>, column: <span class="number">4</span>]</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>
<p>这是典型的泛型擦除问题。该问题只可能出现在读（反序列化）上，不能出现在写上。那么这种问题怎么破？</p>
<p><strong>在解决此问题之前，我们得先对Java中的泛型擦除有所了解，至少知道如下两点结论：</strong></p>
<ol>
<li>Java 在编译时会在字节码里指令集之外的地方保留<strong>部分</strong>泛型信息</li>
<li>泛型接口、类、方法定义上的所有泛型、成员变量声明处的泛型<strong>都会</strong>被保留类型信息，<strong>其它地方</strong>的泛型信息都会被擦除</li>
</ol>
<p>此问题在开发过程中非常高频，有了此理论作为支撑，A哥提供两种可以解决本问题的方案供以参考：</p>
<h4 id="方案一：利用成员变量保留泛型"><a href="#方案一：利用成员变量保留泛型" class="headerlink" title="方案一：利用成员变量保留泛型"></a>方案一：利用成员变量保留泛型</h4><p>理论依据：成员变量的泛型类型不会被擦除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"----------读集合类型----------"</span>);</span><br><span class="line">    Data data = objectMapper.readValue(<span class="string">"&#123;\"ids\" : [1,2,3]&#125;"</span>, Data<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    Long id = data.getIds().get(<span class="number">0</span>);</span><br><span class="line">    System.out.println(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@lombok</span>.Data</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Long&gt; ids;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，一切正常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">----------读集合类型----------</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="方案二：使用官方推荐的TypeReference-lt-T-gt"><a href="#方案二：使用官方推荐的TypeReference-lt-T-gt" class="headerlink" title="方案二：使用官方推荐的TypeReference&lt;T&gt;"></a>方案二：使用官方推荐的<code>TypeReference&lt;T&gt;</code></h4><p>官方早早就为我们考虑好了这类泛型擦除的问题，所以它提供了<code>TypeReference&lt;T&gt;</code>方便我们把泛型类型保留下来，使用起来是非常的方便的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"----------读集合类型----------"</span>);</span><br><span class="line">    List&lt;Long&gt; ids = objectMapper.readValue(<span class="string">"[1,2,3]"</span>, <span class="keyword">new</span> TypeReference&lt;List&lt;Long&gt;&gt;() &#123;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Long id = ids.get(<span class="number">0</span>);</span><br><span class="line">    System.out.println(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，一切正常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">----------读集合类型----------</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>本方案的理论依据是：泛型接口/类上的泛型类型不会被擦除。</p>
<p>对于泛型擦除情况，解决思路是<strong>hold住</strong>泛型类型，这样反序列化的时候才不会抓瞎。但凡只要一抓瞎，Jackson就木有办法只能采用<strong>通用/默认类型</strong>去装载喽。</p>
<h2 id="加餐"><a href="#加餐" class="headerlink" title="加餐"></a>加餐</h2><p>自<code>2.10</code>版本起，给ObjectMapper提供了一个子类：<code>JsonMapper</code>，使得语义更加明确，专门用于处理JSON格式。</p>
<blockquote>
<p>严格意义上讲，ObjectMapper不局限于处理JSON格式，比如后面会讲到的它的另外一个子类<code>YAMLMapper</code>用于对Yaml格式的支持（需额外导包，后面见~）</p>
</blockquote>
<p>另外，由于构建一个ObjectMapper实例属于高频动作，因此Jackson也顺应潮流的提供了<code>MapperBuilder</code>构建器（2.10版本起）。我们可以通过此构建起很容易的得到一个ObjectMapper（以JsonMapper为例）实例来使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    JsonMapper jsonMapper = JsonMapper.builder()</span><br><span class="line">            .configure(JsonReadFeature.ALLOW_SINGLE_QUOTES, <span class="keyword">true</span>)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    Person person = jsonMapper.readValue(<span class="string">"&#123;'name':  'YourBatman', 'age': 18&#125;"</span>, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，正常输出：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Person(name=YourBatman, age=18)</span><br></pre></td></tr></table></figure>


<h1 id="✍总结"><a href="#✍总结" class="headerlink" title="✍总结"></a>✍总结</h1><p>本文内容很轻松，讲述了ObjectMapper的日常使用，使用它进行读/写，完成日常功能。</p>
<p>对于写来说比较简单，一个<code>writeValueAsString(obj)</code>方法走天下；但对于读来说，除了使用<code>readValue(String content, Class&lt;T&gt; valueType)</code>自动完成数据绑定外，需要特别注意泛型擦除问题：<strong>若反序列化成为一个集合类型（Collection or Map），泛型会被擦除</strong>，此时你应该使用<code>readValue(String content, TypeReference&lt;T&gt; valueTypeRef)</code>方法代替。</p>
<blockquote>
<p>小贴士：若你在工程中遇到<code>objectMapper.readValue(xxx, List.class)</code>这种代码，那肯定是有安全隐患的（但不一定报错）</p>
</blockquote>
<h5 id="✔推荐阅读："><a href="#✔推荐阅读：" class="headerlink" title="✔推荐阅读："></a>✔推荐阅读：</h5><ul>
<li><a href="https://mp.weixin.qq.com/s/z6T9n9YvwjmDwuj-YTa0_w" target="_blank" rel="noopener">Fastjson到了说再见的时候了</a></li>
<li><a href="https://mp.weixin.qq.com/s/iqSN4HUoIdX0kGcSdnD7EA" target="_blank" rel="noopener">1. 初识Jackson – 世界上最好的JSON库</a></li>
<li><a href="https://mp.weixin.qq.com/s/p6cwP2BVrC8VxkN-T3uAxg" target="_blank" rel="noopener">2. 妈呀，Jackson原来是这样写JSON的</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZHb3P06IC4xElHwJqDepxw" target="_blank" rel="noopener">3. 懂了这些，方敢在简历上说会用Jackson写JSON</a></li>
<li><a href="https://mp.weixin.qq.com/s/syAOETfEawiGItaQO35mLA" target="_blank" rel="noopener">4. JSON字符串是如何被解析的？JsonParser了解一下</a></li>
<li><a href="https://mp.weixin.qq.com/s/0ZaDYb_ueFLbvOf3FbetfQ" target="_blank" rel="noopener">5. JsonFactory工厂而已，还蛮有料，这是我没想到的</a></li>
</ul>]]></content>
      <categories>
        <category>A哥学Jackson</category>
      </categories>
      <tags>
        <tag>Jackson</tag>
        <tag>ObjectMapper</tag>
      </tags>
  </entry>
  <entry>
    <title>5. JsonFactory工厂而已，还蛮有料，这是我没想到的</title>
    <url>/x2y/1f2d2fb8.html</url>
    <content><![CDATA[<blockquote>
<p>少年易学老难成，一寸光阴不可轻。本文已被 <a href="https://www.yourbatman.cn"><strong>https://www.yourbatman.cn</strong></a> 收录，里面一并有Spring技术栈、MyBatis、JVM、中间件等小而美的<strong>专栏</strong>供以免费学习。关注公众号【<strong>BAT的乌托邦</strong>】逐个击破，深入掌握，拒绝浅尝辄止。</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20200728142302514.png" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>各位好，我是YourBatman。前面用四篇文章介绍完了Jackson底层流式API的读（JsonParser）、写（JsonGenerator）操作，我们清楚的知道，这哥俩都是abstract抽象类，使用时并没有显示的去new它们的（子类）实例，均通过一个工厂来搞定，这便就是本文的主角<code>JsonFactory</code>。</p>
<p>通过名称就知道，这是工厂设计模式。Jackson它并不建议你直接new读/写实例，因为那过于麻烦。为了对使用者<strong>屏蔽</strong>这些复杂的构造细节，于是就有了<code>JsonFactory</code>实例工厂的出现。</p>
<p>可能有的人会说，一个对象工厂有什么好了解的，很简单嘛。非也非也，<strong>一件事情本身的复杂度并不会凭空消失，而是从一个地方转移到另外一个地方</strong>，这另外一个地方指的就是JsonFactory。因此按照本系列的定位，了解它你绕不过去。</p>
<h2 id="版本约定"><a href="#版本约定" class="headerlink" title="版本约定"></a>版本约定</h2><ul>
<li>Jackson版本：<code>2.11.0</code></li>
<li>Spring Framework版本：<code>5.2.6.RELEASE</code></li>
<li>Spring Boot版本：<code>2.3.0.RELEASE</code></li>
</ul>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>JsonFactory是Jackson的（最）主要工厂类，用于 配置和构建<code>JsonGenerator</code>和<code>JsonParser</code>，这个工厂实例是<strong>线程安全</strong>的，因此可以重复使用。</p>
<p>作为一个实例工厂，它最重要的职责当然是创建实例对象。本工厂职责并不单一，它负责读、写两种实例的创建工作。</p>
<h2 id="创建JsonGenerator实例"><a href="#创建JsonGenerator实例" class="headerlink" title="创建JsonGenerator实例"></a>创建JsonGenerator实例</h2><p><img data-src="https://img-blog.csdnimg.cn/20200725145602371.png" alt=""><br>JsonGenerator它负责向目的地写数据，因此强调的是<strong>目的地在哪？如何写？</strong></p>
<p>如截图所示，一共有六个重载方法用于构建JsonGenerator实例，多个重载方法目的是对使用者友好，我们可以认为最终效果是一样的。比如，底层实现是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JsonFactory:</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonGenerator <span class="title">createGenerator</span><span class="params">(OutputStream out, JsonEncoding enc)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        IOContext ctxt = _createContext(out, <span class="keyword">false</span>);</span><br><span class="line">        ctxt.setEncoding(enc);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果编码是UTF-8</span></span><br><span class="line">        <span class="keyword">if</span> (enc == JsonEncoding.UTF8) &#123;</span><br><span class="line">            <span class="keyword">return</span> _createUTF8Generator(_decorate(out, ctxt), ctxt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用指定的编码把OutputStream包装为一个writer</span></span><br><span class="line">        Writer w = _createWriter(out, enc, ctxt);</span><br><span class="line">        <span class="keyword">return</span> _createGenerator(_decorate(w, ctxt), ctxt);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这就解释了，为何在详解JsonGenerator的这篇文章中，我一直以<code>UTF8JsonGenerator</code>作为实例进行讲解，因为例子中指定的编码就是UTF-8嘛。当然，即使你自己不显示的指定编码集，默认情况下Jackson也是使用UTF-8：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JsonFactory:</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonGenerator <span class="title">createGenerator</span><span class="params">(OutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createGenerator(out, JsonEncoding.UTF8);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonFactory jsonFactory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line"></span><br><span class="line">    JsonGenerator jsonGenerator1 = jsonFactory.createGenerator(System.out);</span><br><span class="line">    JsonGenerator jsonGenerator2 = jsonFactory.createGenerator(System.out, JsonEncoding.UTF8);</span><br><span class="line"></span><br><span class="line">    System.out.println(jsonGenerator1);</span><br><span class="line">    System.out.println(jsonGenerator2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.fasterxml.jackson.core.json.UTF8JsonGenerator<span class="meta">@cb</span>51256</span><br><span class="line">com.fasterxml.jackson.core.json.UTF8JsonGenerator@<span class="number">59906517</span></span><br></pre></td></tr></table></figure>

<h2 id="创建JsonParser实例"><a href="#创建JsonParser实例" class="headerlink" title="创建JsonParser实例"></a>创建JsonParser实例</h2><p><img data-src="https://img-blog.csdnimg.cn/20200725145457812.png" alt=""><br>JsonParser它负责从一个JSON字符串中提取出值，因此它强调的是<strong>数据从哪来？如何解析？</strong></p>
<p>如截图所示，一共11个重载方法（其实最后一个不属于重载）用于构建JsonParser实例，它的底层实现是根据不同的数据媒介，使用了不同的处理方式，最终生成<code>UTF8StreamJsonParser/ReaderBasedJsonParser</code>。</p>
<p>你会发现这几个重载方法均无需我们指定编码集，那它是如何确定<strong>使用何种编码</strong>去解码形如byte[]数组这种数据来源的呢？这得益于其内部的编码自动发现机制实现，也就是<code>ByteSourceJsonBootstrapper#detectEncoding()</code>这个方法。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonFactory jsonFactory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line"></span><br><span class="line">    JsonParser jsonParser1 = jsonFactory.createParser(<span class="string">"&#123;&#125;"</span>);</span><br><span class="line">    <span class="comment">// JsonParser jsonParser2 = jsonFactory.createParser(new FileReader("..."));</span></span><br><span class="line">    JsonParser jsonParser3 = jsonFactory.createNonBlockingByteArrayParser();</span><br><span class="line"></span><br><span class="line">    System.out.println(jsonParser1);</span><br><span class="line">    <span class="comment">// System.out.println(jsonParser2);</span></span><br><span class="line">    System.out.println(jsonParser3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.fasterxml.jackson.core.json.ReaderBasedJsonParser@<span class="number">5f</span>3a4b84</span><br><span class="line">com.fasterxml.jackson.core.json.async.NonBlockingJsonParser@<span class="number">27f</span>723</span><br></pre></td></tr></table></figure>

<h3 id="创建非阻塞实例"><a href="#创建非阻塞实例" class="headerlink" title="创建非阻塞实例"></a>创建非阻塞实例</h3><p>值得注意的是，上面截图的11个方法中，最后一个并非重载。它创建的是一个非阻塞JSON解析器，也就是<code>NonBlockingJsonParser</code>，并且它还没有指定入参（数据源）。</p>
<p><code>NonBlockingJsonParser</code>是Jackson在<strong>2.9</strong>版本新增的的一个解析器，目标是进一步提升效率、性能。但它也有局限的地方：<strong>只能解析使用UTF-8编码的内容，否则抛出异常</strong>。</p>
<p>当然喽，现在UTF-8编码几乎成为了标准编码手段，问题不大。但是呢，我自己玩了玩<code>NonBlockingJsonParser</code>，发现复杂度增加不少（玩半天才玩明白😄），效果却并不显著，因此这里了解一下便可，至少目前不建议深入探究。</p>
<blockquote>
<p>小贴士：不管是Spring还是Redis的反序列化，使用的均是普通的解析器（阻塞IO）。因为JSON解析过程从来都不会是性能瓶颈（特殊场景除外）</p>
</blockquote>
<h2 id="JsonFactory的Feature"><a href="#JsonFactory的Feature" class="headerlink" title="JsonFactory的Feature"></a>JsonFactory的Feature</h2><p>除了JsonGenerator和JsonParser有Feature来控制行为外，JsonFactory也有自己的Feature特征，来控制<strong>自己的</strong>行为，可以理解为它对读/写均生效。</p>
<p>同样的也是一个内部枚举类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Feature &#123;</span><br><span class="line">	INTERN_FIELD_NAMES(<span class="keyword">true</span>),</span><br><span class="line">	CANONICALIZE_FIELD_NAMES(<span class="keyword">true</span>),</span><br><span class="line">	FAIL_ON_SYMBOL_HASH_OVERFLOW(<span class="keyword">true</span>),</span><br><span class="line">	USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING(<span class="keyword">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小贴士：枚举值均为bool类型，括号内为默认值</p>
</blockquote>
<p>每个枚举值都控制着JsonFactory不同的行为。</p>
<h4 id="INTERN-FIELD-NAMES-true"><a href="#INTERN-FIELD-NAMES-true" class="headerlink" title="INTERN_FIELD_NAMES(true)"></a>INTERN_FIELD_NAMES(true)</h4><p>这是Jackson所谓的key缓存：对JSON的<strong>字段名</strong>是否调用<code>String#intern</code>方法，放进字符串常量池里，以提高效率，默认是true。</p>
<blockquote>
<p>小贴士：Jackson在调用String#intern之前使用<code>InternCache</code>（继承自ConcurrentHashMap）挡了一层，以防止高并发条件下intern效果不显著问题</p>
</blockquote>
<p><strong>intern()方法的作用</strong>这个老生常谈的话题了，解释为：当调用intern方法时，如果字符串池已经包含一个等于此String对象的字符串(内容相等)，则返回池中的字符串。否则，将此 String放进池子里。下面写个例子增加感受感受：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String str1 = <span class="string">"a"</span>;</span><br><span class="line">    String str2 = <span class="string">"b"</span>;</span><br><span class="line">    String str3 = <span class="string">"ab"</span>;</span><br><span class="line">    String str4 = str1 + str2;</span><br><span class="line">    String str5 = <span class="keyword">new</span> String(<span class="string">"ab"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(str5.equals(str3)); <span class="comment">// true</span></span><br><span class="line">    System.out.println(str5 == str3); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// str5.intern()去常量池里找到了ab，所以直接返回常量池里的地址值了，因此是true</span></span><br><span class="line">    System.out.println(str5.intern() == str3); <span class="comment">// true</span></span><br><span class="line">    System.out.println(str5.intern() == str4); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可想而知，开启这个小功能的意义还是蛮大的。因为同一个格式的JSON串被多次解析的可能性是非常之大的，想想你的Rest API接口，被调用多少次就会进行了多少次JSON解析（想想高并发场景）。这是一种用<strong>空间换时间</strong>的思想，所以小小功能，大大能量。</p>
<blockquote>
<p>小贴士：如果你的应用对内存很敏感，你可以关闭此特征。但，真的有这种应用吗？有吗？</p>
</blockquote>
<p><strong>值得注意的是：此特征必须是<code>CANONICALIZE_FIELD_NAMES</code>也为true（开启）的情况下才有效，否则是无效的。</strong></p>
<h4 id="CANONICALIZE-FIELD-NAMES-true"><a href="#CANONICALIZE-FIELD-NAMES-true" class="headerlink" title="CANONICALIZE_FIELD_NAMES(true)"></a>CANONICALIZE_FIELD_NAMES(true)</h4><p>是否需要规范化属性名。所谓的规范化处理，就是去字符串池里尝试找一个字符串出来，默认值为true。规范化借助的是<code>ByteQuadsCanonicalizer</code>去处理，简而言之会根据Hash值来计算每个属性名存放的位置~</p>
<blockquote>
<p>小贴士：ByteQuadsCanonicalizer拥有一套优秀的Hash算法来规范化属性存储，提高效率，抵御攻击（见下特征）</p>
</blockquote>
<p>此特征开启了，<code>INTERN_FIELD_NAMES</code>特征的开启才有意义~</p>
<h4 id="FAIL-ON-SYMBOL-HASH-OVERFLOW-true"><a href="#FAIL-ON-SYMBOL-HASH-OVERFLOW-true" class="headerlink" title="FAIL_ON_SYMBOL_HASH_OVERFLOW(true)"></a>FAIL_ON_SYMBOL_HASH_OVERFLOW(true)</h4><p>当<code>ByteQuadsCanonicalizer</code>处理hash碰撞达到一个阈值时，是否快速失败。</p>
<p>什么时候能达到阈值？官方的说明是：若触发了阈值，这<strong>基本可以确定</strong>是Dos（denial-of-service）攻击，制造了<strong>非常多</strong>的相同Hash值的key，这在正常情况下几乎是没有发生的可能性的。</p>
<p>所以，开启此特征值，可以防止攻击，在提高性能的同时也确保了安全。</p>
<h4 id="USE-THREAD-LOCAL-FOR-BUFFER-RECYCLING-true"><a href="#USE-THREAD-LOCAL-FOR-BUFFER-RECYCLING-true" class="headerlink" title="USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING(true)"></a>USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING(true)</h4><p>是否使用<code>BufferRecycler、ThreadLocal、SoftReference</code>来有效的<strong>重用</strong>底层的输入/输出缓冲区。这个特性在后端服务（JavaEE）环境下是很有意义的，提效明显。但是对于在Android环境下就不见得了~</p>
<p>总而言之言而总之，JsonFactory的这几个特征值都<strong>建议开启</strong>，也就是维持默认即可。</p>
<h2 id="定制读-写实例"><a href="#定制读-写实例" class="headerlink" title="定制读/写实例"></a>定制读/写实例</h2><p>读写行为的控制是通过各自的Feature来控制的，JsonFactory作为一个功能<strong>并非单一</strong>的工厂类，需要既能够定制化读JsonParser，也能定制化写JsonGenerator。</p>
<p>为此，对应的API它都提供了三份（一份定制化自己的Feature）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> JsonFactory <span class="title">enable</span><span class="params">(JsonFactory.Feature f)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> JsonFactory <span class="title">enable</span><span class="params">(JsonParser.Feature f)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> JsonFactory <span class="title">enable</span><span class="params">(JsonGenerator.Feature f)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> JsonFactory <span class="title">disable</span><span class="params">(JsonFactory.Feature f)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> JsonFactory <span class="title">disable</span><span class="params">(JsonParser.Feature f)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> JsonFactory <span class="title">disable</span><span class="params">(JsonGenerator.Feature f)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合二为一的Configure方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JsonFactory <span class="title">configure</span><span class="params">(JsonFactory.Feature f, <span class="keyword">boolean</span> state)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> JsonFactory <span class="title">configure</span><span class="params">(JsonParser.Feature f, <span class="keyword">boolean</span> state)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> JsonFactory <span class="title">configure</span><span class="params">(JsonGenerator.Feature f, <span class="keyword">boolean</span> state)</span></span>;</span><br></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String jsonStr = <span class="string">"&#123;\"age\":18, \"age\": 28 &#125;"</span>;</span><br><span class="line"></span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    factory.enable(JsonParser.Feature.STRICT_DUPLICATE_DETECTION);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (JsonParser jsonParser = factory.createParser(jsonStr)) &#123;</span><br><span class="line">        <span class="comment">// 使用factory定制将不生效</span></span><br><span class="line">        <span class="comment">// factory.enable(JsonParser.Feature.STRICT_DUPLICATE_DETECTION);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (jsonParser.nextToken() != JsonToken.END_OBJECT) &#123;</span><br><span class="line">            String fieldname = jsonParser.getCurrentName();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"age"</span>.equals(fieldname)) &#123;</span><br><span class="line">                jsonParser.nextToken();</span><br><span class="line">                System.out.println(jsonParser.getIntValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，抛出异常。证明特征开启成功，<strong>符合预期</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.fasterxml.jackson.core.JsonParseException: Duplicate field <span class="string">'age'</span></span><br><span class="line"> at [Source: (String)<span class="string">"&#123;"</span>age<span class="string">":18, "</span>age<span class="string">": 28 &#125;"</span>; line: <span class="number">1</span>, column: <span class="number">17</span>]</span><br></pre></td></tr></table></figure>

<p>在使用JsonFactory定制化读/写实例的时需要特别注意：请务必确保在<code>factory.createXXX()</code>之前配置好对应的Feature特征，若在实例创建好之后再弄的话，对<strong>已经创建的</strong>实例无效。</p>
<blockquote>
<p>小贴士：实例创建好后若你还想定制，可以使用实例<strong>自己的</strong>对应API操作</p>
</blockquote>
<h2 id="JsonFactoryBuilder"><a href="#JsonFactoryBuilder" class="headerlink" title="JsonFactoryBuilder"></a>JsonFactoryBuilder</h2><p>JsonFactory负责基类和实现类的双重任务，是比较重的，分离得也不彻底。同时，现在都2020年了，对于这种构建类工厂如果还不用Builder模式就现在太out了，书写起来也非常不便：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonFactory jsonFactory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    <span class="comment">// jsonFactory自己的特征</span></span><br><span class="line">    jsonFactory.enable(JsonFactory.Feature.INTERN_FIELD_NAMES);</span><br><span class="line">    jsonFactory.enable(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES);</span><br><span class="line">    jsonFactory.enable(JsonFactory.Feature.USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// JsonParser的特征</span></span><br><span class="line">    jsonFactory.enable(JsonParser.Feature.ALLOW_SINGLE_QUOTES);</span><br><span class="line">    jsonFactory.enable(JsonParser.Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// JsonGenerator的特征</span></span><br><span class="line">    jsonFactory.enable(JsonGenerator.Feature.QUOTE_FIELD_NAMES);</span><br><span class="line">    jsonFactory.enable(JsonGenerator.Feature.ESCAPE_NON_ASCII);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建读/写实例</span></span><br><span class="line">    <span class="comment">// jsonFactory.createParser(...);</span></span><br><span class="line">    <span class="comment">// jsonFactory.createGenerator(...);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>功能实现上没毛病，但总显得<strong>不够优雅</strong>。同时上面也说了：定制化操作一定得在create创建动作<strong>之前</strong>执行，这全靠程序员自行控制。</p>
<p>Jackson在<strong>2.10</strong>版本新增了一个<code>JsonFactoryBuilder</code>构件类，让我们能够基于builder模式优雅的构建出一个<code>JsonFactory</code>实例。</p>
<blockquote>
<p>小贴士：2.10版本是2019.09发布的</p>
</blockquote>
<p>比如上面例子的代码使用<code>JsonFactoryBuilder</code>可重构为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonFactory jsonFactory = <span class="keyword">new</span> JsonFactoryBuilder()</span><br><span class="line">            <span class="comment">// jsonFactory自己的特征</span></span><br><span class="line">            .enable(INTERN_FIELD_NAMES)</span><br><span class="line">            .enable(CANONICALIZE_FIELD_NAMES)</span><br><span class="line">            .enable(USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING)</span><br><span class="line">            <span class="comment">// JsonParser的特征</span></span><br><span class="line">            .enable(ALLOW_SINGLE_QUOTES, ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER)</span><br><span class="line">            <span class="comment">// JsonGenerator的特征</span></span><br><span class="line">            .enable(QUOTE_FIELD_NAMES, ESCAPE_NON_ASCII)</span><br><span class="line"></span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建读/写实例</span></span><br><span class="line">    <span class="comment">// jsonFactory.createParser(...);</span></span><br><span class="line">    <span class="comment">// jsonFactory.createGenerator(...);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比起来，使用Builder模式优雅太多了。</p>
<p>因为JsonFactory是线程安全的，因此一般情况下全局我们只需要一个JsonFactory实例即可，推荐使用<code>JsonFactoryBuilder</code>去完成你的构建。</p>
<blockquote>
<p>小贴士：使用JsonFactoryBuilder确保你的Jackson版本至少是2.10版本哦~</p>
</blockquote>
<h2 id="SPI方式"><a href="#SPI方式" class="headerlink" title="SPI方式"></a>SPI方式</h2><p>从源码包里发现，JsonFactory是支持Java SPI方式构建实例的。<br><img data-src="https://img-blog.csdnimg.cn/20200725183005272.png" alt=""><br>文件内容为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.fasterxml.jackson.core.JsonFactory</span><br></pre></td></tr></table></figure>
<p>因此，我可以使用Java SPI的方式得到一个JsonFactory实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ServiceLoader&lt;JsonFactory&gt; jsonFactories = ServiceLoader.load(JsonFactory<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(jsonFactories.iterator().next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，妥妥的输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.fasterxml.jackson.core.JsonFactory@<span class="number">4</span>abdb505</span><br></pre></td></tr></table></figure>
<p>这种方式，<strong>玩玩即可</strong>，在这里没实际用途。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文围绕JsonFactory工厂为核心，讲解了它是如何创建、定制读/写实例的。对于自己的实例的创建共有三种方式：</p>
<ol>
<li>直接new实例</li>
<li>使用<code>JsonFactoryBuilder</code>构建（需要2.10或以上版本）</li>
<li>SPI方式创建实例</li>
</ol>
<p>其中<strong>方式2</strong>是被推荐的，如果你的版本较低，就老老实实使用方式1呗。至于方式3嘛，玩玩就行，别当真。</p>
<p>至此，jackson-core的三大核心内容：<code>JsonGenerator、JsonParser、JsonFactory</code>全部介绍完了，它们是jackson <strong>其它所有模块</strong> 的基石，需要掌握扎实喽。</p>
<p>下篇文章更有意思，会分析Jackson里Feature机制的设计，使用<strong>补码、掩码</strong>来实现是高效的体现，同时设计上也非常优美，下文见。</p>
<h5 id="相关推荐："><a href="#相关推荐：" class="headerlink" title="相关推荐："></a>相关推荐：</h5><ul>
<li><a href="https://mp.weixin.qq.com/s/z6T9n9YvwjmDwuj-YTa0_w" target="_blank" rel="noopener">Fastjson到了说再见的时候了</a></li>
<li><a href="https://mp.weixin.qq.com/s/iqSN4HUoIdX0kGcSdnD7EA" target="_blank" rel="noopener">1. 初识Jackson – 世界上最好的JSON库</a></li>
<li><a href="https://mp.weixin.qq.com/s/p6cwP2BVrC8VxkN-T3uAxg" target="_blank" rel="noopener">2. 妈呀，Jackson原来是这样写JSON的</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZHb3P06IC4xElHwJqDepxw" target="_blank" rel="noopener">3. 懂了这些，方敢在简历上说会用Jackson写JSON</a></li>
<li><a href="https://mp.weixin.qq.com/s/syAOETfEawiGItaQO35mLA" target="_blank" rel="noopener">4. JSON字符串是如何被解析的？JsonParser了解一下</a></li>
</ul>]]></content>
      <categories>
        <category>A哥学Jackson</category>
      </categories>
      <tags>
        <tag>Jackson</tag>
        <tag>JSON</tag>
        <tag>JsonFactory</tag>
      </tags>
  </entry>
  <entry>
    <title>IntelliJ IDEA 2020.2正式发布，诸多亮点总有几款能助你提效</title>
    <url>/x2y/c21d2a8e.html</url>
    <content><![CDATA[<blockquote>
<p>向工具人致敬。本文已被 <a href="https://www.yourbatman.cn"><strong>https://www.yourbatman.cn</strong></a> 收录，里面一并有Spring技术栈、MyBatis、JVM、中间件等小而美的<strong>专栏</strong>供以免费学习。关注公众号【<strong>BAT的乌托邦</strong>】逐个击破，深入掌握，拒绝浅尝辄止。</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20200729184018857.png" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>各位小伙伴大家好，我是A哥。IDEA上个较大版本的发布，要追溯到4月份了：<br><img data-src="https://img-blog.csdnimg.cn/20200729132634729.png" alt=""><br>时隔近4个月，北京时间2020-07-28深夜，<code>IntelliJ IDEA</code>再迎更新，这是2020年的第二个里程碑版本。</p>
<p>之前提到过，2020年是<code>Jetbrain公司</code>的20周年（小伙子长成大男孩了），有理由相信官方会立些Flag。所以自从官方在2020-01-20发布了其<strong>2020年的Roadmap</strong>后，我个人是有保持持续关注的，毕竟一方面是公司20周年，另一方面是21世纪的“新10年”，这么好的契机很适合搞事情。</p>
<p>上个版本（2020.1）发布后，带来了众多实用新特性，比如：<strong>中文支持、禅模式、Javadoc渲染</strong>等等，某些新功能可以显著提高效率，因此反响是一片叫好。无独有偶，作为2020年的第二个里程碑版本，它能给我们带来什么样的期许呢？</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>按照惯例，来一张最新版IDEA启动图尝尝鲜：<br><img data-src="https://img-blog.csdnimg.cn/20200729133934485.png" alt=""><br>我把<strong>2020.1</strong>版本启动图也扔在这供你对比，哪个更好看？</p>
<p><img data-src="https://img-blog.csdnimg.cn/2020041022460850.png" alt=""></p>
<h2 id="what’s-new（新特性）"><a href="#what’s-new（新特性）" class="headerlink" title="what’s new（新特性）"></a>what’s new（新特性）</h2><p>IntelliJ IDEA 2020.2做的改进重点体现在<strong>完全控制GitHub请求</strong>，包括在IDE中审查、合并 GitHub PR等。同时还提供了对Java15、Jakarta EE 9的支持，还包括Quarkus、microaut等等。</p>
<h3 id="1、支持Java-15"><a href="#1、支持Java-15" class="headerlink" title="1、支持Java 15"></a>1、支持Java 15</h3><p>尽管Java 15将在9月发布，IntelliJ IDEA 2020.2已经提前为此做好了准备，反应不可为不灵活，给个大大的赞👍。</p>
<blockquote>
<p>说明：Java 15新特性啥的本文不提，毕竟这不是本文关注点所在</p>
</blockquote>
<p>题外话：<strong>从JDK9之后</strong>，Oracle采用了新的发布周期：每6个月发布一个版本，每3年发布一个LTS版本。JDK15是继JDK9之后发布的第七个版本， 该版本依旧为非LTS版本，最新的LTS版本为JDK11（JDK17还未发布）。<br><img data-src="https://img-blog.csdnimg.cn/20200729135501542.png" alt=""></p>
<h3 id="2、相关问题内嵌提示"><a href="#2、相关问题内嵌提示" class="headerlink" title="2、相关问题内嵌提示"></a>2、相关问题内嵌提示</h3><p>这个功能非常好用，特别对有些不使用<code>RENAME</code>功能的小伙伴来说是福音。</p>
<p>如果您通过更改具有<strong>外部使用</strong>的类、方法或字段的签名而引入了编译错误，IDE将用<strong>镶嵌提示</strong>通知您。单击相关嵌入提示，IDE将自动帮你打开Find工具窗口，列出了在外部文件中发生的所有相关问题。</p>
<p>看完这段话是不是还有点蒙，来吧，A哥给你准备了示例：</p>
<p>Person.java文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"SUCCESS"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Demo.java文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Person().eat(<span class="string">"大鱼"</span>);</span><br><span class="line">        <span class="keyword">new</span> Person().eat(<span class="string">"大肉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时编译肯定一切正常。现在我做出改变：更改Person类的<code>eat()</code>方法名为<code>eatDish()</code>，结果如下图：<br><img data-src="https://img-blog.csdnimg.cn/20200729152511552.png" alt=""><br>鼠标单击提示，自动帮你打开Find框且定位到问题所在：<br><img data-src="https://img-blog.csdnimg.cn/20200729152615381.png" alt=""><br>就问你，这个功能爽不爽，实用不实用？</p>
<blockquote>
<p>小贴士：在同一个<code>.java</code>文件内（即使是不同class），是不会类似提示的哦</p>
</blockquote>
<h3 id="3、运行时异常原因分析"><a href="#3、运行时异常原因分析" class="headerlink" title="3、运行时异常原因分析"></a>3、运行时异常原因分析</h3><p>一听这个功能名称，就觉得很厉害。快速定位问题一直是程序员的痛点，现在让工具来辅助你完成，效率更上一层楼。</p>
<p>新版IDEA为异常堆栈跟踪分析添加了数据流分析。点击堆栈跟踪时，IDE 可能会将您带到代码中出现异常的确切位置，并<strong>提供建议</strong>来帮助您了解发生此错误的原因。</p>
<p>下面用一个NPE异常作为示例感受一把，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer i = <span class="keyword">null</span>;</span><br><span class="line">    System.out.println(i.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，抛出异常，控制台显示：<br><img data-src="https://img-blog.csdnimg.cn/20200729153158227.png" alt=""><br>如红框所示，IDEA给出的建议是让我们创建一个断点，单击此“按钮”即弹出断点创建对话框：<br><img data-src="https://img-blog.csdnimg.cn/20200729153310506.png" alt=""><br>不得不说，真的是方便了很多。</p>
<p><strong>附</strong>：老版本中效果截图，用以对比：<br><img data-src="https://img-blog.csdnimg.cn/20200729153456509.png" alt=""></p>
<h3 id="4、更好Stream-API自动补全"><a href="#4、更好Stream-API自动补全" class="headerlink" title="4、更好Stream API自动补全"></a>4、更好Stream API自动补全</h3><p><strong>Stream API</strong>在开发中太太太常用了，因此哪怕只是更智能一丁点的，带来的效率提升都可谓是大大的。</p>
<p>可以直接在<strong>集合或数组</strong>中直接输入Stream API方法名，IDEA 会自动插入 <code>stream()</code>。这适用于任何流操作（map、reduce、collect等所有操作都行）。</p>
<blockquote>
<p>话外音：以后你就不用自己的手动的多写一步<code>stream()</code>了，开不开森</p>
</blockquote>
<p>话不多说，来个栗子：<br><img data-src="https://img-blog.csdnimg.cn/20200729154009816.png" alt=""><br><img data-src="https://img-blog.csdnimg.cn/20200729154050630.png" alt=""></p>
<p><strong>附</strong>：老版本中效果截图，用以对比：很明显根本就不支持嘛<br><img data-src="https://img-blog.csdnimg.cn/2020072915421223.png" alt=""></p>
<h3 id="5、Live-Templates新增Java分组"><a href="#5、Live-Templates新增Java分组" class="headerlink" title="5、Live Templates新增Java分组"></a>5、Live Templates新增Java分组</h3><p>相信这是很多小伙伴一直以来的一个痛点，毕竟咱们都是Java程序员，使用<code>Live Templates</code>几乎100%都是针对于Java代码的，然后老版本竟然还<strong>没有</strong>个Java分组，实在难受，我还记得我刚开始使用IDEA时就默默吐槽了这点。</p>
<p>现在好了，这个版本终于补上喽：<br><img data-src="https://img-blog.csdnimg.cn/2020072915550291.png" alt=""></p>
<blockquote>
<p>小贴士：你之前放在自定义分组里的还在那，不会给你自动挪过来的</p>
</blockquote>
<p><strong>附</strong>：老版本中效果截图，用以对比：JavaScript分组都有竟然没有Java分组，服气<br><img data-src="https://img-blog.csdnimg.cn/20200729155623917.png" alt=""><br>特别强调：此窗口是新增的，老版本并无此能力，也并无此窗口。所以，升吗？🙂</p>
<h3 id="6、新增Problems窗口"><a href="#6、新增Problems窗口" class="headerlink" title="6、新增Problems窗口"></a>6、新增Problems窗口</h3><p>此版本新增了一个Problems窗口，简直不要太赞。</p>
<p>显示<strong>与当前文件有关</strong>的警告和错误以及问题描述。在此工具窗口中，可以右键点击问题导航到遇到问题的代码行，方便你逐个修复。<br><img data-src="https://img-blog.csdnimg.cn/20200729160254928.png" alt=""><br>另外，它在文件<strong>右上角</strong>还有问题总数、上/下导航按钮，可谓非常贴心：<br><img data-src="https://img-blog.csdnimg.cn/20200729160353542.png" alt=""></p>
<h3 id="7、操作意图预览"><a href="#7、操作意图预览" class="headerlink" title="7、操作意图预览"></a>7、操作意图预览</h3><p>咋一看还以为人工智能呢，都能预览我的意图了。</p>
<p>此功能可以让你在将它们实际应用到代码<strong>之前</strong>预览它们的结果。按<code>Alt+Enter</code>调用显示上下文动作并选择你需要的意图动作，然后按相应快捷键显示结果预览（Windows和Linux上按Ctrl+Shift+I，macOS上按Alt+Space）。</p>
<p>例如如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ids = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (Integer id : ids) &#123;</span><br><span class="line">        <span class="keyword">if</span> (id &gt; <span class="number">10</span>) &#123;</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在for处按<code>Alt+Enter</code>：<br><img data-src="https://img-blog.csdnimg.cn/20200729162027506.png" alt=""><br>再按<code>Ctrl+Shift+I</code>（我是windows），即可看见结果预览：<br><img data-src="https://img-blog.csdnimg.cn/20200729162119946.png" alt=""></p>
<h3 id="8、改进的拼写检查"><a href="#8、改进的拼写检查" class="headerlink" title="8、改进的拼写检查"></a>8、改进的拼写检查</h3><p>IDEA使用spell checker做拼写检查，看你单词也没有写错啥的。这次改进主要提升了性能和准确性，然而我一般都是把此项禁用的，毕竟有时候我需要用拼音命名😄。</p>
<h3 id="9、完整的GitHub-pull-requests支持"><a href="#9、完整的GitHub-pull-requests支持" class="headerlink" title="9、完整的GitHub pull requests支持"></a>9、完整的GitHub pull requests支持</h3><p>现在整个 GitHub PR 工作流程全部可以<strong>直接在</strong> IntelliJ IDEA 完成。包括浏览、指派、管理以及合并 PR、查看时间线和内联评论、提交评论、审查以及接受更改。</p>
<p>简单点，我就不用实际案例了。引用官方提供的三张图作为示例了哈：<br><img data-src="https://img-blog.csdnimg.cn/20200729163406501.png" alt=""><br><img data-src="https://img-blog.csdnimg.cn/20200729163414845.png" alt=""><br><img data-src="https://img-blog.csdnimg.cn/20200729163423792.png" alt=""><br>我想说，这个功能区，对做Java开源社区开发的工作者绝对是<strong>福音</strong>，可以多睡会了~</p>
<h3 id="10、改进的Git操作对话框"><a href="#10、改进的Git操作对话框" class="headerlink" title="10、改进的Git操作对话框"></a>10、改进的Git操作对话框</h3><p>主要体现在<strong>merge、pull和rebase</strong>对话框的视觉一致性上。此外还改进了对话框，使其可以清楚地标识<strong>待执行</strong>的 Git 命令，并加入一些缺失选项，比如向Pull和 Merge对话框<strong>分别</strong>添加了<code>--rebase</code>和<code>--no-verify</code>。<br><img data-src="https://img-blog.csdnimg.cn/20200729164202515.png" alt=""></p>
<p><strong>附</strong>：老版本中效果截图，用以对比：<br><img data-src="https://img-blog.csdnimg.cn/20200729181509932.png" alt=""></p>
<h3 id="11、支持Jakarta-EE-9"><a href="#11、支持Jakarta-EE-9" class="headerlink" title="11、支持Jakarta EE 9"></a>11、支持Jakarta EE 9</h3><p>Jakarta EE 9同Java 15一样也将会在今年9月份发布，但IDEA已早早的提供了支持。并且号称是已经支持到了Jakarta EE的所有可用特性（典型的13种技术嘛）。</p>
<p>题外话：2018年3月初，Java EE正式更名为JakartaEE，<strong>至此再无 JavaEE</strong>。<br><img data-src="https://img-blog.csdnimg.cn/20200729165154694.png" alt=""></p>
<h3 id="12、创建企业项目向导"><a href="#12、创建企业项目向导" class="headerlink" title="12、创建企业项目向导"></a>12、创建企业项目向导</h3><p>如果需要创建Java EE 8或Jakarta EE 9项目，可以使用IDEA的创建向导。<br><img data-src="https://img-blog.csdnimg.cn/20200729165437160.png" alt=""><br><img data-src="https://img-blog.csdnimg.cn/20200729165447970.png" alt=""><br>这对于天朝的程序员来说貌似没啥卵用，因为我们都用Spring，所以大都使用<code>Spring Initializr</code>来创建工程。</p>
<h3 id="12、HPROF内存查看器"><a href="#12、HPROF内存查看器" class="headerlink" title="12、HPROF内存查看器"></a>12、HPROF内存查看器</h3><p>我们知道IntelliJ IDEA 2020.1版本就可以打开<code>.hprof</code>内存转储文件，有助于识别内存泄漏，并找到优化内存使用率的方法。那时候功能还非常的简陋，IDEA官方承诺会持续改进的，果不其然这个版本带来了功能提升。</p>
<p>下面通过案例使用一把。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ids = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    TimeUnit.MINUTES.sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先使用jps找到你的进程id（这个都会吧，我就不截图了），然后使用<code>jmap -dump:file=test.hprof,format=b 你的pid</code>拿到一份dump文件：<code>test.hprof</code>。<br><img data-src="https://img-blog.csdnimg.cn/202007291706323.png" alt=""><br>然后使用IDEA的此功能把该文件读取进来：<br><img data-src="https://img-blog.csdnimg.cn/20200729170657377.png" alt=""><br>文件读取进来后，可在其“专属视窗”看到分析结果：<br><img data-src="https://img-blog.csdnimg.cn/20200729170859587.png" alt=""></p>
<p>指出使用大量内存的代码部分，并检测内存泄漏的原因。HPROF内存查看器显示了计算的对象保留大小、到垃圾收集器根的最短路径、对象(保留的对象)的支配器树和传入的引用。</p>
<p><strong>附</strong>：上个版本（2020.1）效果截图，用以对比：<br><img data-src="https://img-blog.csdnimg.cn/20200411011115802.png" alt=""><br>新版本还是感觉到明显的<strong>功能提升</strong>的。上个版本官方不建议你用于生产分析，很明显这个版本已经没有这样的字眼了，用吧骚年。</p>
<h3 id="12、使用预先构建好的indexes"><a href="#12、使用预先构建好的indexes" class="headerlink" title="12、使用预先构建好的indexes"></a>12、使用预先构建好的indexes</h3><p>IDEA在每打开一个项目时都会它进行index建立索引，以确保你后续时候过程中的编码流畅度（代码补全、代码跳转…），而这个建立索引阶段一般来说是比较耗时的。</p>
<p>同一个项目一般会被N多人使用、开发，那么能不能只需要构建<strong>一次</strong>索引，别人直接用就行了呢？IDEA此版本对此痛点提供了支持。</p>
<p>现在，通过在<strong>另一台机器</strong>上生成的索引（我们可以弄台机器专门来生成索引），而不用再在本地构建，索引文件拿来就用，可以加快索引速度。</p>
<blockquote>
<p>小贴士：此功能需要安装共享索引<strong>插件</strong>提供额外支持</p>
</blockquote>
<h3 id="13、正在索引中也可编码"><a href="#13、正在索引中也可编码" class="headerlink" title="13、正在索引中也可编码"></a>13、正在索引中也可编码</h3><p>当我们打开一个项目时，如果正在构建索引，代码的颜色是这样的（预示先别编码，请等待）：<br><img data-src="https://img-blog.csdnimg.cn/20200729171750615.png" alt=""><br>说明：颜色灰色并不是说你不能敲字，只是没有代码提示了</p>
<p>索引构建好后，颜色恢复正常，你可以正常编码了：<br><img data-src="https://img-blog.csdnimg.cn/20200729171930276.png" alt=""></p>
<p>然后在IntelliJ IDEA 2020.2版本中，当在为你的项目构建索引时，你现在可以<strong>继续</strong>编写代码了。IDE现在能在索引期间为Java提供代码完成建议（也就是最重要的代码补全提示能力）。</p>
<h3 id="14、支持Maven-Wrapper"><a href="#14、支持Maven-Wrapper" class="headerlink" title="14、支持Maven Wrapper"></a>14、支持Maven Wrapper</h3><p>IntelliJ IDEA 2020.2现在支持Maven包装器，它会自动将所需的Maven版本安装到您的项目中。如果提供并配置了Maven包装器，IDE会自动使用它并在需要时导入更改。</p>
<p>Maven Wrapper（Maven包装器）是什么？嗯嗯，建议你可以自己了解一下了~</p>
<h3 id="15、其它"><a href="#15、其它" class="headerlink" title="15、其它"></a>15、其它</h3><p>其它的还有诸如对<code>JavaScript</code>语言的代码自动补全支持、Database链接数据库的UI/功能优化、Scala语言支持等，因为用的人着实不多（主要是我自己也不用😄），所以就不做详解了哈。</p>
<p>当然喽，新版IDEA怎么少得了对云原生技术<code>Docker</code>和<code>Kubernetes</code>的优化支持呢？这些主要体现在对它们配置文件的支持上，在实际使用时你会感受出来。</p>
<h2 id="升级建议"><a href="#升级建议" class="headerlink" title="升级建议"></a>升级建议</h2><p><strong>升</strong>。</p>
<blockquote>
<p>以前我的建议很保守，现在明确点，毕竟仅仅只是建议😄</p>
</blockquote>
<h2 id="关于破解"><a href="#关于破解" class="headerlink" title="关于破解"></a>关于破解</h2><p>如果你是付费党（土豪），或者是开源committer，或者是edu邮箱拥有者，请忽略此part哈。</p>
<ul>
<li><p>若你升级到了<code>2020.2</code>最新版本，你可以享有这些新特性功能，提升编码效率。但是，<strong>暂时</strong>破解没戏，这不我也试用着呢（就不信1个月后还不能破解😄）：<br><img data-src="https://img-blog.csdnimg.cn/20200729182720118.png" alt=""></p>
</li>
<li><p>若你仍决定停留在<code>2020.1</code>甚至之前版本，那么是可以实现破解的。<strong>破解方式可在公众号后台回复“IDEA破解”获得</strong>，白嫖去吧~</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>作为2020年的第二个版本，虽然说没有第一个版本（2020.1）提供的新功能那么的博人眼球，但好些新特性依旧是可圈可点，值得称赞。</p>
<p>最后，依旧要向那些孜孜不倦为IT行业提供优秀工具的人们致敬！！！特别是捷克的那些创造者们，你们创造了非常好的工具提高了生产力，<strong>推动了社会某些产业的进步，功勋卓越！！！</strong></p>
<h5 id="推荐你看："><a href="#推荐你看：" class="headerlink" title="推荐你看："></a>推荐你看：</h5><ul>
<li><a href="https://mp.weixin.qq.com/s/z6T9n9YvwjmDwuj-YTa0_w" target="_blank" rel="noopener">Fastjson到了说再见的时候了</a></li>
<li><a href="https://mp.weixin.qq.com/s/iqSN4HUoIdX0kGcSdnD7EA" target="_blank" rel="noopener">1. 初识Jackson – 世界上最好的JSON库</a></li>
<li><a href="https://mp.weixin.qq.com/s/p6cwP2BVrC8VxkN-T3uAxg" target="_blank" rel="noopener">2. 妈呀，Jackson原来是这样写JSON的</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZHb3P06IC4xElHwJqDepxw" target="_blank" rel="noopener">3. 懂了这些，方敢在简历上说会用Jackson写JSON</a></li>
<li><a href="https://mp.weixin.qq.com/s/syAOETfEawiGItaQO35mLA" target="_blank" rel="noopener">4. JSON字符串是如何被解析的？JsonParser了解一下</a></li>
<li><a href="https://mp.weixin.qq.com/s/0ZaDYb_ueFLbvOf3FbetfQ" target="_blank" rel="noopener">5. JsonFactory工厂而已，还蛮有料，这是我没想到的</a></li>
</ul>]]></content>
      <categories>
        <category>新特性</category>
      </categories>
      <tags>
        <tag>IntelliJ IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>4. JSON字符串是如何被解析的？JsonParser了解一下</title>
    <url>/x2y/a47cf2f7.html</url>
    <content><![CDATA[<blockquote>
<p>公司不是你家，领导不是你妈。本文已被 <a href="https://www.yourbatman.cn"><strong>https://www.yourbatman.cn</strong></a> 收录，里面一并有Spring技术栈、MyBatis、JVM、中间件等小而美的<strong>专栏</strong>供以免费学习。关注公众号【<strong>BAT的乌托邦</strong>】逐个击破，深入掌握，拒绝浅尝辄止。</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20200725140936285.png" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>各位好，我是A哥(YourBatman)。上篇文章：<a href="https://mp.weixin.qq.com/s/ZHb3P06IC4xElHwJqDepxw" target="_blank" rel="noopener">3. 懂了这些，方敢在简历上说会用Jackson写JSON</a>  聊完，<strong>流式API</strong>的写部分可以认为你已完全掌握了，本文了解它读的部分。<br><img data-src="https://img-blog.csdnimg.cn/20200723180943213.png" alt=""></p>
<h2 id="版本约定"><a href="#版本约定" class="headerlink" title="版本约定"></a>版本约定</h2><ul>
<li>Jackson版本：<code>2.11.0</code></li>
<li>Spring Framework版本：<code>5.2.6.RELEASE</code></li>
<li>Spring Boot版本：<code>2.3.0.RELEASE</code></li>
</ul>
<blockquote>
<p>小贴士：截止到本文，本系列<strong>前面</strong>所有示例都只仅仅导入<code>jackson-core</code>而已，后续若要新增jar包我会额外说明，否则相同</p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>什么叫读JSON？就是把一个JSON <strong>字符串</strong> 解析为对象or树模型嘛，因此也称作解析JSON串。Jackson底层流式API使用<code>JsonParser</code>来完成<strong>JSON字符串</strong>的解析。</p>
<h2 id="最简使用Demo"><a href="#最简使用Demo" class="headerlink" title="最简使用Demo"></a>最简使用Demo</h2><p>准备一个POJO：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例：把一个JSON字符串绑定（封装）进一个POJO对象里</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String jsonStr = <span class="string">"&#123;\"name\":\"YourBatman\",\"age\":18&#125;"</span>;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    <span class="keyword">try</span> (JsonParser jsonParser = factory.createParser(jsonStr)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 只要还没结束"&#125;"，就一直读</span></span><br><span class="line">        <span class="keyword">while</span> (jsonParser.nextToken() != JsonToken.END_OBJECT) &#123;</span><br><span class="line">            String fieldname = jsonParser.getCurrentName();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"name"</span>.equals(fieldname)) &#123;</span><br><span class="line">                jsonParser.nextToken();</span><br><span class="line">                person.setName(jsonParser.getText());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"age"</span>.equals(fieldname)) &#123;</span><br><span class="line">                jsonParser.nextToken();</span><br><span class="line">                person.setAge(jsonParser.getIntValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person(name=YourBatman, age=<span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<p>成功把一个JSON字符串的值解析到Person对象。你可能会疑问，怎么这么麻烦？那当然，这是底层流式API，纯<strong>手动档</strong>嘛。你获得了性能，可不要失去一些便捷性嘛。</p>
<blockquote>
<p>小贴士：底层流式API一般面向“专业人士”，应用级开发使用高阶API <code>ObjectMapper</code>即可。当然，读完本系列就能让你完全具备“专业人士”的实力😄</p>
</blockquote>
<p><code>JsonParser</code>针对不同的value类型，提供了非常多的方法用于实际值的获取。</p>
<p><strong>直接</strong>值获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取字符串类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getText</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字Number类型值 标量值（支持的Number类型参照NumberType枚举）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Number <span class="title">getNumberValue</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> NumberType &#123;</span><br><span class="line">    INT, LONG, BIG_INTEGER, FLOAT, DOUBLE, BIG_DECIMAL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getIntValue</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">getLongValue</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span>[] getBinaryValue(Base64Variant bv) <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>
<p>这类方法可能会抛出异常：比如value值本不是数字但你调用了getInValue()方法~</p>
<blockquote>
<p>小贴士：如果value值是null，像getIntValue()、getBooleanValue()等这种直接获取方法是会抛出异常的，但getText()不会</p>
</blockquote>
<p><strong>带默认值</strong>的值获取，具有更好安全性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getValueAsString</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getValueAsString(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getValueAsString</span><span class="params">(String def)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getValueAsLong</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getValueAsLong(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">getValueAsLong</span><span class="params">(<span class="keyword">long</span> def)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>此类方法若碰到数据的转换失败时，<strong>不会抛出异常</strong>，把<code>def</code>作为默认值返回。</p>
<h3 id="组合方法"><a href="#组合方法" class="headerlink" title="组合方法"></a>组合方法</h3><p>同<code>JsonGenerator</code>一样，JsonParser也提供了<strong>高钙片</strong>组合方法，让你更加便捷的使用。<br><img data-src="https://img-blog.csdnimg.cn/20200725133407278.png" alt=""></p>
<h3 id="自动绑定"><a href="#自动绑定" class="headerlink" title="自动绑定"></a>自动绑定</h3><p>听起来像高级功能，是的，它必须依赖于<code>ObjectCodec</code>去实现，因为实际是全部委托给了它去完成的，也就是我们最为熟悉的readXXX系列方法：<br><img data-src="https://img-blog.csdnimg.cn/20200724154538278.png" alt=""><br>我们知道，ObjectMapper就是一个ObjectCodec，它属于高级API，本文显然不会用到ObjectMapper它喽，因此我们自己手敲一个实现来完成此功能。</p>
<p>自定义一个ObjectCodec，Person类专用：用于把JSON串自动绑定到实例属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonObjectCodec</span> <span class="keyword">extends</span> <span class="title">ObjectCodec</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(JsonParser jsonParser, Class&lt;T&gt; valueType)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Person person = (Person) valueType.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只要还没结束"&#125;"，就一直读</span></span><br><span class="line">        <span class="keyword">while</span> (jsonParser.nextToken() != JsonToken.END_OBJECT) &#123;</span><br><span class="line">            String fieldname = jsonParser.getCurrentName();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"name"</span>.equals(fieldname)) &#123;</span><br><span class="line">                jsonParser.nextToken();</span><br><span class="line">                person.setName(jsonParser.getText());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"age"</span>.equals(fieldname)) &#123;</span><br><span class="line">                jsonParser.nextToken();</span><br><span class="line">                person.setAge(jsonParser.getIntValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (T) person;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了它，就可以实现我们的<strong>自动</strong>绑定了，书写测试用例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String jsonStr = <span class="string">"&#123;\"name\":\"YourBatman\",\"age\":18, \"pickName\":null&#125;"</span>;</span><br><span class="line"></span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    <span class="keyword">try</span> (JsonParser jsonParser = factory.createParser(jsonStr)) &#123;</span><br><span class="line">        jsonParser.setCodec(<span class="keyword">new</span> PersonObjectCodec());</span><br><span class="line"></span><br><span class="line">        System.out.println(jsonParser.readValueAs(Person<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person(name=YourBatman, age=<span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<p>这就是ObjectMapper自动绑定的核心原理所在，其它更为强大能力将在后续章节详细展开。</p>
<h2 id="JsonToken"><a href="#JsonToken" class="headerlink" title="JsonToken"></a>JsonToken</h2><p>在上例解析过程中，有一个非常重要的角色，那便是：JsonToken。它表示解析JSON内容时，用于返回结果的基本<strong>标记类型</strong>的枚举。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> JsonToken &#123;</span><br><span class="line">	NOT_AVAILABLE(<span class="keyword">null</span>, JsonTokenId.ID_NOT_AVAILABLE),</span><br><span class="line">	</span><br><span class="line">	START_OBJECT(<span class="string">"&#123;"</span>, JsonTokenId.ID_START_OBJECT),</span><br><span class="line">	END_OBJECT(<span class="string">"&#125;"</span>, JsonTokenId.ID_END_OBJECT),</span><br><span class="line">	START_ARRAY(<span class="string">"["</span>, JsonTokenId.ID_START_ARRAY),</span><br><span class="line">	END_ARRAY(<span class="string">"]"</span>, JsonTokenId.ID_END_ARRAY),</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 属性名（key）</span></span><br><span class="line">	FIELD_NAME(<span class="keyword">null</span>, JsonTokenId.ID_FIELD_NAME),</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 值（value）</span></span><br><span class="line">	VALUE_EMBEDDED_OBJECT(<span class="keyword">null</span>, JsonTokenId.ID_EMBEDDED_OBJECT),</span><br><span class="line">	VALUE_STRING(<span class="keyword">null</span>, JsonTokenId.ID_STRING),</span><br><span class="line">	VALUE_NUMBER_INT(<span class="keyword">null</span>, JsonTokenId.ID_NUMBER_INT),</span><br><span class="line">	VALUE_NUMBER_FLOAT(<span class="keyword">null</span>, JsonTokenId.ID_NUMBER_FLOAT),</span><br><span class="line">	VALUE_TRUE(<span class="string">"true"</span>, JsonTokenId.ID_TRUE),</span><br><span class="line">	VALUE_FALSE(<span class="string">"false"</span>, JsonTokenId.ID_FALSE),</span><br><span class="line">	VALUE_NULL(<span class="string">"null"</span>, JsonTokenId.ID_NULL),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了辅助理解，A哥用一个例子，输出各个部分一目了然：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String jsonStr = <span class="string">"&#123;\"name\":\"YourBatman\",\"age\":18, \"pickName\":null&#125;"</span>;</span><br><span class="line">    System.out.println(jsonStr);</span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    <span class="keyword">try</span> (JsonParser jsonParser = factory.createParser(jsonStr)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            JsonToken token = jsonParser.nextToken();</span><br><span class="line">            System.out.println(token + <span class="string">" -&gt; 值为:"</span> + jsonParser.getValueAsString());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (token == JsonToken.END_OBJECT) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"YourBatman"</span>,<span class="attr">"age"</span>:<span class="number">18</span>, <span class="attr">"pickName"</span>:<span class="literal">null</span>&#125;</span><br><span class="line">START_OBJECT -&gt; 值为:null</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FIELD_NAME -&gt; 值为:name</span><br><span class="line">VALUE_STRING -&gt; 值为:YourBatman</span><br><span class="line"></span><br><span class="line">FIELD_NAME -&gt; 值为:age</span><br><span class="line">VALUE_NUMBER_INT -&gt; 值为:18</span><br><span class="line"></span><br><span class="line">FIELD_NAME -&gt; 值为:pickName</span><br><span class="line">VALUE_NULL -&gt; 值为:null</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">END_OBJECT -&gt; 值为:null</span><br></pre></td></tr></table></figure>
<p><strong>从左至右</strong>解析，一一对应。各个部分用下面这张图可以简略表示出来：<br><img data-src="https://img-blog.csdnimg.cn/20200724140146351.png" alt=""></p>
<blockquote>
<p>小贴士：解析时请确保你的的JSON串是合法的，否则抛出<code>JsonParseException</code>异常</p>
</blockquote>
<h2 id="JsonParser的Feature"><a href="#JsonParser的Feature" class="headerlink" title="JsonParser的Feature"></a>JsonParser的Feature</h2><p>它是JsonParser的一个内部枚举类，共15个枚举值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Feature &#123;</span><br><span class="line">	AUTO_CLOSE_SOURCE(<span class="keyword">true</span>),</span><br><span class="line">	</span><br><span class="line">	ALLOW_COMMENTS(<span class="keyword">false</span>),</span><br><span class="line">	ALLOW_YAML_COMMENTS(<span class="keyword">false</span>),</span><br><span class="line">	ALLOW_UNQUOTED_FIELD_NAMES(<span class="keyword">false</span>),</span><br><span class="line">	ALLOW_SINGLE_QUOTES(<span class="keyword">false</span>),</span><br><span class="line">	<span class="meta">@Deprecated</span></span><br><span class="line">	ALLOW_UNQUOTED_CONTROL_CHARS(<span class="keyword">false</span>),</span><br><span class="line">	<span class="meta">@Deprecated</span></span><br><span class="line">	ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER(<span class="keyword">false</span>),</span><br><span class="line">	<span class="meta">@Deprecated</span></span><br><span class="line">	ALLOW_NUMERIC_LEADING_ZEROS(<span class="keyword">false</span>),</span><br><span class="line">	<span class="meta">@Deprecated</span></span><br><span class="line">	ALLOW_LEADING_DECIMAL_POINT_FOR_NUMBERS(<span class="keyword">false</span>),</span><br><span class="line">	<span class="meta">@Deprecated</span></span><br><span class="line">	ALLOW_NON_NUMERIC_NUMBERS(<span class="keyword">false</span>),</span><br><span class="line">	<span class="meta">@Deprecated</span></span><br><span class="line">	ALLOW_MISSING_VALUES(<span class="keyword">false</span>),</span><br><span class="line">	<span class="meta">@Deprecated</span></span><br><span class="line">	ALLOW_TRAILING_COMMA(<span class="keyword">false</span>),</span><br><span class="line">	</span><br><span class="line">	STRICT_DUPLICATE_DETECTION(<span class="keyword">false</span>),</span><br><span class="line">	IGNORE_UNDEFINED(<span class="keyword">false</span>),</span><br><span class="line">	INCLUDE_SOURCE_IN_LOCATION(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小贴士：枚举值均为bool类型，括号内为默认值</p>
</blockquote>
<p>每个枚举值都控制着<code>JsonParser</code>不同的行为。下面分类进行解释</p>
<h3 id="底层I-O流相关"><a href="#底层I-O流相关" class="headerlink" title="底层I/O流相关"></a>底层I/O流相关</h3><blockquote>
<p>自2.10版本后，使用<code>StreamReadFeature#AUTO_CLOSE_SOURCE</code>代替</p>
</blockquote>
<p>Jackson的流式API指的是I/O流，所以即使是<strong>读</strong>，底层也是用I/O流（Reader）去读取然后解析的。</p>
<h4 id="AUTO-CLOSE-SOURCE-true"><a href="#AUTO-CLOSE-SOURCE-true" class="headerlink" title="AUTO_CLOSE_SOURCE(true)"></a>AUTO_CLOSE_SOURCE(true)</h4><p>原理和JsonGenerator的<code>AUTO_CLOSE_TARGET(true)</code>一样，不再解释，详见<a href="https://mp.weixin.qq.com/s/ZHb3P06IC4xElHwJqDepxw" target="_blank" rel="noopener">上篇文章</a>对应部分。</p>
<h3 id="支持非标准格式"><a href="#支持非标准格式" class="headerlink" title="支持非标准格式"></a>支持非标准格式</h3><p>JSON是有规范的，在它的规范里并没有描述到对注释的规定、对控制字符的处理等等，也就是说这些均属于<strong>非标准</strong>行为。比如这个JSON串：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"name"</span> : <span class="string">"YourBarman"</span>, <span class="comment">// 名字</span></span><br><span class="line">	<span class="attr">"age"</span> : <span class="number">18</span> <span class="comment">// 年龄</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你看，若你这么写IDEA都会飘红提示你：<br><img data-src="https://img-blog.csdnimg.cn/20200724185832770.png" alt=""><br><strong>但是</strong>，在很多使用场景（特别是JavaScript）里，我们会在JSON串里写注释（属性多时尤甚）那么对于这种串，JsonParser如何控制处理呢？它提供了对非标准JSON格式的兼容，通过下面这些特征值来控制。</p>
<h4 id="ALLOW-COMMENTS-false"><a href="#ALLOW-COMMENTS-false" class="headerlink" title="ALLOW_COMMENTS(false)"></a>ALLOW_COMMENTS(false)</h4><blockquote>
<p>自2.10版本后，使用<code>JsonReadFeature#ALLOW_JAVA_COMMENTS</code>代替</p>
</blockquote>
<p>是否允许<code>/* */</code>或者<code>//</code>这种类型的注释出现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String jsonStr = <span class="string">"&#123;\n"</span> +</span><br><span class="line">            <span class="string">"\t\"name\" : \"YourBarman\", // 名字\n"</span> +</span><br><span class="line">            <span class="string">"\t\"age\" : 18 // 年龄\n"</span> +</span><br><span class="line">            <span class="string">"&#125;"</span>;</span><br><span class="line"></span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    <span class="keyword">try</span> (JsonParser jsonParser = factory.createParser(jsonStr)) &#123;</span><br><span class="line">    	<span class="comment">// 开启注释支持</span></span><br><span class="line">        <span class="comment">// jsonParser.enable(JsonParser.Feature.ALLOW_COMMENTS);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (jsonParser.nextToken() != JsonToken.END_OBJECT) &#123;</span><br><span class="line">            String fieldname = jsonParser.getCurrentName();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"name"</span>.equals(fieldname)) &#123;</span><br><span class="line">                jsonParser.nextToken();</span><br><span class="line">                System.out.println(jsonParser.getText());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"age"</span>.equals(fieldname)) &#123;</span><br><span class="line">                jsonParser.nextToken();</span><br><span class="line">                System.out.println(jsonParser.getIntValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，抛出异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.fasterxml.jackson.core.JsonParseException: <span class="function">Unexpected <span class="title">character</span> <span class="params">(<span class="string">'/'</span> (code <span class="number">47</span>)</span>): maybe <span class="title">a</span> <span class="params">(non-standard)</span> comment? <span class="params">(not recognized as one since Feature <span class="string">'ALLOW_COMMENTS'</span> not enabled <span class="keyword">for</span> parser)</span></span></span><br><span class="line"><span class="function"> at [Source: <span class="params">(String)</span>"</span>&#123;</span><br><span class="line">	<span class="string">"name"</span> : <span class="string">"YourBarman"</span>, <span class="comment">// 名字</span></span><br><span class="line">	<span class="string">"age"</span> : <span class="number">18</span> <span class="comment">// 年龄</span></span><br><span class="line">&#125;<span class="string">"; line: 2, column: 26]</span></span><br></pre></td></tr></table></figure>
<p>放开注释的代码，再次运行程序，<strong>正常work</strong>。</p>
<h4 id="ALLOW-YAML-COMMENTS-false"><a href="#ALLOW-YAML-COMMENTS-false" class="headerlink" title="ALLOW_YAML_COMMENTS(false)"></a>ALLOW_YAML_COMMENTS(false)</h4><blockquote>
<p>自2.10版本后，使用<code>JsonReadFeature#ALLOW_YAML_COMMENTS</code>代替</p>
</blockquote>
<p>顾名思义，开启后将支持Yaml格式的的注释，也就是<code>#</code>形式的注释语法。</p>
<h4 id="ALLOW-UNQUOTED-FIELD-NAMES-false"><a href="#ALLOW-UNQUOTED-FIELD-NAMES-false" class="headerlink" title="ALLOW_UNQUOTED_FIELD_NAMES(false)"></a>ALLOW_UNQUOTED_FIELD_NAMES(false)</h4><blockquote>
<p>自2.10版本后，使用<code>JsonReadFeature#ALLOW_UNQUOTED_FIELD_NAMES</code>代替</p>
</blockquote>
<p>是否允许属性名<strong>不带双引号””</strong>，比较简单，示例略。</p>
<h4 id="ALLOW-SINGLE-QUOTES-false"><a href="#ALLOW-SINGLE-QUOTES-false" class="headerlink" title="ALLOW_SINGLE_QUOTES(false)"></a>ALLOW_SINGLE_QUOTES(false)</h4><blockquote>
<p>自2.10版本后，使用<code>JsonReadFeature#ALLOW_SINGLE_QUOTES</code>代替</p>
</blockquote>
<p>是否允许属性名支持单引号，也就是使用<code>&#39;&#39;</code>包裹，形如这样：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    'age' : 18</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ALLOW-UNQUOTED-CONTROL-CHARS-false"><a href="#ALLOW-UNQUOTED-CONTROL-CHARS-false" class="headerlink" title="ALLOW_UNQUOTED_CONTROL_CHARS(false)"></a><del>ALLOW_UNQUOTED_CONTROL_CHARS(false)</del></h4><blockquote>
<p>自2.10版本后，使用<code>JsonReadFeature#ALLOW_UNESCAPED_CONTROL_CHARS</code>代替</p>
</blockquote>
<p>是否允许JSON字符串包含非引号<strong>控制字符</strong>（值小于32的ASCII字符，包含制表符和换行符）。 由于JSON规范要求对所有控制字符使用引号，这是一个非标准的特性，因此默认禁用。</p>
<p>那么，哪些字符属于控制字符呢？做个简单科普：我们一般说的ASCII码共128个字符(7bit)，共分为两大类</p>
<h5 id="控制字符"><a href="#控制字符" class="headerlink" title="控制字符"></a>控制字符</h5><p>控制字符，也叫不可打印字符。第<strong>0～32号</strong>及第127号(共34个)是控制字符，例如常见的：<strong>LF（换行）</strong>、<strong>CR（回车）</strong>、FF（换页）、DEL（删除）、BS（退格)等都属于此类。</p>
<p>控制字符<strong>大部分已经废弃</strong>不用了，它们的用途主要是用来操控已经处理过的文字，ASCII值为8、9、10 和13 分别转换为退格、制表、换行和回车字符。它们<strong>并没有特定的图形显示</strong>，但会依不同的应用程序，而对文本显示有不同的影响。</p>
<blockquote>
<p>话外音：你看不见我，但我对你影响还蛮大</p>
</blockquote>
<h5 id="非控制字符"><a href="#非控制字符" class="headerlink" title="非控制字符"></a>非控制字符</h5><p>也叫可显示字符，或者可打印字符，能从键盘直接输入的字符。比如0-9数字，逗号、分号这些等等。</p>
<blockquote>
<p>话外音：你肉眼能看到的字符就属于非控制字符</p>
</blockquote>
<h4 id="ALLOW-BACKSLASH-ESCAPING-ANY-CHARACTER-false"><a href="#ALLOW-BACKSLASH-ESCAPING-ANY-CHARACTER-false" class="headerlink" title="ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER(false)"></a><del>ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER(false)</del></h4><blockquote>
<p>自2.10版本后，使用<code>JsonReadFeature#ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER</code>代替</p>
</blockquote>
<p>是否允许<strong>反斜杠\</strong>转义任何字符。这句话不是非常好理解，看下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String jsonStr = <span class="string">"&#123;\"name\" : \"YourB\\'atman\" &#125;"</span>;</span><br><span class="line"></span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    <span class="keyword">try</span> (JsonParser jsonParser = factory.createParser(jsonStr)) &#123;</span><br><span class="line">        <span class="comment">// jsonParser.enable(JsonParser.Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (jsonParser.nextToken() != JsonToken.END_OBJECT) &#123;</span><br><span class="line">            String fieldname = jsonParser.getCurrentName();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"name"</span>.equals(fieldname)) &#123;</span><br><span class="line">                jsonParser.nextToken();</span><br><span class="line">                System.out.println(jsonParser.getText());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，报错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.fasterxml.jackson.core.JsonParseException: Unrecognized character escape <span class="string">''</span><span class="string">' (code 39)</span></span><br><span class="line"><span class="string"> at [Source: (String)"&#123;"name" : "YourB\'atman" &#125;"; line: 1, column: 19]</span></span><br><span class="line"><span class="string"> ...</span></span><br></pre></td></tr></table></figure>
<p>放开注释掉的代码，再次运行程序，<strong>一切正常</strong>，输出：<code>YourB&#39;atman</code>。</p>
<h4 id="ALLOW-NUMERIC-LEADING-ZEROS-false"><a href="#ALLOW-NUMERIC-LEADING-ZEROS-false" class="headerlink" title="ALLOW_NUMERIC_LEADING_ZEROS(false)"></a><del>ALLOW_NUMERIC_LEADING_ZEROS(false)</del></h4><blockquote>
<p>自2.10版本后，使用<code>JsonReadFeature#ALLOW_LEADING_ZEROS_FOR_NUMBERS</code>代替</p>
</blockquote>
<p>是否允许像<code>00001</code>这样的“数字”出现（而不报错）。看例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String jsonStr = <span class="string">"&#123;\"age\" : 00018 &#125;"</span>;</span><br><span class="line"></span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    <span class="keyword">try</span> (JsonParser jsonParser = factory.createParser(jsonStr)) &#123;</span><br><span class="line">        <span class="comment">// jsonParser.enable(JsonParser.Feature.ALLOW_NUMERIC_LEADING_ZEROS);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (jsonParser.nextToken() != JsonToken.END_OBJECT) &#123;</span><br><span class="line">            String fieldname = jsonParser.getCurrentName();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"age"</span>.equals(fieldname)) &#123;</span><br><span class="line">                jsonParser.nextToken();</span><br><span class="line">                System.out.println(jsonParser.getIntValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.fasterxml.jackson.core.JsonParseException: Invalid numeric value: Leading zeroes not allowed</span><br><span class="line"> at [Source: (String)<span class="string">"&#123;"</span>age<span class="string">" : 00018 &#125;"</span>; line: <span class="number">1</span>, column: <span class="number">11</span>]</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>
<p>放开注掉的代码，再次运行程序，一切正常。输出<code>18</code>。</p>
<h4 id="ALLOW-LEADING-DECIMAL-POINT-FOR-NUMBERS-false"><a href="#ALLOW-LEADING-DECIMAL-POINT-FOR-NUMBERS-false" class="headerlink" title="ALLOW_LEADING_DECIMAL_POINT_FOR_NUMBERS(false)"></a><del>ALLOW_LEADING_DECIMAL_POINT_FOR_NUMBERS(false)</del></h4><blockquote>
<p>自2.10版本后，使用<code>JsonReadFeature#ALLOW_LEADING_DECIMAL_POINT_FOR_NUMBERS</code>代替</p>
</blockquote>
<p>是否允许小数点<code>.</code>打头，也就是说<code>.1</code>这种小数格式是否合法。默认是不合法的，需要开启此特征才能支持，例子就略了，基本同上。</p>
<h4 id="ALLOW-NON-NUMERIC-NUMBERS-false"><a href="#ALLOW-NON-NUMERIC-NUMBERS-false" class="headerlink" title="ALLOW_NON_NUMERIC_NUMBERS(false)"></a><del>ALLOW_NON_NUMERIC_NUMBERS(false)</del></h4><blockquote>
<p>自2.10版本后，使用<code>JsonReadFeature#ALLOW_NON_NUMERIC_NUMBERS</code>代替</p>
</blockquote>
<p>是否允许一些解析器识别一组<strong>“非数字”(如NaN)</strong>作为合法的浮点数值。这个属性和上篇文章的<code>JsonGenerator#QUOTE_NON_NUMERIC_NUMBERS</code>特征值是遥相呼应的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String jsonStr = <span class="string">"&#123;\"percent\" : NaN &#125;"</span>;</span><br><span class="line"></span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    <span class="keyword">try</span> (JsonParser jsonParser = factory.createParser(jsonStr)) &#123;</span><br><span class="line">        <span class="comment">// jsonParser.enable(JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (jsonParser.nextToken() != JsonToken.END_OBJECT) &#123;</span><br><span class="line">            String fieldname = jsonParser.getCurrentName();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"percent"</span>.equals(fieldname)) &#123;</span><br><span class="line">                jsonParser.nextToken();</span><br><span class="line">                System.out.println(jsonParser.getFloatValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，抛错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.fasterxml.jackson.core.JsonParseException: Non-standard token <span class="string">'NaN'</span>: enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow</span><br><span class="line"> at [Source: (String)<span class="string">"&#123;"</span>percent<span class="string">" : NaN &#125;"</span>; line: <span class="number">1</span>, column: <span class="number">17</span>]</span><br></pre></td></tr></table></figure>
<p>放开注释掉的代码，再次运行，一切正常。输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NaN</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小贴士：NaN也可以表示一个Float对象，是的你没听错，即使它不是<strong>数字</strong>但它也是Float类型。具体你可以看看Float源码里的那几个常量</p>
</blockquote>
<h4 id="ALLOW-MISSING-VALUES-false"><a href="#ALLOW-MISSING-VALUES-false" class="headerlink" title="ALLOW_MISSING_VALUES(false)"></a><del>ALLOW_MISSING_VALUES(false)</del></h4><blockquote>
<p>自2.10版本后，使用<code>JsonReadFeature#ALLOW_MISSING_VALUES</code>代替</p>
</blockquote>
<p>是否允许支持<strong>JSON数组中</strong>“缺失”值。怎么理解：数组中缺失了值表示两个逗号之间，啥都没有，形如这样<code>[value1, , value3]</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String jsonStr = <span class="string">"&#123;\"names\" : [\"YourBatman\",,\"A哥\",,] &#125;"</span>;</span><br><span class="line"></span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    <span class="keyword">try</span> (JsonParser jsonParser = factory.createParser(jsonStr)) &#123;</span><br><span class="line">        <span class="comment">// jsonParser.enable(JsonParser.Feature.ALLOW_MISSING_VALUES);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (jsonParser.nextToken() != JsonToken.END_OBJECT) &#123;</span><br><span class="line">            String fieldname = jsonParser.getCurrentName();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"names"</span>.equals(fieldname)) &#123;</span><br><span class="line">                jsonParser.nextToken();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (jsonParser.nextToken() != JsonToken.END_ARRAY) &#123;</span><br><span class="line">                    System.out.println(jsonParser.getText());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，抛错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">YourBatman <span class="comment">// 能输出一个，毕竟第一个part（JsonToken）是正常的嘛</span></span><br><span class="line"></span><br><span class="line">com.fasterxml.jackson.core.JsonParseException: <span class="function">Unexpected <span class="title">character</span> <span class="params">(<span class="string">','</span> (code <span class="number">44</span>)</span>): expected a valid <span class="title">value</span> <span class="params">(JSON String, Number, Array, Object or token <span class="string">'null'</span>, <span class="string">'true'</span> or <span class="string">'false'</span>)</span></span></span><br><span class="line"><span class="function"> at [Source: <span class="params">(String)</span>"</span>&#123;<span class="string">"names"</span> : [<span class="string">"YourBatman"</span>,,<span class="string">"A哥"</span>,,] &#125;<span class="string">"; line: 1, column: 27]</span></span><br></pre></td></tr></table></figure>
<p>放开注释掉的代码，再次运行，一切正常，结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">YourBatman</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">A哥</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<p>请注意：此时数组的长度是5哦。</p>
<blockquote>
<p>小贴士：此处用的String类型展示结果，是因为null可以作为String类型（<code>jsonParser.getText()</code>得到null是合法的）。但如果你使用的int类型（或者bool类型），那么如果是null的话就报错喽<code>Current token (VALUE_NULL) not of boolean type</code>，有兴趣的亲可自行尝试，巩固下理解的效果。报错原因文上已有说明~</p>
</blockquote>
<h4 id="ALLOW-TRAILING-COMMA-false"><a href="#ALLOW-TRAILING-COMMA-false" class="headerlink" title="ALLOW_TRAILING_COMMA(false)"></a><del>ALLOW_TRAILING_COMMA(false)</del></h4><blockquote>
<p>自2.10版本后，使用<code>JsonReadFeature#ALLOW_TRAILING_COMMA</code>代替</p>
</blockquote>
<p>是否允许最后一个多余的逗号（一定是最后一个）。这个特征是<strong>非常重要</strong>的，若开关打开，有如下效果：</p>
<ul>
<li>[true,true,]等价于[true, true]</li>
<li>{“a”: true,}等价于{“a”: true}</li>
</ul>
<p>当这个特征和上面的<code>ALLOW_MISSING_VALUES</code>特征同时使用时，本特征优先级更高。也就是说：会先去除掉最后一个逗号后，再进行数组长度的计算。</p>
<p>举个例子：当然这两个特征开关都打开时，[true,true,]等价于[true, true]好理解；<strong>并且呢，<code>[true,true,,]</code>是等价于<code>[true, true, null]</code>的哦，可千万别忽略最后的这个null</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String jsonStr = <span class="string">"&#123;\"results\" : [true,true,,] &#125;"</span>;</span><br><span class="line"></span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    <span class="keyword">try</span> (JsonParser jsonParser = factory.createParser(jsonStr)) &#123;</span><br><span class="line">        jsonParser.enable(JsonParser.Feature.ALLOW_MISSING_VALUES);</span><br><span class="line">        <span class="comment">// jsonParser.enable(JsonParser.Feature.ALLOW_TRAILING_COMMA);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (jsonParser.nextToken() != JsonToken.END_OBJECT) &#123;</span><br><span class="line">            String fieldname = jsonParser.getCurrentName();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"results"</span>.equals(fieldname)) &#123;</span><br><span class="line">                jsonParser.nextToken();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (jsonParser.nextToken() != JsonToken.END_ARRAY) &#123;</span><br><span class="line">                    System.out.println(jsonParser.getBooleanValue());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">YourBatman</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">A哥</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<p>这完全就是上例的效果嘛。现在我放开注释掉的代码，再次运行，结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">YourBatman</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">A哥</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<p><strong>请注意对比前后的结果差异，并自己能能自己合理解释</strong>。</p>
<h3 id="校验相关"><a href="#校验相关" class="headerlink" title="校验相关"></a>校验相关</h3><p>Jackson在JSON标准<strong>之外</strong>，给出了两个校验相关的特征。</p>
<h4 id="STRICT-DUPLICATE-DETECTION-false"><a href="#STRICT-DUPLICATE-DETECTION-false" class="headerlink" title="STRICT_DUPLICATE_DETECTION(false)"></a>STRICT_DUPLICATE_DETECTION(false)</h4><blockquote>
<p>自2.10版本后，使用<code>StreamReadFeature#STRICT_DUPLICATE_DETECTION</code>代替</p>
</blockquote>
<p>是否允许JSON串有两个相同的属性key，默认是<strong>允许的</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String jsonStr = <span class="string">"&#123;\"age\":18, \"age\": 28 &#125;"</span>;</span><br><span class="line"></span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    <span class="keyword">try</span> (JsonParser jsonParser = factory.createParser(jsonStr)) &#123;</span><br><span class="line">        <span class="comment">// jsonParser.enable(JsonParser.Feature.STRICT_DUPLICATE_DETECTION);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (jsonParser.nextToken() != JsonToken.END_OBJECT) &#123;</span><br><span class="line">            String fieldname = jsonParser.getCurrentName();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"age"</span>.equals(fieldname)) &#123;</span><br><span class="line">                jsonParser.nextToken();</span><br><span class="line">                System.out.println(jsonParser.getIntValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，正常输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">28</span></span><br></pre></td></tr></table></figure>
<p>若放开注释代码，再次运行，则抛错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">18</span> <span class="comment">// 第一个数字还是能正常输出的哟</span></span><br><span class="line"></span><br><span class="line">com.fasterxml.jackson.core.JsonParseException: Duplicate field <span class="string">'age'</span></span><br><span class="line"> at [Source: (String)<span class="string">"&#123;"</span>age<span class="string">":18, "</span>age<span class="string">": 28 &#125;"</span>; line: <span class="number">1</span>, column: <span class="number">17</span>]</span><br></pre></td></tr></table></figure>

<h4 id="IGNORE-UNDEFINED-false"><a href="#IGNORE-UNDEFINED-false" class="headerlink" title="IGNORE_UNDEFINED(false)"></a>IGNORE_UNDEFINED(false)</h4><blockquote>
<p>自2.10版本后，使用<code>StreamReadFeature#IGNORE_UNDEFINED</code>代替</p>
</blockquote>
<p>是否忽略<strong>没有定义</strong>的属性key。和<code>JsonGenerator.Feature#IGNORE_UNKNOWN</code>的这个特征一样，它作用于预先定义了格式的数据类型，如<code>Avro、protobuf</code>等等，JSON是不需要预先定义的哦~</p>
<p>同样的，你可以通过这个API预先设置格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JsonParser:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSchema</span><span class="params">(FormatSchema schema)</span> </span>&#123;</span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h4 id="INCLUDE-SOURCE-IN-LOCATION-true"><a href="#INCLUDE-SOURCE-IN-LOCATION-true" class="headerlink" title="INCLUDE_SOURCE_IN_LOCATION(true)"></a>INCLUDE_SOURCE_IN_LOCATION(true)</h4><blockquote>
<p>自2.10版本后，使用<code>StreamReadFeature#INCLUDE_SOURCE_IN_LOCATION</code>代替</p>
</blockquote>
<p>是否构建<code>JsonLocation</code>对象来表示每个part的来源，你可以通过<code>JsonParser#getCurrentLocation()</code>来访问。作用不大，就此略过。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了底层流式API JsonParser读JSON的方式，它不仅仅能够处理<strong>标准JSON</strong>，也能通过Feature特征值来控制，开启对一些非标准但又比较常用的JSON串的支持，这不正式一个优秀框架/库应有的态度麽：<strong>兼容性</strong>。</p>
<p>结合上篇文章对写JSON时<code>JsonGenerator</code>的描述，能够总结出两点原则：</p>
<ul>
<li>写：100%遵循规范</li>
<li>读：最大程度<strong>兼容</strong>并包</li>
</ul>
<p>写代表你的输出，遵循规范的输出能确保第三方在用你输出的数据时不至于对你破口大骂，所以这是你应该做好的<strong>本分</strong>。读代表你的输入，能够处理规范的格式是你的职责，但我若还能额外的处理一些非标准格式（一般为常用的），那绝对是闪耀点，也就是你给的<strong>情分</strong>。本分是你应该做的，而情分就是你的加分项。<br><img data-src="https://img-blog.csdnimg.cn/20200725135421852.png" alt=""></p>
<h5 id="相关推荐："><a href="#相关推荐：" class="headerlink" title="相关推荐："></a>相关推荐：</h5><ul>
<li><a href="https://mp.weixin.qq.com/s/z6T9n9YvwjmDwuj-YTa0_w" target="_blank" rel="noopener">Fastjson到了说再见的时候了</a></li>
<li><a href="https://mp.weixin.qq.com/s/iqSN4HUoIdX0kGcSdnD7EA" target="_blank" rel="noopener">1. 初识Jackson – 世界上最好的JSON库</a></li>
<li><a href="https://mp.weixin.qq.com/s/p6cwP2BVrC8VxkN-T3uAxg" target="_blank" rel="noopener">2. 妈呀，Jackson原来是这样写JSON的</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZHb3P06IC4xElHwJqDepxw" target="_blank" rel="noopener">3. 懂了这些，方敢在简历上说会用Jackson写JSON</a></li>
</ul>]]></content>
      <categories>
        <category>A哥学Jackson</category>
      </categories>
      <tags>
        <tag>Jackson</tag>
        <tag>Fastjson</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>搞事情？Spring Boot今天一口气发布三个版本</title>
    <url>/x2y/a3cba048.html</url>
    <content><![CDATA[<blockquote>
<p>学无止境？本文已被 <a href="https://www.yourbatman.cn"><strong>https://www.yourbatman.cn</strong></a> 收录，里面一并有Spring技术栈、MyBatis、JVM、中间件等小而美的<strong>专栏</strong>供以免费学习。关注公众号【<strong>BAT的乌托邦</strong>】逐个击破，深入掌握，拒绝浅尝辄止。</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20200725232718273.png" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>各位好，我是A哥(YourBatman)。今天是2020-07-25，上午我正从<strong><a href="https://start.spring.io" target="_blank" rel="noopener">https://start.spring.io</a></strong>准备down一个工程下来的时候，打开页面发现默认选中的Spring Boot版本号是<code>2.3.2</code>：<br><img data-src="https://img-blog.csdnimg.cn/20200725213616518.png" alt=""><br>并非我刻意的去找到这个变化，而是由于我<strong>昨天</strong> down下来的工程使用的Spring Boot版本是<strong>2.3.1</strong>，印象还在，所以今天一下子就发现了差异。</p>
<p>既然升级了（虽然是小版本号），那就去官方楼一眼呗。不看不知道，一看还真让发现些内容：<strong>Spring Boot在同一天（2020-07-25）一口气发布了三个版本，这是要搞事情啊？</strong><br><img data-src="https://img-blog.csdnimg.cn/20200725233253231.png" alt=""></p>
<blockquote>
<p>小贴士：本文所有时间若未做特殊说明，指的均是<strong>北京时间</strong></p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>Spring Boot目前还处于<strong>Active</strong>活跃的分支共有三个：<br><img data-src="https://img-blog.csdnimg.cn/20200725215806663.png" alt=""><br>因此就在今天，<strong>同一天</strong>里Spring Boot对它的这三条线做了更新：</p>
<ul>
<li>Spring Boot 2.3.1 -&gt; <strong>Spring Boot 2.3.2</strong></li>
<li>Spring Boot 2.2.8 -&gt; <strong>Spring Boot 2.2.9</strong></li>
<li>Spring Boot 2.1.15 -&gt; <strong>Spring Boot 2.1.16</strong></li>
</ul>
<p><img data-src="https://img-blog.csdnimg.cn/20200725221151805.png" alt=""><br>此次发版，距离上次<strong>正式</strong>发版（不区分分支）已足足有<strong>44天</strong>之久。<br><img data-src="https://img-blog.csdnimg.cn/20200725220629806.png" alt=""></p>
<h2 id="有哪些升级？"><a href="#有哪些升级？" class="headerlink" title="有哪些升级？"></a>有哪些升级？</h2><p>参考github上的Release详情，三个分支<strong>都</strong>有如下三方面的改进：</p>
<ol>
<li>🐞 修复bug</li>
<li>📔 文档同步</li>
<li>🔨 升级依赖</li>
</ol>
<h3 id="🐞-修复bug"><a href="#🐞-修复bug" class="headerlink" title="🐞 修复bug"></a>🐞 修复bug</h3><p>小版本号的升级，最重要的使命就是<strong>修复bug</strong>，这是它存在的意义。针对这三个版本，各自的bug修复总数如下：</p>
<ul>
<li><strong>2.3.2</strong>：34个。遥遥领先</li>
<li><strong>2.2.9</strong>：10个。</li>
<li><strong>2.1.16</strong>：1个。</li>
</ul>
<p>能发现规律吧，<strong>版本越新，bug越多</strong>，这是符合常理的。另外，从小版本号里能知道：2.1.x版本都修复16次bug了，而2.3.x才第2次修复，正处于bug井喷阶段呢。所以一味的追新的话，还需谨慎哈。</p>
<p>也许你会吐槽，Spring Boot这啥编码水平，咋这么多bug？其实非也，个数虽多（其实也还好），但每一个都是<strong>非严重bug</strong>，影响甚微，无需大惊小怪。</p>
<p>另外，从bug的原因上来看，不少bug是各个版本都有的共性问题。比如2.1.x版本那个唯一的bug，其它两个版本均有：<br><img data-src="https://img-blog.csdnimg.cn/20200725224007874.png" alt=""></p>
<h3 id="📔-文档同步"><a href="#📔-文档同步" class="headerlink" title="📔 文档同步"></a>📔 文档同步</h3><p>此part用于对文档上的改变做出一些说明，比如文字描述错误、排班不正确等等。举例本次的一个修复：</p>
<p>修复前：<br><img data-src="https://img-blog.csdnimg.cn/20200725224446430.png" alt=""><br>修复后：<br><img data-src="https://img-blog.csdnimg.cn/20200725224517894.png" alt=""><br>不得不说，这老外还挺较真（挺仔细）的。</p>
<h3 id="🔨-升级依赖"><a href="#🔨-升级依赖" class="headerlink" title="🔨 升级依赖"></a>🔨 升级依赖</h3><p>由于是小版本的升级，因此对应的依赖也是小版本升级。举例：</p>
<ul>
<li>Tomcat升级到9.0.37</li>
<li>Spring Framework升级到5.2.8（此版本4天前发布）</li>
</ul>
<p>值得注意的是，拿<code>Spring Framework</code>的升级举例：Spring Boot的2.2.x和2.3.x都是升级到了5.2.8版本，而Spring Boot的2.1.x分支依赖的是<code>Spring Framework 5.1.17</code>版本哦。</p>
<hr>
<p><strong>除此之外</strong>，Spring Boot它的最新版本，也就是2.3.2里还新增了3个新特性，了解一下：</p>
<ol>
<li>改进 Kubernates Liveness/Readiness 健康指标和探针配置</li>
<li>添加运行镜像选项用于Docker镜像构建</li>
<li>增加对reactive Elasticsearch的健康检查</li>
</ol>
<blockquote>
<p>小贴士：小版本号的升级是可以新增这种很小的功能点的，但不允许新增大功能</p>
</blockquote>
<h2 id="三个版本核心依赖的区别"><a href="#三个版本核心依赖的区别" class="headerlink" title="三个版本核心依赖的区别"></a>三个版本核心依赖的区别</h2><p>Spring Boot目前活跃的分支有3个，也就是这三个<strong>主线版本</strong>。那么他们三在核心依赖上有啥区别呢？A哥特意翻资料帮你整理了一下，绘制如下表：</p>
<blockquote>
<p>说明：因为表格兼容性不太好，所以我以图片方式展示</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20200725230447674.png" alt=""></p>
<h2 id="关于1-5-x和2-0-x版本"><a href="#关于1-5-x和2-0-x版本" class="headerlink" title="关于1.5.x和2.0.x版本"></a>关于1.5.x和2.0.x版本</h2><p>这两个分支已经是古董分支了：<br><img data-src="https://img-blog.csdnimg.cn/20200725230905400.png" alt=""></p>
<blockquote>
<p>stale中文意思：不新鲜的，老掉牙的，没有新意的</p>
</blockquote>
<p>它们<strong>早已</strong>寿终正寝，最后一个版本和发布时间为：</p>
<ul>
<li>1.5.22.RELEASE，2019.08</li>
<li>2.0.9.RELEASE，2019.04</li>
</ul>
<p>有意思的是，<strong>2.0.x</strong>版本的生命周期非常的短暂，几乎刚好一年（2018.3 - 2019.4）。但是不可否认2.0.x版本是具有划时代意义的，在1.5.x的基础上垮了一大步，上了一个大台阶。</p>
<p>所以如果你的项目还在使用这两个版本，特别是1.5.x，那么尽快升级吧。官方推荐的是使用最新的2.3.x分支，这也是当前最为活跃的分支。</p>
<blockquote>
<p>小贴士：1.5.x升级到2.x.x属于阻断式升级，需要十分谨慎</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Spring Boot作为微服务、云原生开发的基础设施，每个Java开发者都应该理解它、跟上它、学习它，才得以保证自己不掉队，不被<strong>后浪</strong>拍死。</p>
<p>但是，如此之快的更新速度，Spring官方是认真的，但你能认真起来吗？歪果仁，这是周末唉，你们不用休息的吗？疫情期间在家办公就这么任性？<br><img data-src="https://img-blog.csdnimg.cn/20200725231628798.png" alt=""></p>
<h5 id="相关推荐："><a href="#相关推荐：" class="headerlink" title="相关推荐："></a>相关推荐：</h5><ul>
<li><a href="https://mp.weixin.qq.com/s/z6T9n9YvwjmDwuj-YTa0_w" target="_blank" rel="noopener">Fastjson到了说再见的时候了</a></li>
<li><a href="https://mp.weixin.qq.com/s/iqSN4HUoIdX0kGcSdnD7EA" target="_blank" rel="noopener">1. 初识Jackson – 世界上最好的JSON库</a></li>
<li><a href="https://mp.weixin.qq.com/s/p6cwP2BVrC8VxkN-T3uAxg" target="_blank" rel="noopener">2. 妈呀，Jackson原来是这样写JSON的</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZHb3P06IC4xElHwJqDepxw" target="_blank" rel="noopener">3. 懂了这些，方敢在简历上说会用Jackson写JSON</a></li>
</ul>]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>蚂蚁金服上市了，我不想努力了</title>
    <url>/x2y/2d980889.html</url>
    <content><![CDATA[<blockquote>
<p>努力和选择，哪个更重要？本文已被 <a href="https://www.yourbatman.cn"><strong>https://www.yourbatman.cn</strong></a> 收录，里面一并有Spring技术栈、MyBatis、JVM、中间件等小而美的<strong>专栏</strong>供以免费学习。关注公众号【<strong>BAT的乌托邦</strong>】逐个击破，深入掌握，拒绝浅尝辄止。</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20200721204501418.jpeg#x200" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>各位好，我是A哥(YourBatman)。今天咱们就来唠唠这两天最热的话题：🐜蚂蚁金服。</p>
<p>昨晚，杭州一整栋楼都在欢呼，听说那是<strong>财富自由</strong>的声音：<br><img data-src="https://img-blog.csdnimg.cn/20200721183040565.png" alt=""><br>之前都是小道消息，这次是官宣了。7月20日，支付宝母公司蚂蚁集团宣布，将启动在上市的计划，蚂蚁集团寻求IPO估值至少2000亿美元。2000亿美元，这意味着蚂蚁集团将成为阿里腾讯之外，中国市值<strong>第三大</strong>的互联网公司。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>财务自由这个词，在职场上非常非常的火，特别是在空手套白狼的互联网行业，你经常能看到各种让人“羡慕嫉妒恨”的热搜，比如前段时间的：<strong>字节跳动28岁程序员郭宇就宣布自己实现财务自由，要正式退休了，还准备旅居日本经营温泉酒店</strong>。</p>
<p>那么，在中国，有多少钱才算财务自由？如何定义？</p>
<h2 id="多少钱算财务自由？"><a href="#多少钱算财务自由？" class="headerlink" title="多少钱算财务自由？"></a>多少钱算财务自由？</h2><p>为此我特意翻了翻资料，找了份2020年比较权威的解答：根据<strong>胡润研究院</strong>发布的报告，在一线城市财务自由的门槛达到了<strong>2.9</strong>亿元，二线城市也要<strong>1.7</strong>亿元。<br><img data-src="https://img-blog.csdnimg.cn/20200721190459518.png" alt=""><br>2020年的北京市的平均月薪（互联网行业）17539元，如果你想要靠工资实现财务自由，那不吃不喝也得是<strong>一千年以后，世界早已没有你</strong>。很明显，要实现财务自由，对于<strong>99.99%</strong> 的人来说啊，都是遥不可及的梦想。</p>
<blockquote>
<p>4个9，熟悉吗😄。其实我觉得应该是6个9…</p>
</blockquote>
<p>虽说这事<strong>难如登天</strong>，但在朋友圈、微博上，我们却又总能看到有人分享些浇浇花、到处自驾游、出国游，那种不用一直上班、能说走就走的自由，那时我们也会认为他们没有财务压力，自由了。</p>
<blockquote>
<p>这种就比较多了吧，比如老北京、老上海，拆迁上几套房足矣~</p>
</blockquote>
<p>其实，在很多人眼中财务自由的<strong>标准并不一样</strong>，它并不仅仅是财富本身，而是选择未来的自由度。</p>
<h2 id="蚂蚁金服员工"><a href="#蚂蚁金服员工" class="headerlink" title="蚂蚁金服员工"></a>蚂蚁金服员工</h2><p>蚂蚁给期权还是很慷慨的，马爸爸把40%左右的股票都分给了员工，真可谓全员持股啊。认识个湖北老乡，蚂蚁金服10年+的老员工，手握十几万<strong>SERs</strong>，具体我不知道SERs和股票怎么兑换和计算，但上市后至少大几千万是没跑了，行情好的话说不定上亿。</p>
<p>其实公司（特别是创业公司）给期权的<strong>套路</strong>是非常多的，比如冯大和丁香园的期权没兑现事件等等“悲惨”例子不再少数，所以大多数时候我们人会选择高些的Base最为稳妥。</p>
<p><strong>但是</strong>，蚂蚁金服是非常实在的，可谓明着打牌。2014年开始蚂蚁就基本确定了肯定会上市（那时候体量已足够），无非一直憋着在寻找一个最好的时机（毕竟不差钱，根本不用着急嘛）。因此我们基本是要恭喜<strong>2014年-2018年</strong>期间入职蚂蚁金服的员工，P8以及以上大概率能够实现财富自由了。</p>
<blockquote>
<p>P7也会配股，但应该还不至于财务自由，但一线城市的一套三居室应该妥妥的</p>
</blockquote>
<p>当然喽，并不是所有人都在欢笑，也有哭晕在厕所的：<br><img data-src="https://img-blog.csdnimg.cn/20200721192807636.png" alt=""><br>这还不算太惨，还有<strong>正在走</strong>离职流程的，这个官宣可谓晴天霹雳：<br><img data-src="https://img-blog.csdnimg.cn/20200721192916435.png" alt=""><br>这位老兄留言给你提的建议，你真的可以考虑考虑这一跪：<br><img data-src="https://img-blog.csdnimg.cn/20200721193258470.png" alt=""><br>如果不行，你还可以<strong>长跪不起</strong>😄。<br><img data-src="https://img-blog.csdnimg.cn/20200721201128815.png" alt=""><br>会有波离职潮，妥妥的，毕竟这么大公司，一碗水肯定是端不平的。</p>
<h3 id="不为人知的背后付出"><a href="#不为人知的背后付出" class="headerlink" title="不为人知的背后付出"></a>不为人知的背后付出</h3><p>蚂蚁金服在互联网公司中非常出名，不仅仅是因为它的产品（支付宝、花呗、借呗…），还有它的“福报”，据说可能算得上是<strong>全国最苦逼</strong>的公司。</p>
<p>在互联网圈加班是常态，什么996、10 10 7都不算什么新闻。但蚂蚁金服的工作强度还能高出1-2个档位：普通互联网公司强度为3，华为为4，那么蚂蚁金服就是5。脉脉上随便逛逛：<br><img data-src="https://img-blog.csdnimg.cn/20200721194901277.png" alt="压力过大，辞职走人"><br><img data-src="https://img-blog.csdnimg.cn/20200721193931277.png" alt=""></p>
<blockquote>
<p>入职后你终于知道为毛马爸爸取名为蚂蚁🐜了吧😄😄😄</p>
</blockquote>
<p>还有，这是<strong>晚上11点</strong>拍的支付宝大厦照片：<br><img data-src="https://img-blog.csdnimg.cn/20200721193557460.png" alt=""><br>看起来真像<strong>人间炼狱</strong>，但马爸爸会说这是福报。还是马云那句话：加班是对的，不加班也是对的，只有完不成工作是不对的！什么是完成工作？60分是完成，80分是完成，100分也是完成，你要的是多少？青春是用来拼搏的，而不是用来挥霍的！选择奔跑，选择努力。</p>
<p>如果吃着马爸爸这样精神食粮，是不是又觉得每天11点下班太早呢？<br><img data-src="https://img-blog.csdnimg.cn/2020072120082014.png" alt=""></p>
<p><strong>无论如何</strong>，这个财务自由还是非常令人羡慕的。不管是P7还是P8，说到底还是打工仔，这下靠手上的期权一下子就能完成原始积累，然后稍微投资投资，当个小老板岂不美滋滋。哪怕不投资，全部放银行拿利息一年算下来也不是个小数目了。</p>
<p>这么看来，杭州这房价还得涨啊。如果你在北京、上海，又或者在成都的话，也不用笑，因为这几个城市的“蚂蚁”也不在少数。</p>
<blockquote>
<p>小贴士：开玩笑哈，一个公司上市还不足以撬动房地产市场~</p>
</blockquote>
<h3 id="无股员工还有机会吗？"><a href="#无股员工还有机会吗？" class="headerlink" title="无股员工还有机会吗？"></a>无股员工还有机会吗？</h3><p>我认为还是有的，毕竟蚂蚁金服上市了，还有<strong>阿里云</strong>，还有<strong>菜鸟裹裹</strong>这些超级独角兽嘛，但前提是：你首先得先让自己入坑。<br><img data-src="https://img-blog.csdnimg.cn/20200721195658163.png" alt=""><br><img data-src="https://img-blog.csdnimg.cn/20200721195719433.png" alt=""></p>
<p><strong>如果你想要财富自由，但又不想入坑，不想修福报。那么接下来就只能通过我介绍的方法去实现了，此处敲黑板喽，要考。</strong></p>
<hr>
<h2 id="我不想努力了"><a href="#我不想努力了" class="headerlink" title="我不想努力了"></a>我不想努力了</h2><p>2020年之予阿里算是多事之秋，前有蒋凡那啥，后有阿里P8那啥……可见阿里人在杭州是多么的多金，让那些“不想努力”的人趋之若鹜。<br><img data-src="https://img-blog.csdnimg.cn/20200721200548780.png" alt=""></p>
<p><strong>我不想努力了</strong>，这句话应该很多人说过，无论是在口头上，还是在心里默念，说出这句话和有这个想法也很容易，但真正想放弃的人有多少，很多人只是被压得想要宣泄一下，明明说过上百次“我不想努力了”。</p>
<p>如果你也说过这样的话，那么今天你就来对了，下面A哥介绍三种<strong>不用努力，也能实现财富自由</strong>的方式，供你选择。</p>
<h3 id="方式一：你好，阿姨"><a href="#方式一：你好，阿姨" class="headerlink" title="方式一：你好，阿姨"></a>方式一：你好，阿姨</h3><p><img data-src="https://img-blog.csdnimg.cn/20200721201529637.png" alt=""></p>
<ul>
<li><strong>优点</strong>：一步到位，静想盛世荣华富贵</li>
<li><strong>缺点</strong>：50岁的年龄差，不是每个人都能接受</li>
</ul>
<p>如果你确定选择这个方式，A哥也给你提供了一个（自己加vx聊哈），若需要更多选择，请私聊A哥，给你发《<strong>北京单身富婆通讯录</strong>》，里面有联系电话，自己煲电话粥聊聊看看合适否。<br><img data-src="https://img-blog.csdnimg.cn/20200721182320739.jpg" alt=""></p>
<h3 id="方式二：泰森，我不想努力了"><a href="#方式二：泰森，我不想努力了" class="headerlink" title="方式二：泰森，我不想努力了"></a>方式二：泰森，我不想努力了</h3><p>如果你想找一个<strong>年龄相仿</strong>的，那么这个方式挺适合你。如果谁能娶<strong>泰森</strong>的女儿米切尔，他将把<strong>1000万美金</strong>当作嫁妆送给他。看，你还能看到女主照片呢：<br><img data-src="https://img-blog.csdnimg.cn/20200721202118271.png" alt=""></p>
<ul>
<li><strong>优点</strong>：女主三百斤的体重，加上一米八的身高，安全系数极高，安全感绝对爆棚</li>
<li><strong>缺点</strong>：需要抗打。毕竟泰森的拳头甑子丹都够呛</li>
</ul>
<h3 id="方式三：做梦"><a href="#方式三：做梦" class="headerlink" title="方式三：做梦"></a>方式三：做梦</h3><p>如果上面两种方式你都不算特别满意，那么睡一觉你总不会抗拒了吧~<br><img data-src="https://img-blog.csdnimg.cn/20200721202619265.png" alt=""></p>
<h2 id="奋斗，努力"><a href="#奋斗，努力" class="headerlink" title="奋斗，努力"></a>奋斗，努力</h2><p><img data-src="https://img-blog.csdnimg.cn/20200721203017284.gif" alt=""><br>通往财富自由的路，哪有捷径。哪怕是即将财富自由的蚂蚁金服员工，也都是汗水、泪水，甚至血水拼出来的。成年人，就没有容易二字。</p>
<p>上面都是开玩笑，聊点实在的。在你很难的时候，感觉到身心力竭的时候。一句安慰，一声问候，一个拥抱，一张笑脸都会显得弥足珍贵；你会发现，加班到深夜，路过旁边的小卖店，大爷的笑容让你心情十分愉悦。有时闭起眼睛，给自己两三分钟冥想一下，让美好的事情盖掉所有负面情绪，虽然生活很难，保持乐观是非常重要的，所以请善待你身边的<strong>开心果</strong>，他们的存在，其实是在帮助你调节自己，即使他在开你玩笑。</p>
<p>有时候感觉不行了，可以大声说出<strong>我不想努力了</strong>，但是千万不要落实到行动中，可以说一说，但是千万不要做，因为能找到自己喜欢坚持的事情，这本身就是一件很了不起的事了，所以千万不要轻易放弃自己的坚持，比如我，也在坚持啊。</p>
<p><strong>“喂，再坚持坚持吧！”</strong><br><img data-src="https://img-blog.csdnimg.cn/20200721200943489.png" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实，我觉得人生的终极自由在于<strong>心灵自由</strong>，财务自由的人，未必心灵自由；而心灵自由的人，往往只需要不多的财富，就能获得无限的自由感。</p>
<blockquote>
<p>小贴士：财富也很重要，财富也很重要，财富也很重要</p>
</blockquote>
<p>财富自由是我们几乎每个人追求的目标，但你不应该拿你当下的生活去交换（只要工作，不要生活？不要妻儿？），也不该是人生的终极目标。<strong>踏踏实实地过好平凡的每一天，远比什么财务自由来得现实！</strong></p>
<p>优秀也好，平凡也罢，接受自己，爱自己。</p>]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>蚂蚁金服</tag>
        <tag>财富自由</tag>
        <tag>IPO</tag>
      </tags>
  </entry>
  <entry>
    <title>3. 懂了这些，方敢在简历上说会用Jackson写JSON</title>
    <url>/x2y/cae3349a.html</url>
    <content><![CDATA[<blockquote>
<p>你必须非常努力,才能看起来毫不费力。本文已被 <a href="https://www.yourbatman.cn"><strong>https://www.yourbatman.cn</strong></a> 收录，里面一并有Spring技术栈、MyBatis、JVM、中间件等小而美的<strong>专栏</strong>供以免费学习。关注公众号【<strong>BAT的乌托邦</strong>】逐个击破，深入掌握，拒绝浅尝辄止。</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20200720073108356.png" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>各位好，我是A哥(YourBatman)。上篇文章：<a href="https://mp.weixin.qq.com/s/p6cwP2BVrC8VxkN-T3uAxg" target="_blank" rel="noopener">2. 妈呀，Jackson原来是这样写JSON的</a> 知道了Jackson写JSON的姿势，切实感受了一把ObjectMapper原来是这样完成序列化的…本文继续深入讨论JsonGenerator写JSON的细节。</p>
<p>先闲聊几句题外话哈。我们在书写简历的时候，都会用一定篇幅展示自己的技能点（亮点），就像这样：<br><img data-src="https://img-blog.csdnimg.cn/20200720073821953.png" alt=""><br>这一part非常重要，它决定了面试官是否有跟你聊的兴趣，决定了你是否能在浩如烟海的简历中够脱颖而出。如何做到差异性？在当下如此发达的信息社会里，信息的获取唾手可得，所以在<strong>知识的广度</strong>方面，我认为人与人之间的差异其实并不大：<br><img data-src="https://img-blog.csdnimg.cn/20200720074651594.png" alt=""><br>你知道DDD领域驱动、读过架构整洁之道、知道六边形架构、知道DevOps……难道你还在想凭一些概念卖钱？拉出差距？<br>你在用Spring技术栈、在用Redis、在用ElasticSearch……难道你还以为现在像10年前一样，会用就能加分？</p>
<p><strong>一聊就会，一问就退，一写就废</strong>。这是很多公司程序员的真实写照，基/中层管理者尤甚。早早的和技术渐行渐远，导致裁员潮到来时很容易获得一张“飞机票”，年纪越大，焦虑感越强。</p>
<p>在你的公司是否有过这种场景：<strong>四五个人指挥一个人干活</strong>。对，就像这样：<br><img data-src="https://img-blog.csdnimg.cn/20200720162708278.png" alt=""><br><img data-src="https://img-blog.csdnimg.cn/20200720162822933.png" alt=""><br>扎不扎心，老铁😄。不过不用悲观，从这应该你看到的是机会，习xx都说了实干才能兴邦嘛，2019年裁员潮洗牌后，适者生存，不适者很多回老家了，这也让大批<strong>很有实力</strong>的程序员享受到了红利。应正了那句：<strong>当大潮褪去，才知道谁在裸泳</strong>。</p>
<p>扯远了，言归正传。Jackson单会简单使用我认为还不足矣立足，那就跟我来吧~</p>
<h2 id="版本约定"><a href="#版本约定" class="headerlink" title="版本约定"></a>版本约定</h2><ul>
<li>Jackson版本：<code>2.11.0</code></li>
<li>Spring Framework版本：<code>5.2.6.RELEASE</code></li>
<li>Spring Boot版本：<code>2.3.0.RELEASE</code></li>
</ul>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>一个框架/库好不好，不是看它的核心功能做得怎么样，而是非核心功能处理得如何。比如后台页面做得咋样？容错机制呢？定制化、可配置化，扩展性等等。</p>
<p>Jackson称得上优秀（甚至最佳）最主要是得益于它优秀的<strong>module</strong>模块化设计，在接触其之前，我们先完成本章节的内容：<code>JsonGenerator</code>写JSON的行为控制（配置）。</p>
<p>配置属于程序的一部分，它影响着程序执行的方方面面。<code>Spring</code>使用Environment/PropertySource管理配置，对应的在Jackson里会看到有很多Feature类来控制Jackson的读/写行为，均是使用enum枚举类型来管理。</p>
<p><a href="https://mp.weixin.qq.com/s/p6cwP2BVrC8VxkN-T3uAxg" target="_blank" rel="noopener">上篇文章</a> 我们学会了如何使用JsonGenerator去写一个JSON，本文将来学习它的需要掌握的使用细节。同样的，为围绕着JsonGenerator展开。</p>
<h2 id="JsonGenerator的Feature"><a href="#JsonGenerator的Feature" class="headerlink" title="JsonGenerator的Feature"></a>JsonGenerator的Feature</h2><p>它是JsonGenerator的一个<strong>内部</strong>枚举类，共10个枚举值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Feature &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Low-level I/O</span></span><br><span class="line">	AUTO_CLOSE_TARGET(<span class="keyword">true</span>),</span><br><span class="line">	AUTO_CLOSE_JSON_CONTENT(<span class="keyword">true</span>),</span><br><span class="line">	FLUSH_PASSED_TO_STREAM(<span class="keyword">true</span>),</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Quoting-related features</span></span><br><span class="line">	<span class="meta">@Deprecated</span></span><br><span class="line">	QUOTE_FIELD_NAMES(<span class="keyword">true</span>),</span><br><span class="line">	<span class="meta">@Deprecated</span></span><br><span class="line">	QUOTE_NON_NUMERIC_NUMBERS(<span class="keyword">true</span>),</span><br><span class="line">	<span class="meta">@Deprecated</span></span><br><span class="line">	ESCAPE_NON_ASCII(<span class="keyword">false</span>),</span><br><span class="line">	<span class="meta">@Deprecated</span></span><br><span class="line">	WRITE_NUMBERS_AS_STRINGS(<span class="keyword">false</span>),</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Schema/Validity support features</span></span><br><span class="line">	WRITE_BIGDECIMAL_AS_PLAIN(<span class="keyword">false</span>),</span><br><span class="line">	STRICT_DUPLICATE_DETECTION(<span class="keyword">false</span>),</span><br><span class="line">	IGNORE_UNKNOWN(<span class="keyword">false</span>);</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小贴士：枚举值均为bool类型，括号内为默认值</p>
</blockquote>
<p>这个Feature的每个枚举值都控制着<code>JsonGenerator</code>写JSON时的不同行为，并且可分为三大类（源码处我也有标注）：</p>
<ul>
<li>Low-level I/O：底层I/O流相关。</li>
</ul>
<blockquote>
<p>Jackson的流式API指的是I/O流，因此就涉及到关流、flush刷新流等操作</p>
</blockquote>
<ul>
<li>Quoting-related：双引号””引用相关。</li>
</ul>
<blockquote>
<p>JSON规范规定key都必须有双引号，但这对于某些场景下并不需要</p>
</blockquote>
<ul>
<li>Schema/Validity support：约束/规范/校验相关。</li>
</ul>
<blockquote>
<p>JSON作为K-V结构的数据，那么允许相同key出现吗？这便由这些特征去控制</p>
</blockquote>
<p>下面分别来认识认识它们。</p>
<h3 id="AUTO-CLOSE-TARGET-true"><a href="#AUTO-CLOSE-TARGET-true" class="headerlink" title="AUTO_CLOSE_TARGET(true)"></a>AUTO_CLOSE_TARGET(true)</h3><p>含义即为字面意：自动关闭目标（流）。</p>
<ul>
<li>true：调用<code>JsonGenerator#close()</code>便会自动关闭底层的I/O流，你无需再关心</li>
<li>false：底层I/O流请手动关闭</li>
</ul>
<p>自动关闭：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    <span class="keyword">try</span> (JsonGenerator jg = factory.createGenerator(System.err, JsonEncoding.UTF8)) &#123;</span><br><span class="line">        <span class="comment">// doSomething</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果改为false：那么你就需要自己<strong>手动去close</strong>底层使用的OutputStream或者Writer。形如这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    <span class="keyword">try</span> (PrintStream err = System.err; JsonGenerator jg = factory.createGenerator(err, JsonEncoding.UTF8)) &#123;</span><br><span class="line">        <span class="comment">// 特征置为false 采用手动关流的方式</span></span><br><span class="line">        jg.disable(JsonGenerator.Feature.AUTO_CLOSE_TARGET);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// doSomething</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小贴士：例子均采用<code>try-with-resources</code>方式关流，所以并没有显示调用close()方法，你应该能懂吧😄</p>
</blockquote>
<h3 id="AUTO-CLOSE-JSON-CONTENT-true"><a href="#AUTO-CLOSE-JSON-CONTENT-true" class="headerlink" title="AUTO_CLOSE_JSON_CONTENT(true)"></a>AUTO_CLOSE_JSON_CONTENT(true)</h3><p>先来看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    <span class="keyword">try</span> (JsonGenerator jg = factory.createGenerator(System.err, JsonEncoding.UTF8)) &#123;</span><br><span class="line">        jg.writeStartObject();</span><br><span class="line">        jg.writeFieldName(<span class="string">"names"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写数组</span></span><br><span class="line">        jg.writeStartArray();</span><br><span class="line">        jg.writeString(<span class="string">"A哥"</span>);</span><br><span class="line">        jg.writeString(<span class="string">"YourBatman"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"names"</span>:[<span class="string">"A哥"</span>,<span class="string">"YourBatman"</span>]&#125;</span><br></pre></td></tr></table></figure>
<p>wow，竟然输出一切正常。细心的你会发现，我的代码是缺胳膊少腿的：<strong>不管是Object还是Array都只start了，并没有显示调用end进行闭合</strong>。但是呢，结果却正常得很，这便是此Feature的作用了。</p>
<ul>
<li>true：自动补齐（闭合）<code>JsonToken#START_ARRAY</code>和<code>JsonToken#START_OBJECT</code>类型的内容</li>
<li>false：啥都不做（不会主动抛错哦）</li>
</ul>
<p>不过还是要啰嗦一句：虽然Jackson通过此Feature做了容错，但是自己在使用时，<strong>请务必</strong>显示书写闭合</p>
<h3 id="FLUSH-PASSED-TO-STREAM-true"><a href="#FLUSH-PASSED-TO-STREAM-true" class="headerlink" title="FLUSH_PASSED_TO_STREAM(true)"></a>FLUSH_PASSED_TO_STREAM(true)</h3><p>在使用带有缓冲区的I/O写数据时，缺少“临门一脚”是初学者很容易犯的错误，比如下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    JsonGenerator jg = factory.createGenerator(System.err, JsonEncoding.UTF8);</span><br><span class="line"></span><br><span class="line">    jg.writeStartObject();</span><br><span class="line">    jg.writeStringField(<span class="string">"name"</span>,<span class="string">"A哥"</span>);</span><br><span class="line">    jg.writeEndObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jg.flush();</span></span><br><span class="line">    <span class="comment">// jg.close();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，<strong>控制台没有任何输出</strong>。把注释代码放开任何一行，再次运行程序，控制台正常输出：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"A哥"</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>true：当JsonGenerator调用close()/flush()方法时，自动强刷I/O流里面的数据</li>
<li>false：请手动处理</li>
</ul>
<h4 id="为何需要flush-？"><a href="#为何需要flush-？" class="headerlink" title="为何需要flush()？"></a>为何需要flush()？</h4><p>对于此问题这里小科普一下。因为向磁盘、网络写入数据的时候，出于效率的考虑，<strong>操作系统</strong>（话外音：这是操作系统为之）并不是输出一个字节就立刻写入到文件或者发送到网络，而是把输出的字节先放到内存的一个缓冲区里（本质上就是一个byte[]数组），等到缓冲区写满了，再一次性写入文件或者网络。对于<strong>很多IO设备</strong>来说，一次写一个字节和一次写1000个字节，花费的时间几乎是完全一样的，所以OutputStream有个flush()方法，能<strong>强制</strong>把缓冲区内容输出。</p>
<blockquote>
<p>小贴士：<strong>InputStream</strong>是没有flush()方法的哦</p>
</blockquote>
<p><strong>通常情况下</strong>，我们不需要调用这个flush()方法，因为缓冲区写满了，OutputStream会自动调用它，并且，在调用close()方法关闭OutputStream之前，也会自动调用flush()方法强制刷一次缓冲区。但是，在某些情况下，我们必须手动调用flush()方法，比如上例子，比如发IM消息…</p>
<h3 id="QUOTE-FIELD-NAMES-true"><a href="#QUOTE-FIELD-NAMES-true" class="headerlink" title="QUOTE_FIELD_NAMES(true)"></a><del>QUOTE_FIELD_NAMES(true)</del></h3><blockquote>
<p>此属性自<code>2.10</code>版本后已过期，使用<code>JsonWriteFeature#QUOTE_FIELD_NAMES</code>代替，应用在JsonFactory上，后文详解</p>
</blockquote>
<p>JSON对象字段名是否为使用””双引号括起来，这是JSON规范（RFC4627）规定的。</p>
<ul>
<li>true：字段名使用””括起来 -&gt; 遵循JSON规范</li>
<li>false：字段名<strong>不</strong>使用””括起来 -&gt; <strong>不</strong>遵循JSON规范<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    <span class="keyword">try</span> (JsonGenerator jg = factory.createGenerator(System.err, JsonEncoding.UTF8)) &#123;</span><br><span class="line">		<span class="comment">// jg.disable(QUOTE_FIELD_NAMES);</span></span><br><span class="line">		</span><br><span class="line">        jg.writeStartObject();</span><br><span class="line">        jg.writeStringField(<span class="string">"name"</span>,<span class="string">"A哥"</span>);</span><br><span class="line">        jg.writeEndObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
运行程序，输出：<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"A哥"</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>99.99%的情况下我们不需要改变默认值。Jackson添加了<strong>禁用引号</strong>的功能以支持那非常不常见的情况，最常见的情况直接从Javascript中使用时可能会发生。</p>
<p>打开注释掉的语句，再次运行程序，输出：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;name:"A哥"&#125;</span><br></pre></td></tr></table></figure>

<h3 id="QUOTE-NON-NUMERIC-NUMBERS-true"><a href="#QUOTE-NON-NUMERIC-NUMBERS-true" class="headerlink" title="QUOTE_NON_NUMERIC_NUMBERS(true)"></a><del>QUOTE_NON_NUMERIC_NUMBERS(true)</del></h3><blockquote>
<p>此属性自<code>2.10</code>版本后已过期，使用<code>JsonWriteFeature#WRITE_NAN_AS_STRINGS</code>代替，应用在JsonFactory上，后文详解</p>
</blockquote>
<p>这个特征挺有意思，看例子（以写Float为例）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    <span class="keyword">try</span> (JsonGenerator jg = factory.createGenerator(System.err, JsonEncoding.UTF8)) &#123;</span><br><span class="line">    	<span class="comment">// jg.disable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS);</span></span><br><span class="line"></span><br><span class="line">        jg.writeNumber(<span class="number">0.9</span>);</span><br><span class="line">        jg.writeNumber(<span class="number">1.9</span>);</span><br><span class="line"></span><br><span class="line">        jg.writeNumber(Float.NaN);</span><br><span class="line">        jg.writeNumber(Float.NEGATIVE_INFINITY);</span><br><span class="line">        jg.writeNumber(Float.POSITIVE_INFINITY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="number">0.9</span> <span class="number">1.9</span> <span class="string">"NaN"</span> <span class="string">"-Infinity"</span> <span class="string">"Infinity"</span></span><br></pre></td></tr></table></figure>
<p><strong>同为Float数字类型</strong>，有的输出有””双引号包着，有的没有。放开注释的语句（禁用此特征），再次运行程序，输出：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">0.9 1.9 NaN -Infinity Infinity</span><br></pre></td></tr></table></figure>
<p>很明显，如果你是这么输出为一个JSON的话，那它就会是<strong>非法的JSON</strong>，是不符合JSON标准的（因为像NaN、Infinity这种明显是字符串嘛，必须用””包起来才是合法的value值）。</p>
<p>由于JSON规范中对数字的严格定义，加上Java可能具有的<strong>开放式数字集</strong>（如上例中Float类型并不100%是数字），很难做到既安全又方便，因此有了此特征让你根据需要来控制。</p>
<h3 id="ESCAPE-NON-ASCII-false"><a href="#ESCAPE-NON-ASCII-false" class="headerlink" title="ESCAPE_NON_ASCII(false)"></a><del>ESCAPE_NON_ASCII(false)</del></h3><blockquote>
<p>此属性自<code>2.10</code>版本后已过期，使用<code>JsonWriteFeature#ESCAPE_NON_ASCII</code>代替，应用在JsonFactory上，后文详解</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    <span class="keyword">try</span> (JsonGenerator jg = factory.createGenerator(System.err, JsonEncoding.UTF8)) &#123;</span><br><span class="line">        <span class="comment">// jg.enable(ESCAPE_NON_ASCII);</span></span><br><span class="line">        jg.writeString(<span class="string">"A哥"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">"A哥"</span></span><br></pre></td></tr></table></figure>
<p>放开注掉的代码（开启此属性），再次运行，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">"A\u54E5"</span></span><br></pre></td></tr></table></figure>

<h3 id="WRITE-NUMBERS-AS-STRINGS-false"><a href="#WRITE-NUMBERS-AS-STRINGS-false" class="headerlink" title="WRITE_NUMBERS_AS_STRINGS(false)"></a><del>WRITE_NUMBERS_AS_STRINGS(false)</del></h3><blockquote>
<p>此属性自<code>2.10</code>版本后已过期，使用<code>JsonWriteFeature#WRITE_NUMBERS_AS_STRINGS</code>代替，应用在JsonFactory上，后文详解</p>
</blockquote>
<p>该特性<strong>强制</strong>将<strong>所有</strong>Java数字写成字符串，即使底层数据格式真的是数字。</p>
<ul>
<li>true：所有数字<strong>强制</strong>写为字符串</li>
<li>false：不做处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    <span class="keyword">try</span> (JsonGenerator jg = factory.createGenerator(System.err, JsonEncoding.UTF8)) &#123;</span><br><span class="line">        <span class="comment">// jg.enable(WRITE_NUMBERS_AS_STRINGS);</span></span><br><span class="line"></span><br><span class="line">        Long num = Long.MAX_VALUE;</span><br><span class="line">        jg.writeNumber(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="number">9223372036854775807</span></span><br></pre></td></tr></table></figure>
<p>放开注释代码（开启此特征），再次运行程序，输出：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">"9223372036854775807"</span></span><br></pre></td></tr></table></figure>
<p>有什么使用场景？一个用例是避免Javascript限制的问题：因为Javascript标准规定所有的数字处理都应该使用<strong>64位ieee754浮点值</strong>来完成，结果是一些64位整数值不能被精确表示（因为尾数只有51位宽）。</p>
<blockquote>
<p>采坑提醒：时间戳后端用Long类型反给前端是没有问题的。但如果你是<strong>很大的一个Long值</strong>（如雪花算法算出的很大的Long值），直接返回前端的话，Javascript就会出现精度丢失的bug</p>
</blockquote>
<h3 id="WRITE-BIGDECIMAL-AS-PLAIN-false"><a href="#WRITE-BIGDECIMAL-AS-PLAIN-false" class="headerlink" title="WRITE_BIGDECIMAL_AS_PLAIN(false)"></a>WRITE_BIGDECIMAL_AS_PLAIN(false)</h3><p>控制写<code>java.math.BigDecimal</code>的行为：</p>
<ul>
<li>true：使用<code>BigDecimal#toPlainString()</code>方法输出</li>
<li>false： 使用默认输出方式（取决于BigDecimal是如何构造的）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    <span class="keyword">try</span> (JsonGenerator jg = factory.createGenerator(System.err, JsonEncoding.UTF8)) &#123;</span><br><span class="line">        <span class="comment">// jg.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);</span></span><br><span class="line"></span><br><span class="line">        BigDecimal bigDecimal1 = <span class="keyword">new</span> BigDecimal(<span class="number">1.0</span>);</span><br><span class="line">        BigDecimal bigDecimal2 = <span class="keyword">new</span> BigDecimal(<span class="string">"1.0"</span>);</span><br><span class="line">        BigDecimal bigDecimal3 = <span class="keyword">new</span> BigDecimal(<span class="string">"1E11"</span>);</span><br><span class="line">        jg.writeNumber(bigDecimal1);</span><br><span class="line">        jg.writeNumber(bigDecimal2);</span><br><span class="line">        jg.writeNumber(bigDecimal3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1.0</span> <span class="number">1E+11</span></span><br></pre></td></tr></table></figure>
<p>放开注释代码，再次运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1.0</span> <span class="number">100000000000</span></span><br></pre></td></tr></table></figure>

<h3 id="STRICT-DUPLICATE-DETECTION-false"><a href="#STRICT-DUPLICATE-DETECTION-false" class="headerlink" title="STRICT_DUPLICATE_DETECTION(false)"></a>STRICT_DUPLICATE_DETECTION(false)</h3><p>是否去严格的检测重复属性名。</p>
<ul>
<li>true：检测是否有重复字段名，若有，则抛出<code>JsonParseException</code>异常</li>
<li>false：不检测JSON对象重复的字段名，即：相同字段名都要解析</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    <span class="keyword">try</span> (JsonGenerator jg = factory.createGenerator(System.err, JsonEncoding.UTF8)) &#123;</span><br><span class="line">        <span class="comment">// jg.enable(JsonGenerator.Feature.STRICT_DUPLICATE_DETECTION);</span></span><br><span class="line"></span><br><span class="line">        jg.writeStartObject();</span><br><span class="line">        jg.writeStringField(<span class="string">"name"</span>,<span class="string">"YourBatman"</span>);</span><br><span class="line">        jg.writeStringField(<span class="string">"name"</span>,<span class="string">"A哥"</span>);</span><br><span class="line">        jg.writeEndObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"YourBatman"</span>,<span class="attr">"name"</span>:<span class="string">"A哥"</span>&#125;</span><br></pre></td></tr></table></figure>
<p>打开注释掉的哪行代码：开启此特征值为true。再次运行程序，输出：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">com.fasterxml.jackson.core.JsonGenerationException: Duplicate field 'name'</span><br><span class="line"></span><br><span class="line">	at com.fasterxml.jackson.core.json.JsonWriteContext._checkDup(JsonWriteContext.java:224)</span><br><span class="line">	at com.fasterxml.jackson.core.json.JsonWriteContext.writeFieldName(JsonWriteContext.java:217)</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p><strong>注意：谨慎打开此开关，如果检查的话性能会下降20%-30%。</strong></p>
<h3 id="IGNORE-UNKNOWN-false"><a href="#IGNORE-UNKNOWN-false" class="headerlink" title="IGNORE_UNKNOWN(false)"></a>IGNORE_UNKNOWN(false)</h3><p>如果<strong>底层数据格式</strong>需要输出所有属性，以及如果<strong>找不到</strong>调用者试图写入的属性的定义，则该特性确定是否要执行的操作。</p>
<p>可能你听完还一脸懵逼，什么底层数据格式，什么找不到，我明明是写JSON啊，何解？其实这不是针对于写JSON来说的，<strong>对于JSON，这个特性没有效果，因为属性不需要预先定义</strong>。通常，大多数文本数据格式不需要模式信息，而某些二进制数据格式需要定义（如Avro、protobuf），因此这个属性是为它们而生（Smile、BSON等这些二进制也是不需要预定模式信息的哦）。</p>
<blockquote>
<p>强调：<code>JsonGenerator</code>不是只能写JSON格式，毕竟底层是I/O流嘛，理论上啥都能写</p>
</blockquote>
<ul>
<li>true：启动该功能</li>
</ul>
<p>可以预先调用（在写数据之前）这个API设定好模式信息即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JsonGenerator：</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSchema</span><span class="params">(FormatSchema schema)</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>false：禁用该功能。如果底层数据格式需要所有属性的知识才能输出，那就抛出JsonProcessingException异常</li>
</ul>
<h2 id="定制Feature"><a href="#定制Feature" class="headerlink" title="定制Feature"></a>定制Feature</h2><p>通过上一part知晓了控制<code>JsonGenerator</code>的特征值们，以及其作用是。Feature的每个枚举值都有个默认值（括号里面），那么如果我们希望对<strong>不同的JsonGenerator实例</strong>应用不同的配置该怎么办呢？</p>
<p>自然而然的JsonGenerator提供了相关API供以我们操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> JsonGenerator <span class="title">enable</span><span class="params">(Feature f)</span></span>;</span><br><span class="line"><span class="comment">// 关闭</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> JsonGenerator <span class="title">disable</span><span class="params">(Feature f)</span></span>;</span><br><span class="line"><span class="comment">// 开启/关闭</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> JsonGenerator <span class="title">configure</span><span class="params">(Feature f, <span class="keyword">boolean</span> state)</span> </span>&#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">(Feature f)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">(StreamWriteFeature f)</span> </span>&#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="替换者：StreamWriteFeature"><a href="#替换者：StreamWriteFeature" class="headerlink" title="替换者：StreamWriteFeature"></a>替换者：StreamWriteFeature</h2><p>本类是2.10版本新增的，用于完全替换上面的Feature。目的：完全独立的属性配置，不依赖于任何后端格式，因为<code>JsonGenerator</code>并不局限于写JSON，因此把Feature放在JsonGenerator作为内部类是不太合适的，所以单独摘出来。</p>
<p>StreamWriteFeature用在<code>JsonFactory</code>里，后面再讲解到它的构建器<code>JsonFactoryBuilder</code>时再详细探讨。</p>
<h2 id="序列化POJO对象"><a href="#序列化POJO对象" class="headerlink" title="序列化POJO对象"></a>序列化POJO对象</h2><p>上篇文章用代码演示过了如何使用<code>writeObject(Object pojo)</code>来把一个POJO一次性序列化成为一个JSON串，它主要依赖于ObjectCodec去完成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> JsonGenerator <span class="title">setCodec</span><span class="params">(ObjectCodec oc)</span></span>;</span><br></pre></td></tr></table></figure>
<p>ObjectCodec可谓是Jackson里极其重要的一个基础组件，我们最熟悉的<code>ObjectMapper</code>它就是一个解码器，实现了序列化和反序列化、树模型等操作。这将在后面章节里重点介绍~</p>
<h2 id="输出漂亮的JSON格式"><a href="#输出漂亮的JSON格式" class="headerlink" title="输出漂亮的JSON格式"></a>输出漂亮的JSON格式</h2><p>我们知道JSON之所以快速流行的原因之一是得益于它的<strong>可读性好</strong>，可读性好又表现在它漂亮的（规则）的展示格式上。</p>
<p>默认情况下，使用<code>JsonGenerator</code>写JSON时，所有的部分都是输出在同一行里，显然这种格式对人阅读来说是不够友好的。作为最流行的JSON库自然考虑到了这一点，提供了格式化器来<strong>美化输出</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自己指定漂亮格式打印器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JsonGenerator <span class="title">setPrettyPrinter</span><span class="params">(PrettyPrinter pp)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用默认的漂亮格式打印器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> JsonGenerator <span class="title">useDefaultPrettyPrinter</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>PrettyPrinter有如下两个实现类：<br><img data-src="https://img-blog.csdnimg.cn/20200720195228788.png" alt=""><br>使用不同的实现类，对输出结果的影响如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">什么都不设置：</span><br><span class="line">MinimalPrettyPrinter：</span><br><span class="line">&#123;<span class="attr">"zhName"</span>:<span class="string">"A哥"</span>,<span class="attr">"enName"</span>:<span class="string">"YourBatman"</span>,<span class="attr">"age"</span>:<span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line">DefaultPrettyPrinter：</span><br><span class="line">useDefaultPrettyPrinter():</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"zhName"</span> : <span class="string">"A哥"</span>,</span><br><span class="line">  <span class="attr">"enName"</span> : <span class="string">"YourBatman"</span>,</span><br><span class="line">  <span class="attr">"age"</span> : <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可见，在什么都不设置的情况下，结果会全部在一行显示（紧凑型输出）。<code>DefaultPrettyPrinter</code>表示带层级格式的输出（可读性好），若有此需要，建议直接调用更为快捷的<code>useDefaultPrettyPrinter()</code>方法，而不用自己去new一个实例。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文的主要内容和重点是介绍了用Feature去控制JsonGenerator的写行为，不同的特征值控制着不同的行为。在实际使用时可针对不同的需求，定制出不同的<code>JsonGenerator</code>实例，因地制宜和互相隔离。</p>]]></content>
      <categories>
        <category>A哥学Jackson</category>
      </categories>
      <tags>
        <tag>Jackson</tag>
        <tag>Fastjson</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>2. 妈呀，Jackson原来是这样写JSON的</title>
    <url>/x2y/cf41a8ab.html</url>
    <content><![CDATA[<blockquote>
<p>没有人永远18岁，但永远有人18岁。本文已被 <a href="https://www.yourbatman.cn"><strong>https://www.yourbatman.cn</strong></a> 收录，里面一并有Spring技术栈、MyBatis、JVM、中间件等小而美的<strong>专栏</strong>供以免费学习。关注公众号【<strong>BAT的乌托邦</strong>】逐个击破，深入掌握，拒绝浅尝辄止。</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20200717122214583.png" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>各位好，我是A哥(YourBatman)。<a href="https://mp.weixin.qq.com/s/iqSN4HUoIdX0kGcSdnD7EA" target="_blank" rel="noopener">上篇文章</a> 整体介绍了世界上最好的JSON库 – Jackson，对它有了整体了解：知晓了它是个生态，其它的仅是个JSON库而已。</p>
<blockquote>
<p>有人说Jackson小众？那么请先看看上篇文章吧。学Jackson性价比特别高，因为它使用广泛、会的人少，因此在团队内如果你能精通，附加价值的效应就会非常明显了…</p>
</blockquote>
<p>我挠头想了想，本系列来不了虚的，只能肝。本系列教程不仅仅教授基本使用，目标是搞完后能够解决日常99.99%的问题，毕竟每个小团队都最好能有某些方面的小专家，毕竟大家都不乏遇见过一个技术问题卡一天的情况。<strong>只有从底层把握，方能游刃有余</strong>。<br><img data-src="https://img-blog.csdnimg.cn/20200715180628489.png" alt=""></p>
<p>命名为core的模块一般都不简单，<code>jackson-core</code>自然也不例外。它是三大核心模块之一，并且是<strong>核心中的核心</strong>，提供了对JSON数据的<strong>完整支持</strong>（包括各种读、写）。它是三者中最强大的模块，具有<strong>最低的</strong>开销和<strong>最快的</strong>读/写操作。 </p>
<p>此模块提供了<strong>最具底层</strong>的Streaming JSON解析器/生成器，这组流式API属于Low-Level API，具有非常显著的特点：</p>
<ul>
<li>开销小，损耗小，性能极高</li>
<li>因为是Low-Level API，所以灵活度极高</li>
<li>又因为是Low-Level API，所以易错性高，可读性差</li>
</ul>
<p><strong>jackson-core</strong>模块提供了两种处理JSON的方式（纵缆整个Jackson共三种）：</p>
<ol>
<li>流式API：读取并将JSON内容写入作为离散事件 -&gt; <code>JsonParser</code>读取数据，而<code>JsonGenerator</code>负责写入数据</li>
<li>树模型：JSON文件在内存里以树形式表示。此种方式也很灵活，它类似于XML的DOM解析，层层嵌套的</li>
</ol>
<p>作为“底层”技术，应用级开发中确实接触不多。为了引起你的重视，提前预告一下：<code>Spring MVC</code>对JSON消息的转换器<code>AbstractJackson2HttpMessageConverter</code>它就用到了底层流式API -&gt; JsonGenerator写数据。想不想拿下Spring呢？我想你的答案应该是Yes吧~<br><img data-src="https://img-blog.csdnimg.cn/20200715182507991.png" alt=""></p>
<p>相信做<strong>难事必有所得</strong>，你我他都会用的技术、都能解决的问题，那绝成不了你的核心竞争力，自然在团队内就难成发光体。</p>
<h2 id="版本约定"><a href="#版本约定" class="headerlink" title="版本约定"></a>版本约定</h2><p>原则：均选当前最新版本（忽略小版本）</p>
<ul>
<li>Jackson版本：<code>2.11.0</code></li>
<li>Spring Framework版本：<code>5.2.6.RELEASE</code></li>
<li>Spring Boot版本：<code>2.3.0.RELEASE</code><ul>
<li>内置的Jackson和Spring版本均和👆保持一致，避免了版本交叉</li>
</ul>
</li>
</ul>
<blockquote>
<p>说明：类似2.11.0和2.11.x这种小版本号的差异，你权可认为没有区别</p>
</blockquote>
<h2 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h2><p>鉴于是首次展示工程示例代码，将基本结构展示如下：<br><img data-src="https://img-blog.csdnimg.cn/20200716114814949.png" alt=""><br><img data-src="https://img-blog.csdnimg.cn/20200716114929650.png" alt=""></p>
<blockquote>
<p>全部源码地址在本系列的<strong>最后一篇</strong>文章中会全部公示出来</p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>Jackson提供了一种对性能有极致要求的方式：流式API。它用于对性能有极致要求的场景，这个时候就可以使用此种方式来对JSON进行读写。</p>
<h2 id="概念解释：流式、增量模式、JsonToken"><a href="#概念解释：流式、增量模式、JsonToken" class="headerlink" title="概念解释：流式、增量模式、JsonToken"></a>概念解释：流式、增量模式、JsonToken</h2><ul>
<li>流式（Streaming）：此概念和Java8中的Stream流是不同的。这里指的是<strong>IO流</strong>，因此具有最低的开销和最快的读/写操作（记得关流哦）</li>
<li>增量模式（incremental mode）：它表示每个部分一个一个地往上增加，类似于垒砖。使用此流式API读写JSON的方式使用的<strong>均是增量模式</strong></li>
<li>JsonToken：每一部分都是一个独立的Token（有不同类型的Token），最终被“拼凑”起来就是一个JSON。这是流式API里很重要的一个抽象概念。</li>
</ul>
<blockquote>
<p>关于增量模式和Token概念，在Spirng的<strong>SpEL</strong>表达式中也有同样的概念，这在Spring相关专栏里你将会再次体会到</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20200715184404566.png" alt=""><br>本文将看看它是如何写JSON数据的，也就是<code>JsonGenerator</code>。</p>
<h2 id="JsonGenerator使用Demo"><a href="#JsonGenerator使用Demo" class="headerlink" title="JsonGenerator使用Demo"></a>JsonGenerator使用Demo</h2><p><code>JsonGenerator</code>定义用于编写JSON内容的公共API的基类（抽象类）。实例使用的工厂方法创建，也就是<code>JsonFactory</code>。</p>
<blockquote>
<p>小贴士：纵观整个Jackson，它更多的是使用抽象类而非接口，这是它的一大“特色”。因此你熟悉的面向接口编程，到这都要转变为面向抽象类编程喽。</p>
</blockquote>
<p>话不多说，先来一个Demo感受一把：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    <span class="comment">// 本处只需演示，向控制台写（当然你可以向文件等任意地方写都是可以的）</span></span><br><span class="line">    JsonGenerator jsonGenerator = factory.createGenerator(System.out, JsonEncoding.UTF8);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        jsonGenerator.writeStartObject(); <span class="comment">//开始写，也就是这个符号 &#123;</span></span><br><span class="line"></span><br><span class="line">        jsonGenerator.writeStringField(<span class="string">"name"</span>, <span class="string">"YourBatman"</span>);</span><br><span class="line">        jsonGenerator.writeNumberField(<span class="string">"age"</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">        jsonGenerator.writeEndObject(); <span class="comment">//结束写，也就是这个符号 &#125;</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        jsonGenerator.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为JsonGenerator实现了<code>AutoCloseable</code>接口，因此可以使用<code>try-with-resources</code>优雅关闭资源（这也是推荐的使用方式），代码改造如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    <span class="comment">// 本处只需演示，向控制台写（当然你可以向文件等任意地方写都是可以的）</span></span><br><span class="line">    <span class="keyword">try</span> (JsonGenerator jsonGenerator = factory.createGenerator(System.out, JsonEncoding.UTF8)) &#123;</span><br><span class="line">        jsonGenerator.writeStartObject(); <span class="comment">//开始写，也就是这个符号 &#123;</span></span><br><span class="line"></span><br><span class="line">        jsonGenerator.writeStringField(<span class="string">"name"</span>, <span class="string">"YourBatman"</span>);</span><br><span class="line">        jsonGenerator.writeNumberField(<span class="string">"age"</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">        jsonGenerator.writeEndObject(); <span class="comment">//结束写，也就是这个符号 &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，<strong>控制台</strong>输出：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"YourBatman"</span>,<span class="attr">"age"</span>:<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure>
<p>这是最简使用示例，这也就是所谓的<strong>序列化</strong>底层实现，从示例中对<strong>增量模式</strong>能够有所感受吧。</p>
<p>纯手动档有木有，灵活性和性能极高，但易出错。这就像头文字D的赛车一样，先要速度、高性能、灵活性，那必须上手动档。<br><img data-src="https://img-blog.csdnimg.cn/2020071612110129.png" alt=""></p>
<h2 id="JsonGenerator详细介绍"><a href="#JsonGenerator详细介绍" class="headerlink" title="JsonGenerator详细介绍"></a>JsonGenerator详细介绍</h2><p>JsonGenerator是个抽象类，它的继承体系如下：<br><img data-src="https://img-blog.csdnimg.cn/20200716122204956.png" alt=""></p>
<ul>
<li><code>WriterBasedJsonGenerator</code>：基于java.io.Writer处理字符编码（话外音：使用Writer输出JSON）<ul>
<li>因为UTF-8编码基本标准化了，因此Jackson内部也提供了<code>SegmentedStringWriter/UTF8Writer</code>来简化操作</li>
</ul>
</li>
<li><code>UTF8JsonGenerator</code>：基于OutputStream + UTF-8处理字符编码（话外音：明确指定了使用UTF-8编码把字节变为字符）</li>
</ul>
<p>默认情况下（不指定编码），Jackson默认会使用UTF-8进行编码，也就是说会使用<code>UTF8JsonGenerator</code>作为实际的JSON生成器实现类，具体逻辑将在讲述<code>JsonFactory</code>章节中有所体现，敬请关注。</p>
<p>值得注意的是，抽象基类<code>JsonGenerator</code>它只负责JSON的生成，至于把生成好的JSON写到哪里去它并不关心。比如示例中我给写到了控制台，当然你也可以写到文件、写到网络等等。</p>
<blockquote>
<p>Spring MVC中的JSON消息转换器就是向<code>HttpOutputMessage</code>（网络输出流）里写JSON数据</p>
</blockquote>
<h3 id="关键API"><a href="#关键API" class="headerlink" title="关键API"></a>关键API</h3><p><code>JsonGenerator</code>虽然仅是抽象基类，但Jackson它建议我们使用<code>JsonFactory</code>工厂来创建其实例，并不需要使用者去关心其底层实现类，因此我们仅需要<strong>面向此抽象类编程</strong>即可，此为对使用者非常友好的设计。</p>
<p>对于JSON生成器来说，写方法自然是它的灵魂所在。众所周知，JSON属于K-V数据结构，因此针对于一个JSON来说，每一段都k额分为<strong>写key</strong>和<strong>写value</strong>两大阶段。<br><img data-src="https://img-blog.csdnimg.cn/20200717135546876.png" alt=""></p>
<h3 id="写JSON-Key"><a href="#写JSON-Key" class="headerlink" title="写JSON Key"></a>写JSON Key</h3><p>JsonGenerator一共提供了3个方法用于写JSON的key：<br><img data-src="https://img-blog.csdnimg.cn/20200716150405123.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    <span class="keyword">try</span> (JsonGenerator jsonGenerator = factory.createGenerator(System.out, JsonEncoding.UTF8)) &#123;</span><br><span class="line">        jsonGenerator.writeStartObject();</span><br><span class="line"></span><br><span class="line">        jsonGenerator.writeFieldName(<span class="string">"zhName"</span>);</span><br><span class="line"></span><br><span class="line">        jsonGenerator.writeEndObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"zhName"</span>&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，<strong>key可以独立存在（无需value）</strong>，但value是不能独立存在的哦，下面你会看到效果。而3个方法中的<strong>其它2个方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeFieldName</span><span class="params">(SerializableString name)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFieldId</span><span class="params">(<span class="keyword">long</span> id)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    writeFieldName(Long.toString(id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个方法，你可以忘了吧，记住<code>writeFieldName()</code>就足够了。</p>
<p>总的来说，写JSON的key非常简单的，这得益于JSON的key有且仅可能是String类型，所以情况单一。下面继续了解较为复杂的写Value的情况。</p>
<h3 id="写JSON-Value"><a href="#写JSON-Value" class="headerlink" title="写JSON Value"></a>写JSON Value</h3><p>我们知道在Java中数据存在的形式（类型）非常之多，比如String、int、Reader、char[]…，而在JSON中<strong>值的类型</strong>只能是如下形式：</p>
<ul>
<li>字符串（如<code>{ &quot;name&quot;:&quot;YourBatman&quot; }</code>）</li>
<li>数字（如<code>{ &quot;age&quot;:18 }</code>）</li>
<li>对象（JSON 对象）（如<code>{ &quot;person&quot;:{ &quot;name&quot;:&quot;YourBatman&quot;, &quot;age&quot;:18}}</code>）</li>
<li>数组（如<code>{&quot;names&quot;:[ &quot;YourBatman&quot;, &quot;A哥&quot; ]}</code>）</li>
<li>布尔（如<code>{ &quot;success&quot;:true }</code>）</li>
<li>null（如：<code>{ &quot;name&quot;:null }</code>）</li>
</ul>
<blockquote>
<p>小贴士：像数组、对象等这些“高级”类型可以互相无限嵌套</p>
</blockquote>
<p>很明显，Java中的数据类型和JSON中的值类型并不是一一对应的关系，那么这就需要<code>JsonGenerator</code>在写入时起到一个桥梁（适配）作用：<br><img data-src="https://img-blog.csdnimg.cn/20200716143504786.png" alt=""><br>下面针对不同的Value类型分别作出API讲解，给出示例说明。在此之前，请先记住两个结论，会更有利于你理解示例：</p>
<ul>
<li>JSON的顺序，和你write的顺序保持一致</li>
<li>写任何类型的Value之前请记得先write写key，否则可能无效</li>
</ul>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p><img data-src="https://img-blog.csdnimg.cn/20200716141127952.png" alt=""><br>可把Java中的String类型、Reader类型、char[]字符数组类型等等写为JSON的字符串形式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    <span class="keyword">try</span> (JsonGenerator jsonGenerator = factory.createGenerator(System.out, JsonEncoding.UTF8)) &#123;</span><br><span class="line">        jsonGenerator.writeStartObject();</span><br><span class="line"></span><br><span class="line">        jsonGenerator.writeFieldName(<span class="string">"zhName"</span>);</span><br><span class="line">        jsonGenerator.writeString(<span class="string">"A哥"</span>);</span><br><span class="line"></span><br><span class="line">        jsonGenerator.writeFieldName(<span class="string">"enName"</span>);</span><br><span class="line">        jsonGenerator.writeString(<span class="string">"YourBatman"</span>);</span><br><span class="line"></span><br><span class="line">        jsonGenerator.writeEndObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"zhName"</span>:<span class="string">"A哥"</span>,<span class="attr">"enName"</span>:<span class="string">"YourBatman"</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><p><img data-src="https://img-blog.csdnimg.cn/20200716143851555.png" alt=""><br>参考上例，不解释。</p>
<h4 id="对象（JSON-对象）"><a href="#对象（JSON-对象）" class="headerlink" title="对象（JSON 对象）"></a>对象（JSON 对象）</h4><p><img data-src="https://img-blog.csdnimg.cn/20200716151833420.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    <span class="keyword">try</span> (JsonGenerator jsonGenerator = factory.createGenerator(System.out, JsonEncoding.UTF8)) &#123;</span><br><span class="line">        jsonGenerator.writeStartObject();</span><br><span class="line"></span><br><span class="line">        jsonGenerator.writeFieldName(<span class="string">"zhName"</span>);</span><br><span class="line">        jsonGenerator.writeString(<span class="string">"A哥"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写对象（记得先写key 否则无效）</span></span><br><span class="line">        jsonGenerator.writeFieldName(<span class="string">"person"</span>);</span><br><span class="line">        jsonGenerator.writeStartObject();</span><br><span class="line">        jsonGenerator.writeFieldName(<span class="string">"enName"</span>);</span><br><span class="line">        jsonGenerator.writeString(<span class="string">"YourBatman"</span>);</span><br><span class="line">        jsonGenerator.writeFieldName(<span class="string">"age"</span>);</span><br><span class="line">        jsonGenerator.writeNumber(<span class="number">18</span>);</span><br><span class="line">        jsonGenerator.writeEndObject();</span><br><span class="line"></span><br><span class="line">        jsonGenerator.writeEndObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"zhName"</span>:<span class="string">"A哥"</span>,<span class="attr">"person"</span>:&#123;<span class="attr">"enName"</span>:<span class="string">"YourBatman"</span>,<span class="attr">"age"</span>:<span class="number">18</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对象属于一个比较特殊的value值类型，可以实现各种嵌套。也就是我们平时所说的JSON套JSON</p>
</blockquote>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>写数组和写对象有点类似，也会有先start再end的闭环思路。<br><img data-src="https://img-blog.csdnimg.cn/2020071615422269.png" alt=""><br>如何向数组里写入Value值？我们知道JSON数组里可以装任何数据类型，因此往里写值的方法都可使用，形如这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    <span class="keyword">try</span> (JsonGenerator jsonGenerator = factory.createGenerator(System.out, JsonEncoding.UTF8)) &#123;</span><br><span class="line">        jsonGenerator.writeStartObject();</span><br><span class="line"></span><br><span class="line">        jsonGenerator.writeFieldName(<span class="string">"zhName"</span>);</span><br><span class="line">        jsonGenerator.writeString(<span class="string">"A哥"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写数组（记得先写key 否则无效）</span></span><br><span class="line">        jsonGenerator.writeFieldName(<span class="string">"objects"</span>);</span><br><span class="line">        jsonGenerator.writeStartArray();</span><br><span class="line">        <span class="comment">// 1、写字符串</span></span><br><span class="line">        jsonGenerator.writeString(<span class="string">"YourBatman"</span>);</span><br><span class="line">        <span class="comment">// 2、写对象</span></span><br><span class="line">        jsonGenerator.writeStartObject();</span><br><span class="line">        jsonGenerator.writeStringField(<span class="string">"enName"</span>, <span class="string">"YourBatman"</span>);</span><br><span class="line">        jsonGenerator.writeEndObject();</span><br><span class="line">        <span class="comment">// 3、写数字</span></span><br><span class="line">        jsonGenerator.writeNumber(<span class="number">18</span>);</span><br><span class="line">        jsonGenerator.writeEndArray();</span><br><span class="line"></span><br><span class="line">        jsonGenerator.writeEndObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"zhName"</span>:<span class="string">"A哥"</span>,<span class="attr">"objects"</span>:[<span class="string">"YourBatman"</span>,&#123;<span class="attr">"enName"</span>:<span class="string">"YourBatman"</span>&#125;,<span class="number">18</span>]&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>理论上JSON数组里的每个元素可以是不同类型，但<strong>原则上</strong>请确保是同一类型哦</p>
</blockquote>
<p>对于JSON数组类型，很多时候里面装载的是数字或者普通字符串类型，因此<code>JsonGenerator</code>也很暖心的为此提供了专用方法（可以调用该方法来一次性便捷的写入单个数组）：<br><img data-src="https://img-blog.csdnimg.cn/20200716154341562.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    <span class="keyword">try</span> (JsonGenerator jsonGenerator = factory.createGenerator(System.out, JsonEncoding.UTF8)) &#123;</span><br><span class="line">        jsonGenerator.writeStartObject();</span><br><span class="line"></span><br><span class="line">        jsonGenerator.writeFieldName(<span class="string">"zhName"</span>);</span><br><span class="line">        jsonGenerator.writeString(<span class="string">"A哥"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快捷写入数组（从第index = 2位开始，取3个）</span></span><br><span class="line">        jsonGenerator.writeFieldName(<span class="string">"values"</span>);</span><br><span class="line">        jsonGenerator.writeArray(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        jsonGenerator.writeEndObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"zhName"</span>:<span class="string">"A哥"</span>,<span class="attr">"values"</span>:[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]&#125;</span><br></pre></td></tr></table></figure>

<h4 id="布尔和null"><a href="#布尔和null" class="headerlink" title="布尔和null"></a>布尔和null</h4><p>比较简单，JsonGenerator各提供了一个方法供你使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeBoolean</span><span class="params">(<span class="keyword">boolean</span> state)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeNull</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    <span class="keyword">try</span> (JsonGenerator jsonGenerator = factory.createGenerator(System.out, JsonEncoding.UTF8)) &#123;</span><br><span class="line">        jsonGenerator.writeStartObject();</span><br><span class="line"></span><br><span class="line">        jsonGenerator.writeFieldName(<span class="string">"success"</span>);</span><br><span class="line">        jsonGenerator.writeBoolean(<span class="keyword">true</span>);</span><br><span class="line">        jsonGenerator.writeFieldName(<span class="string">"myName"</span>);</span><br><span class="line">        jsonGenerator.writeNull();</span><br><span class="line"></span><br><span class="line">        jsonGenerator.writeEndObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"success"</span>:<span class="keyword">true</span>,<span class="string">"myName"</span>:<span class="keyword">null</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组合写JSON-Key和Value"><a href="#组合写JSON-Key和Value" class="headerlink" title="组合写JSON Key和Value"></a>组合写JSON Key和Value</h3><p>在写每个value之前，都必须写key。为了<strong>简化书写</strong>，JsonGenerator提供了二合一的组合方法，一个顶两：<br><img data-src="https://img-blog.csdnimg.cn/20200716161328124.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    <span class="keyword">try</span> (JsonGenerator jsonGenerator = factory.createGenerator(System.out, JsonEncoding.UTF8)) &#123;</span><br><span class="line">        jsonGenerator.writeStartObject();</span><br><span class="line"></span><br><span class="line">        jsonGenerator.writeStringField(<span class="string">"zhName"</span>,<span class="string">"A哥"</span>);</span><br><span class="line">        jsonGenerator.writeBooleanField(<span class="string">"success"</span>,<span class="keyword">true</span>);</span><br><span class="line">        jsonGenerator.writeNullField(<span class="string">"myName"</span>);</span><br><span class="line">        <span class="comment">// jsonGenerator.writeObjectFieldStart();</span></span><br><span class="line">        <span class="comment">// jsonGenerator.writeArrayFieldStart();</span></span><br><span class="line"></span><br><span class="line">        jsonGenerator.writeEndObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"zhName"</span>:<span class="string">"A哥"</span>,<span class="attr">"success"</span>:<span class="literal">true</span>,<span class="attr">"myName"</span>:<span class="literal">null</span>&#125;</span><br></pre></td></tr></table></figure>
<p>实际使用时，<strong>推荐使用这些组合方法</strong>去简化书写，毕竟新盖中盖高钙片，一片能顶过去2片，效率高。<br><img data-src="https://img-blog.csdnimg.cn/20200716161708643.png" alt=""></p>
<h3 id="其它写方法"><a href="#其它写方法" class="headerlink" title="其它写方法"></a>其它写方法</h3><p>如果说上面写方法是必修课，那下面的write写方法就当选修课吧。</p>
<p><strong>writeRaw()和writeRawValue()</strong>：<br><img data-src="https://img-blog.csdnimg.cn/2020071616500318.png" alt=""><br>该方法将强制生成器<strong>不做任何修改</strong>地逐字复制输入文本（包括不进行转义，也不添加分隔符，即使上下文[array，object]可能需要这样做）。如果需要这样的分隔符，请改用writeRawValue方法。</p>
<blockquote>
<p>绝大多数情况下，使用writeRaw()就够了，writeRawValue的使用场景愈发的少</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    <span class="keyword">try</span> (JsonGenerator jsonGenerator = factory.createGenerator(System.out, JsonEncoding.UTF8)) &#123;</span><br><span class="line">        jsonGenerator.writeRaw(<span class="string">"&#123;'name':'YourBatman'&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;'name':'YourBatman'&#125;</span><br></pre></td></tr></table></figure>
<p>如果换成<code>writeString()</code>方法，结果为（请注意比较差异）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">"&#123;'name':'YourBatman'&#125;"</span></span><br></pre></td></tr></table></figure>


<p><strong>writeBinary()</strong>：<br><img data-src="https://img-blog.csdnimg.cn/20200716165057929.png" alt=""><br>使用Base64编码把数据写进去。</p>
<p><strong>writeEmbeddedObject()</strong>：<br>2.8版本新增的方法。看看此方法的源码你就知道它是什么意思，不解释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeEmbeddedObject</span><span class="params">(Object object)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 01-Sep-2016, tatu: As per [core#318], handle small number of cases</span></span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">        writeNull();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (object <span class="keyword">instanceof</span> <span class="keyword">byte</span>[]) &#123;</span><br><span class="line">        writeBinary((<span class="keyword">byte</span>[]) object);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> JsonGenerationException(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>writeObject()</strong>（重要）：<br>写POJO，但前提是你必须给<code>JsonGenerator</code>指定一个<code>ObjectCodec</code>解码器才能正常work，否则抛出异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalStateException: No ObjectCodec defined <span class="keyword">for</span> the generator, <span class="function">can only serialize simple wrapper <span class="title">types</span> <span class="params">(type passed cn.yourbatman.jackson.core.beans.User)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	at com.fasterxml.jackson.core.JsonGenerator.<span class="title">_writeSimpleObject</span><span class="params">(JsonGenerator.java:<span class="number">2238</span>)</span></span></span><br><span class="line"><span class="function">	at com.fasterxml.jackson.core.base.GeneratorBase.<span class="title">writeObject</span><span class="params">(GeneratorBase.java:<span class="number">391</span>)</span></span></span><br><span class="line"><span class="function">	...</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是，Jackson里我们最为熟悉的API <code>ObjectMapper</code>它就是一个ObjectCodec解码器，具体我们在<strong>数据绑定</strong>章节会再详细讨论，下面我给出个简单的使用示例模拟一把：</p>
<p>准备一个User对象，以及解码器UserObjectCodec：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"YourBatman"</span>;</span><br><span class="line">    <span class="keyword">private</span> Integer age = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义ObjectCodec解码器 用于把User写为JSON</span></span><br><span class="line"><span class="comment">// 因为本例只关注write写，因此只需要实现此这一个方法即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserObjectCodec</span> <span class="keyword">extends</span> <span class="title">ObjectCodec</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeValue</span><span class="params">(JsonGenerator gen, Object value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        User user = User<span class="class">.<span class="keyword">class</span>.<span class="title">cast</span>(<span class="title">value</span>)</span>;</span><br><span class="line"></span><br><span class="line">        gen.writeStartObject();</span><br><span class="line">        gen.writeStringField(<span class="string">"name"</span>,user.getName());</span><br><span class="line">        gen.writeNumberField(<span class="string">"age"</span>,user.getAge());</span><br><span class="line">        gen.writeEndObject();</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test11</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    <span class="keyword">try</span> (JsonGenerator jsonGenerator = factory.createGenerator(System.err, JsonEncoding.UTF8)) &#123;</span><br><span class="line">        jsonGenerator.setCodec(<span class="keyword">new</span> UserObjectCodec());</span><br><span class="line"></span><br><span class="line">        jsonGenerator.writeObject(<span class="keyword">new</span> User());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"YourBatman"</span>,<span class="string">"age"</span>:<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure>
<p>😄这就是<code>ObjectMapper</code>的原理雏形，是不是开始着道了？😄</p>
<p><strong>writeTree()</strong>：<br>顾名思义，它便是Jackson大名鼎鼎的<strong>树模型</strong>。可惜的是core模块并没有提供树模型TreeNode的实现，以及它也是得依赖于ObjectCodec才能正常完成解码。</p>
<p>方法用来编写给定的JSON树（表示为树，其中给定的JsonNode是根）。这通常只调用给定节点的writeObject，但添加它是为了方便起见，并使代码在专门处理树的情况下更显式。</p>
<p>可能你会想，已经有了<code>writeObject()</code>方法还要它干啥呢？这其实是蛮有必要的，因为有时候你并不想定义POJO时，就可以用它快速写/读数据，同时它也可以达到<strong>模糊掉类型的概念</strong>，做到更抽象和更公用。</p>
<blockquote>
<p>说到模糊掉类型的的操作，你也可以辅以Spring的<code>AnnotationAttributes</code>的设计和使用来理解</p>
</blockquote>
<p>准备一个TreeNode的实现UserTreeNode：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserTreeNode</span> <span class="keyword">implements</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserTreeNode</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UserObjectCodec改写如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserObjectCodec</span> <span class="keyword">extends</span> <span class="title">ObjectCodec</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeValue</span><span class="params">(JsonGenerator gen, Object value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        User user = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> User) &#123;</span><br><span class="line">            user = User<span class="class">.<span class="keyword">class</span>.<span class="title">cast</span>(<span class="title">value</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> TreeNode) &#123;</span><br><span class="line">            user = UserTreeNode<span class="class">.<span class="keyword">class</span>.<span class="title">cast</span>(<span class="title">value</span>).<span class="title">getUser</span>()</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        gen.writeStartObject();</span><br><span class="line">        gen.writeStringField(<span class="string">"name"</span>, user.getName());</span><br><span class="line">        gen.writeNumberField(<span class="string">"age"</span>, user.getAge());</span><br><span class="line">        gen.writeEndObject();</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>书写测试用例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test12</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">    <span class="keyword">try</span> (JsonGenerator jsonGenerator = factory.createGenerator(System.err, JsonEncoding.UTF8)) &#123;</span><br><span class="line">        jsonGenerator.setCodec(<span class="keyword">new</span> UserObjectCodec());</span><br><span class="line">        jsonGenerator.writeObject(<span class="keyword">new</span> UserTreeNode(<span class="keyword">new</span> User()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"YourBatman"</span>,<span class="attr">"age"</span>:<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure>
<p>本案例绕过了<code>TreeNode</code>的真实处理逻辑，是因为<strong>树模型</strong>这块会放在databind数据绑定模块进行更加详细的描述，后面再会喽。</p>
<blockquote>
<p>说明：Jackson的树模型是比较重要的，当然直接使用core模块的树模型没有意义，所以这里先卖个关子，保持好奇心哈😄</p>
</blockquote>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>国人很喜欢把Jackson的序列化（写JSON）效率和Fastjson进行对比，那么你敢使用本文的流式API和Fastjson比吗？结果你猜一下呢？</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了jackson-core模块的流式API，以及JsonGenerator写JSON的使用，相信对你理解Jackson生成JSON方面是有帮助的。它作为JSON处理的基石，虽然并不推荐直接使用，但仅仅是<strong>应用开发级别</strong>不推荐哦，如果你是个框架、中间件开发者，这些原理你很可能绕不过。</p>
<p>还是那句话，本文介绍它的目的并不是建议大家去项目上使用，而是为了后面理解<code>ObjectMapper</code>夯实基础，毕竟做技术的要知其然，知其所以然了后，面对问题才能坦然。</p>]]></content>
      <categories>
        <category>A哥学Jackson</category>
      </categories>
      <tags>
        <tag>Jackson</tag>
        <tag>Fastjson</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>1. 初识Jackson -- 世界上最好的JSON库</title>
    <url>/x2y/dc384b1c.html</url>
    <content><![CDATA[<blockquote>
<p>要想人前显贵，必须背后受罪。关注公众号【<strong>BAT的乌托邦</strong>】开启专栏式学习，拒绝浅尝辄止。本文 <a href="https://www.yourbatman.cn">https://www.yourbatman.cn</a> 已收录，里面一并有Spring技术栈、MyBatis、中间件等小而美的专栏供以学习哦。</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20200707110839233.png#x200" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>各位小伙伴大家好，我是A哥。上篇文章 <a href="https://mp.weixin.qq.com/s/z6T9n9YvwjmDwuj-YTa0_w" target="_blank" rel="noopener">【Fastjson到了说再见的时候了】</a> A哥跟Fastjson说了拜拜，从本系列开始，我们将一起进入Jackson库的学习。当然喽说它是世界上最好的JSON库并非一家之言，是官网上它自己说的，我免责申明哈。</p>
<p><img data-src="https://img-blog.csdnimg.cn/2020070711185561.png#x200" alt=""></p>
<h2 id="一个工程仅需一个JSON库"><a href="#一个工程仅需一个JSON库" class="headerlink" title="一个工程仅需一个JSON库"></a>一个工程仅需一个JSON库</h2><p>Java的JSON库，你<strong>至少</strong>应该用过/听过这三种：<code>Jackson、Gson、Fastjson</code>。一个独立的工程，按照依赖最少原则，本应该only one JSON库是足矣的。但现状是：各位同仁可观察观察各自的项目，大都同时存在2种JSON库，亦或者3种甚至更多…</p>
<blockquote>
<p>说明：在<strong>同一个工程内</strong>，同一功能若有多种实现，实属不好的现象。这会让管理起来显得混乱（譬如对日期的格式化就不方便做到统一），出口若有多个，想收口时就是个大难题了</p>
</blockquote>
<p>作为一个<strong>合格的</strong>架构师/工程师，保持最简依赖(一致性依赖)是应该有的技术范，因为简单一致性它能带来很大的收益，道理很简单：两个Java程序员的沟通/协同效率，一定会比1个Java + 1个Python沟通效率高。</p>
<p>so what，我们应该选择哪一种JSON库呢？答案显而易见，那便是Jackson。因为它各个方面表现均非常优秀，是世界最流行、最好的JSON库。把<code>Jackson</code>作为工程唯一JSON库是有一丢丢门槛的（想想你为何使用Fastjson就知道啦），所以它来啦，祝你跨越此门槛，规范化使用，<strong>助你增加一项主流的硬核实力，这也是本专栏的最大意义所在</strong>。</p>
<hr>
<h2 id="Jackson是世界最好的JSON库"><a href="#Jackson是世界最好的JSON库" class="headerlink" title="Jackson是世界最好的JSON库"></a>Jackson是世界最好的JSON库</h2><p>Jackson是一个简单的、功能强大的、基于Java的<strong>应用库</strong>。它可以很方便完成<strong>Java对象</strong>和<strong>Json对象</strong>(xml文档or其它格式）进行互转。Jackson社区相对比较活跃，更新速度也比较快。Jackson库有如下几大特性：</p>
<ul>
<li>高性能且稳定：低内存占用，对大/小JSON串，大/小对象的解析表现均很优秀</li>
<li>流行度高：是很多流行框架的默认选择</li>
<li>容易使用：提供高层次的API，极大简化了日常使用案例</li>
<li>无需自己手动创建映射：内置了绝大部分序列化时和Java类型的映射关系</li>
<li>干净的JSON：创建的JSON具有干净、紧凑、体积小等特点</li>
<li>无三方依赖：仅依赖于JDK</li>
<li><strong>Spring生态加持</strong>：jackson是Spring家族的默认JSON/XML解析器（明白了吧，学完此专栏你对Spring都能更亲近些了，一举两得）</li>
</ul>
<p>版本约定：本专栏统一使用的版本号固定为<code>2.10.1</code>（2019-12-09发布），GAV如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>为了保持版本的统一性，后续的<code>Spring Boot（2.2.2.RELEASE）/Spring Framework（5.2.2.RELEASE）</code>使用的均为当前最新版本，因为它内置的jackson也恰好就是本专栏讲解的版本。</p>
<hr>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>细心的朋友从上面的<code>groupId</code>里可以看到：<code>jackson</code>它隶属于<code>fasterxml</code>这个组织。本着追本溯源的精神，可以稍微的了解了解这个组织：<a href="http://fasterxml.com/" target="_blank" rel="noopener">fasterxml官网</a> 截图如下</p>
<p><img data-src="https://img-blog.csdnimg.cn/20191227172623307.png#x200" alt=""><br>简单翻译：FasterXML是Woodstox流的XML解析器、Jackson流的JSON解析器、Aalto非阻塞XML解析器以及<strong>不断增长</strong>的实用程序库和扩展家族背后的业务。</p>
<p>作为一个高度流行的开源库，这种官网页面应该刷新了你的认知吧。并不是它内容不多，而其实是它的详细介绍都发布在<code>github</code>上了，这便是接下来我们来认识它的主要渠道。</p>
<blockquote>
<p>这种做法貌似已经成为了一种流行的趋势：越来越多的开源软件倾向于把github作为他们的Home Page了</p>
</blockquote>
<p><code>fasterxml</code>组织它<strong>直属的一级工程</strong>其实也有不少：</p>
<ol>
<li><strong>com.fasterxml.jackson</strong></li>
<li>com.fasterxml.uuid</li>
<li>com.fasterxml.woodstox</li>
<li>…</li>
</ol>
<p>很显然，<strong>本专栏仅仅只会关注jackson工程</strong>，该工程便是该组织最出名且最最最为重要的部分。</p>
<hr>
<h2 id="官网介绍"><a href="#官网介绍" class="headerlink" title="官网介绍"></a>官网介绍</h2><p>了解一门新的技术，第一步应该就是看它的官网。上面已然解释了，<code>fasterxml</code>组织它把各工程的首页内容都托管在了github上，Jackson当然也不例外。<a href="https://github.com/FasterXML/jackson" target="_blank" rel="noopener">Jackson官网</a> 上对它自己有如下描述：</p>
<p>Jackson旧称为：<strong>Java(或JVM平台)</strong>的标准JSON库，或者是Java的<strong>最佳JSON解析器</strong>，或者简称为“<strong>Java的JSON</strong>”</p>
<blockquote>
<p>从这名字就霸气外露了，NB得不行，足以见得它在JSON解析方面的地位和流行程度，当然主要是自信</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20200707113820299.png#x200" alt=""></p>
<p>更重要的是，Jackson是一套JVM平台的 <strong>数据处理（不限于JSON）</strong> 工具集：包括 <strong>一流的</strong> JSON解析器/ JSON生成器、数据绑定库(POJOs to and from JSON)；并且提供了相关模块来支持 Avro, BSON, CBOR, CSV, Smile, Properties, Protobuf, XML or YAML等数据格式，甚至还支持大数据格式模块的设置。</p>
<hr>
<h2 id="分支：1-x和2-x"><a href="#分支：1-x和2-x" class="headerlink" title="分支：1.x和2.x"></a>分支：1.x和2.x</h2><p>Jackson有两个主要的分支：</p>
<ul>
<li>1.x分支，处于维护模式，只发布bug修复版本（最近一次发布于Jul, 2013）</li>
<li>2.x是正在开发的版本（持续更新升级中，2.0.0发布于Mar, 2012）</li>
</ul>
<p>注意：这两个主要版本使用<strong>不同的Java包名</strong>和Maven GAV，因此它们并不相互兼容，<strong>但可以和平共存</strong>。一个项目可以同时依赖于这两个版本是没有冲突的。这是经过设计而为之，选择这种策略是为了更顺利地从1.x进行迁移2. x</p>
<blockquote>
<p>说明：现在都2020年了，1.x可以毫不客气的说已经淘汰了（除了非常老的项目还在用），因此针对1.x版本本专栏不会有任何涉猎。</p>
</blockquote>
<hr>
<h2 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h2><p>Jackson是个开源的、且开放的社区。下面列出的大多数项目/模块是由Jackson开发团队<strong>领导的</strong>，但也有一些来自Jackson社区的成员</p>
<hr>
<h3 id="三大核心模块"><a href="#三大核心模块" class="headerlink" title="三大核心模块"></a>三大核心模块</h3><p><strong>core module(核心模块) 是扩展模块构建的基础</strong>。Jackson目前有3个核心模块：</p>
<blockquote>
<p>说明：核心模块的groupId均为：<code>&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</code>，artifactId见下面各模块所示</p>
</blockquote>
<ul>
<li>Streaming流处理模块(<code>jackson-core</code>)：定义底层处理流的API：JsonPaser和JsonGenerator等，并包含<strong>特定于json</strong>的实现。</li>
<li>Annotations标准注解模块(<code>jackson-annotations</code>)：包含标准的Jackson注解</li>
<li>Databind数据绑定模块(<code>jackson-databind</code>)：在streaming包上实现数据绑定(和对象序列化)支持；<strong>它依赖于上面的两个模块</strong>，也是Jackson的高层API(如ObjectMapper)所在的模块</li>
</ul>
<p>实际应用级开发中，我们只会使用到Databind数据绑定模块，so它是本系列重中之重。下面介绍那些举足轻重的<strong>第三方模块</strong>。</p>
<hr>
<h3 id="数据类型模块"><a href="#数据类型模块" class="headerlink" title="数据类型模块"></a>数据类型模块</h3><p>这些扩展是Jackson插件模块(通过<code>ObjectMapper.registerModule()</code>注册，下同)，并通过添加序列化器和反序列化器来对各种常用Java库数据类型的支持，以便<code>Jackson databind</code>包(<code>ObjectMapper / ObjectReader / ObjectWriter</code>)能够顺利读写/转换这些类型。</p>
<p>第三方模块有些是Jackson官方人员直接lead和维护的（主流模块），也有些是纯社区行为。现在按照这两个分类分别介绍一下各个模块的作用：</p>
<p><strong>官方直接维护：</strong></p>
<blockquote>
<p>说明：官方维护的这些数据类型模块的groupId统一为：<code>&lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;</code>，且版本号是和主版本号保持一致的</p>
</blockquote>
<ul>
<li>标准集合数据类型模块：<ul>
<li>Guava：支持Guava的集合数据类型</li>
<li>HPPC：略</li>
<li>PCollections：略 (Jackson 2.7新增的支持)</li>
</ul>
</li>
<li>Hibernate：支持Hibernate的一些特性，如懒加载、proxy代理等</li>
<li>Joda：支持Joda date/time的数据类型</li>
<li>JDK7：对JDK7的支持（说明：2.7以后就无用了，以为2.7版本后最低的JDK版本要求是7）</li>
<li>Java8：它分为如下三个子模块来支持Java8<ul>
<li><code>jackson-module-parameter-names</code>：此模块能够访问构造函数和方法参数的名称，从而允许省略<code>@JsonProperty</code>（当然前提是你必须加了编译参数：<code>-parameters</code>）</li>
<li><code>jackson-datatype-jsr310</code>：支持Java8新增的JSR310时间API</li>
<li><code>jackson-datatype-jdk8</code>：除了Java8的时间API外其它的API的支持，如<code>Optional</code></li>
</ul>
</li>
<li>JSR-353/org.json：略</li>
</ul>
<p><strong>非官方直接维护：</strong></p>
<blockquote>
<p>说明：非官方直接维护的这些模块groupId是不定的，每个模块可能都不一样，并且它们的版本号不会随着官方的主版本号一起走</p>
</blockquote>
<ul>
<li>jackson-datatype-bolts：对 Yandex Bolts collection types 的支持</li>
<li>jackson-datatype-commons-lang3：支持Apache Commons Lang v3里面的一些类型</li>
<li>jackson-datatype-money：支持<code>javax.money</code></li>
<li>jackson-datatype-json-lib：对久远的<code>json-lib</code>这个库的支持</li>
<li>…</li>
</ul>
<hr>
<h3 id="数据格式模块"><a href="#数据格式模块" class="headerlink" title="数据格式模块"></a>数据格式模块</h3><p>Data format modules(数据格式模块)提供对<strong>JSON之外</strong>的数据格式的支持。它们中的大多数只是实现streaming API抽象，以便数据绑定组件可以按原样使用。</p>
<p><strong>官方直接维护：</strong></p>
<blockquote>
<p>说明：这些数据格式的模块的groupId均为<code>&lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;</code>，且跟着主版本号走</p>
</blockquote>
<ul>
<li>Avro/CBOR/Ion/Protobuf/Smile(binary JSON) ：这些均属于二进制的数据格式，它们的artifactId为：<code>&lt;artifactId&gt;jackson-dataformat-[FORMAT]&lt;/artifactId&gt;</code></li>
<li>CSV/Properties/<strong>XML/YAML</strong>：这些格式熟悉吧，同样的支持到了这些常用的文本格式</li>
</ul>
<p><strong>非官方直接维护：</strong><br>因非官方直接维护的模块过于偏门，因此省略</p>
<hr>
<h3 id="JVM平台其它语言"><a href="#JVM平台其它语言" class="headerlink" title="JVM平台其它语言"></a>JVM平台其它语言</h3><p>官网有说，Jackson是一个<strong>JVM平台</strong>的解析器，因此语言层面不局限于Java本身，还涵盖了另外两大主流JVM语言：Kotlin和Scala</p>
<blockquote>
<p>说明：这块的groupId均为：<code>&lt;groupId&gt;com.fasterxml.jackson.module&lt;/groupId&gt;</code>，版本号跟着主版本号走</p>
</blockquote>
<ul>
<li>jackson-module-kotlin：处理kotlin源生类型</li>
<li>jackson-module-scala_[scala版本号]：处理scala源生类型</li>
</ul>
<hr>
<h3 id="模式支持"><a href="#模式支持" class="headerlink" title="模式支持"></a>模式支持</h3><p>Jackson注解为POJO定义了预期的属性和预期的处理，除了Jackson本身将其用于读取/写入JSON和其他格式之外，它还允许生成<strong>外部模式</strong>。上面已讲述的数据格式扩展中包含了部分功能，但也仍还有许多独立的模式工具，如：</p>
<ul>
<li>Ant Task for JSON Schema Generation：使用Apache Ant时，使用Jackson库和扩展模块从Java类生成JSON</li>
<li>jackson-json-schema-maven-plugin：maven插件，用于生成JSON</li>
<li>…<blockquote>
<p>说明：本部分因实际应用场景实在太少，为了不要混淆主要内容，此部分后面亦不会再提及</p>
</blockquote>
</li>
</ul>
<hr>
<h3 id="Jackson-jr（用于移动端）"><a href="#Jackson-jr（用于移动端）" class="headerlink" title="Jackson jr（用于移动端）"></a>Jackson jr（用于移动端）</h3><p>虽然<code>Jackson databind</code>（如ObjectMapper）是通用数据绑定的良好选择，但它的<strong>占用空间（Jar包大小）</strong>和<strong>启动开销</strong>在某些领域可能存在问题：比如移动端，特别是对于轻量使用(读或写)。这种case下，完整的Jackson API是让人接受不了的。</p>
<p>由于所有这些原因，Jackson官方决定创建一个<strong>更简单、更小</strong>的库：Jackson jr。它仍旧构建在Streaming API之上，但不依赖于databind和annotation。因此，它的大小(jar和运行时内存使用)要小得多，它的API非常紧凑，所以适合APP等移动端。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.jr<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-jr-objects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>它仅仅只依赖了<code>jackson-core</code>模块，所以体积上控制得非常的好。Jackson单单三大核心模块大小合计1700KB左右（320 + 70 + 1370）。而Jackson jr的体积控制在了95KB（就算加上core模块的320也不到500KB）。</p>
<p>而对于开发Java后台的我们对内存并不敏感，简单易用、功能强大才是硬道理。因此<code>jackson-jr</code>只是在此处做个简单了解即可，本专栏后面也不会再提及。</p>
<hr>
<h2 id="漏洞报告"><a href="#漏洞报告" class="headerlink" title="漏洞报告"></a>漏洞报告</h2><p>Jackson虽然已经足够稳定并且安全了，但哪有圣人呢。针对它的相关漏洞报告，最近一次发生在<code>2019-07-23</code>：<a href="https://www.seebug.org/vuldb/ssvid-98029" target="_blank" rel="noopener">FasterXML jackson-databind 远程代码执行(CVE-2019-12384)</a><br>更多、更新的详细漏洞报告参考链接（持续更新中）：<a href="https://www.seebug.org/appdir/Jackson" target="_blank" rel="noopener">知道创宇Jackson漏洞报告</a></p>
<hr>
<h2 id="Java-JSON库比较"><a href="#Java-JSON库比较" class="headerlink" title="Java JSON库比较"></a>Java JSON库比较</h2><p>市面上的JSON库非常之多，综合一些Java人员的意见，关于使用哪个库，这里有一些现有的独立比较的链接供以你参考：</p>
<ul>
<li><a href="https://www.developer.com/lang/jscript/top-7-open-source-json-binding-providers-available-today.html" target="_blank" rel="noopener">Top 7 Open-Source JSON-binding providers</a></li>
<li><a href="https://dzone.com/articles/be-lazy-productive-android" target="_blank" rel="noopener">Be a Lazy but a Productive Android Developer, Part 3: JSON Parsing Library</a></li>
<li><a href="https://www.linkedin.com/groups/Can-anyone-recommend-good-Java-50472.S.226644043" target="_blank" rel="noopener">“Can anyone recommend a good Java JSON library” (Linked-In group)</a></li>
<li><a href="http://thetarah.com/2012/09/21/which-json-library-should-i-use-in-my-android-and-java-projects/" target="_blank" rel="noopener">“Which JSON library to use on Android?”</a></li>
</ul>
<p>说明：此处贴出的几个参考链接均为官网给出的参考文章，均为国外较权威的文献。</p>
<p>当然天朝的你可能更关心Jackson和Fastjson的对比，那暂先不用着急（虽然上文也比较过），这是本专栏后面的一道主菜，那里会详细道来。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文结合官网认识了Jackson的全貌，用全面的视角整体上把握到了Jackson所提供的功能模块，这为专栏后续的讲解提供一个索引。</p>
<p>从Jackson的<strong>升级之快、模块支持之多</strong>足矣看得见它社区的活跃。并且为了迎合市场它在<code>2.10</code>版本后还提供了商业支持的服务：与Tidelift公司合作，为用户构建应用程序的开源依赖项提供商业支持和维护。节省时间、降低风险和改善代码健康状况（商业支持是收费的）。</p>
<p>相信通过本文你对Jackson有了个大概的了解，不出意外你应该是有兴趣去学它了的。当你深入研究后会发现它的<strong>设计之优雅，扩展性之强</strong>，不是一般国产类库所能比拟的。如果说Fastjson是一个优秀的JSON库，那么Jackson就是一个更优秀的JSON生态。</p>
<hr>
<p><strong>本专栏在CSDN付费，在公众号全部免费公开，欢迎你关注A哥的公众号【BAT的乌托邦】</strong></p>]]></content>
      <categories>
        <category>A哥学Jackson</category>
      </categories>
      <tags>
        <tag>Jackson</tag>
        <tag>Fastjson</tag>
        <tag>JSON库</tag>
      </tags>
  </entry>
  <entry>
    <title>Fastjson到了说再见的时候了</title>
    <url>/x2y/221f1084.html</url>
    <content><![CDATA[<blockquote>
<p>专注Java领域分享、成长，拒绝浅尝辄止<br><strong>作者</strong>：<a href="https://www.yourbatman.cn/about/">A哥（YourBatman）</a><br><strong>公众号</strong>：BAT的乌托邦（ID：BAT-utopia）<br><strong>个人博客</strong>：<a href="https://www.yourbatman.cn/">https://www.yourbatman.cn</a>，已收录本文</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>各位小伙伴大家好，我是A哥。停更1个月后回归啦，今天咱们聊聊一个比较有意思的话题：是否真的需要跟Fastjson说再见了？<br><img data-src="https://img-blog.csdnimg.cn/20200622172605662.png#x260" alt=""></p>
<h2 id="我的态度"><a href="#我的态度" class="headerlink" title="我的态度"></a>我的态度</h2><p>我在CSDN写过好些篇关于JSON的文章，特别是2020年专门写了一个付费专栏：<code>享学Jackson</code><br><img data-src="https://img-blog.csdnimg.cn/2020062218500935.png#x100" alt=""><br><img data-src="https://img-blog.csdnimg.cn/20200701071842704.png#x100" alt=""><br>这个专栏“销量”在我心目中还凑合，4个月“卖出”200份的样子（虽不值一提，但我很满足了😄），小小的一个JSON库而已，热度可见一斑。专栏里不可避免的提到了Jackson和Fastjson的比较，我本人一直持中立态度，主要原因有二：</p>
<ol>
<li>两者都很流行（国内Fastjson流行度甚至超过Jackson），因此平时开发中我<strong>两者都用</strong>（需要随大流嘛）</li>
<li>国产开源软件是需要被支持的，即使现在还存在差距（联想下<strong>最初的</strong>国产手机和苹果手机的差距，再看看现在呢？）</li>
</ol>
<p>当然，本文不一样了，必须得加点料。态度中立并不代表没有偏向：很明显我偏向于使用Jackson作为你的 <strong>唯一</strong> JSON库。<br><img data-src="https://img-blog.csdnimg.cn/20200622160236785.png#x260" alt=""></p>
<hr>
<hr>
<p><strong>从本文起</strong>，我将把CSDN里该付费专栏<strong>全部内容</strong>搬到公众号，免费助你轻松拥抱世界上最好的JSON库：Jackson。<br><strong>从本文起</strong>，我将把CSDN里该付费专栏<strong>全部内容</strong>搬到公众号，免费助你轻松拥抱世界上最好的JSON库：Jackson。<br><strong>从本文起</strong>，我将把CSDN里该付费专栏<strong>全部内容</strong>搬到公众号，免费助你轻松拥抱世界上最好的JSON库：Jackson。</p>
<blockquote>
<p>市面上并无成体系介绍Jackson的教程（官网都木有），独此一家哦。当然喽，这必将损伤到我的CSDN专栏售卖权益（小钱也是钱嘛😄），所以希望你关注公众号，关注此专栏，然后学到手我就觉得值了</p>
</blockquote>
<hr>
<hr>
<p>2020-05-30阿里云应急响应中心监测到Fastjson爆发新的反序列化远程代码执行漏洞，黑客利用漏洞，可绕过autoType限制，直接远程执行任意命令攻击服务器，<strong>风险极大</strong>（话外音：此bug必须Fix）。幸运的是，官方的响应速度非常快：<br><img data-src="https://img-blog.csdnimg.cn/20200622190151492.png##x100" alt=""><br>还记得上一次Fastjson <strong>高级别风险</strong> 安全漏洞是什么时候吗？是的，它就发生在2019-09-04，两次相距着实不远，不满你说我还记忆犹新呢，我司安全部门发的邮件还能找到😄。</p>
<blockquote>
<p>当然，之前也有些漏洞问题，但关注度不如这两次。主要是这两次时间相近，危险级别非常高影响面很大，所以社区反应较为强烈</p>
</blockquote>
<p>这两次“相邻”的安全漏洞着实把Fastjson推到了风口浪尖，吃瓜群众一波接一波，一时间 <strong>“弃用Fastjson，拥抱Jackson/Gson”</strong> 的声音不绝于耳。这很容易理解，因为谁都不情愿时不时收到公司安全部门的这种邮件：<br><img data-src="https://img-blog.csdnimg.cn/20200701173929379.png#x260" alt=""><br>针对此漏洞，虽说咱们Fix起来步骤简单：升级Fastjson的版本，然后重启应用。看起来毫不费力，实则是个大坑。你是否曾想过这个问题：倘若有上百个、几百个Java应用呢？且不谈你操作上的时间和人力成本有多高，单单<strong>管理</strong>起来的工作量也不容小觑。所以如果你是技术Leader，胸中的怒火释放一下是在情理之中的。</p>
<blockquote>
<p>相信很少有部门/团队把Spring Boot应用做成<strong>Jar包分离</strong>的形式的吧~因此大概率都需要经过升版本 -&gt; 提交代码 -&gt; 合代码 -&gt; 上pre -&gt; 上线 -&gt; 验证等步骤，so还是比较麻烦的</p>
</blockquote>
<hr>
<h2 id="你为何用Fastjson？"><a href="#你为何用Fastjson？" class="headerlink" title="你为何用Fastjson？"></a>你为何用Fastjson？</h2><p>这个问题你可以问自己，也可以问身边的同事。汇总一下就是答案，这才是来自用户最真实的声音嘛。我针对此也简单“调查”过，把我听到的了解到的汇总为如下三点：</p>
<ol>
<li>API简单（static方法直接使用），上手快，对开发者友好</li>
<li>阿里巴巴出品，背靠大厂值得信赖. </li>
<li>社区相对活跃，维护升级有保障</li>
</ol>
<p>容我猜猜，这3个理由大概率命中了你心中所想吧😄？有大厂做背书自然能给产品加分，但自身优秀才是硬道理。虽然原因有三点，但我认为让很多人决定去使用它、赞它的最最最主要原因其实就一点：<strong>API简单，static方法直接调用对开发者友好</strong>。</p>
<p>我感觉对于大多数Java Coder（特别对于初学者）来说，使用时会有这样的一种情节在里面：静态方法的逼格比实例方法高。而实际上不应该是这样子的，初学者（初/中级选手）热爱使用静态方法，而高手在设计一个库/框架时应在静态方法+实例方法间运用自如。一味地、过多地使用静态方法只会让你的的思维倾向于<strong>面向过程</strong>，而非更好的利用Java <strong>面向对象</strong> 的特性，因此高下立判。</p>
<blockquote>
<p>没有孰优孰劣，适合的才是最好的</p>
</blockquote>
<p>发现了没，使用Fastjson的原因中，我们至始至终都没有提到性能高/速度快等字眼，但这却是Fastjson最最最为核心的特性，可谓是它能立足于众多JSON库中、“脱颖而出”的立身之本。岂不怪哉，我们使用它竟<strong>不是</strong>因为它最核心的特性有多好，那这是为何呢？<br><img data-src="https://img-blog.csdnimg.cn/2020070118342039.png#x260" alt=""></p>
<hr>
<h2 id="你为何仍在用Fastjson？"><a href="#你为何仍在用Fastjson？" class="headerlink" title="你为何仍在用Fastjson？"></a>你为何仍在用Fastjson？</h2><p>原因可以说出5678种，总而言之言而总之，你不（敢）切换的原因或许只有一个：Fastjson的静态方法调用用着省心；最重要的是，<strong>对其它JSON库（如Jackson/Gson）并不熟悉</strong>不敢切换。</p>
<p>我认为<strong>害怕来自于未知</strong><br><img data-src="https://img-blog.csdnimg.cn/20200629070547714.png#x260" alt=""><br>不可否认Jackson/Gson的使用门槛的确比Fastjson高那么一丢丢，但这绝不是你拒绝去使用它的理由。受Fastjson这“连续”两次高危漏洞影响，A哥更加坚定了把Jackson当作 <strong>唯一</strong> JSON库的决心，甚至在团队内<strong>严令禁止使用Fastjson</strong>。大家统一了语言/工具，更能提高生产力~</p>
<p>如果你也是因为不太了解Jackson而不敢离开温室，那么看到本文就很幸运了，本系列会免费带你拥抱Jackson这个高级JSON库，功能上比Fastjson强了不止一点点。</p>
<hr>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>坊间在某坛里看到这样一句言论：<strong>若你还依赖于使用Fastjson，那么你大概率还只是初/中级水平</strong>。这句话必然让Fastjson的忠实用户火冒三丈，抄起家伙嘎嘎就是干。话出必然有因，那么这句话是否真的言过于词呢？接下来就絮叨絮叨</p>
<p>我很愿意用<strong>存在即合理</strong>原则来表达一个观点：Fastjson出个bug就能有这么高的关注度，不可否认这本身就是一种成功。</p>
<blockquote>
<p>误区描述：“合理”请不要误读为“合乎情理”之类，而是当做“理由”来讲。“存在即合理”正确理解为：一切存在的事物都有它存在的理由</p>
</blockquote>
<p>任何技术能够流行起来，well-known被我们所熟知必然有它的优势，哪怕这个过人之处<strong>只有一个</strong>。下面我们来看看为何Fastjson能一步步被宠爱，它的魔力到底在哪？</p>
<blockquote>
<p>技术选型不应该像相亲：肯定你只需要一个理由，而否定你却能…</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20200630071300475.png#x260" alt=""></p>
<hr>
<h2 id="Why-Fastjson？"><a href="#Why-Fastjson？" class="headerlink" title="Why Fastjson？"></a>Why Fastjson？</h2><p>虽然最近Fastjson由于出现安全漏洞，社区言论一边倒。即使如此，几乎没人直接否定过Fastjson本身的优秀，特别是当你知道这个使用广泛的库几乎全部来自于一人之手时。他就是匠人温少：<br><img data-src="https://img-blog.csdnimg.cn/20200622153533596.png#x260" alt="图片来源于开源中国"></p>
<blockquote>
<p>值得一提的是：温少另一个开源项目Druid是国内<strong>最</strong>流行的（甚至没有之一）数据库连接池产品，广受好评</p>
</blockquote>
<p>成人只看利弊，小孩才分对错。为何要使用它能流行开来，那必然是因为它优秀。它优秀品质在其官网可一览无遗：<br><img data-src="https://img-blog.csdnimg.cn/20200630072342330.png#x160" alt="截图来自于Fastjson官网"><br>这些“优点”用中文描述出来更加直（震）观（撼）：</p>
<h3 id="1、速度快"><a href="#1、速度快" class="headerlink" title="1、速度快"></a>1、速度快</h3><p>fastjson相对其他JSON库的特点是快，从2011年fastjson发布1.1.x版本之后，其性能<strong>从未被</strong>其他Java实现的JSON库超越。</p>
<blockquote>
<p>话外音：速度/性能这一块，Fastjson一直拿捏得死死的</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20200630073524542.gif#x160" alt=""></p>
<h3 id="2、使用广泛"><a href="#2、使用广泛" class="headerlink" title="2、使用广泛"></a>2、使用广泛</h3><p>fastjson在阿里巴巴大规模使用，在数万台服务器上部署，fastjson在业界被广泛接受。在2012年被开源中国评选为最受欢迎的国产开源软件之一。</p>
<blockquote>
<p>话外音：阿里巴巴数以万计的大规模集群实例做规模背书，说服力杠杠的</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20200630073638950.png#x160" alt=""></p>
<h3 id="3、测试完备"><a href="#3、测试完备" class="headerlink" title="3、测试完备"></a>3、测试完备</h3><p>fastjson有非常多的testcase，在1.2.11版本中，testcase超过3321个。每次发布都会进行回归测试，保证质量稳定。</p>
<blockquote>
<p>话外音：单测覆盖率高，代码健壮性有保证</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20200630073803595.png#x160" alt=""></p>
<h3 id="4、使用简单"><a href="#4、使用简单" class="headerlink" title="4、使用简单"></a>4、使用简单</h3><p>fastjson的API十分简洁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String text = JSON.toJSONString(obj); <span class="comment">//序列化</span></span><br><span class="line">VO vo = JSON.parseObject(<span class="string">"&#123;...&#125;"</span>, VO<span class="class">.<span class="keyword">class</span>)</span>; <span class="comment">//反序列化</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>话外音：不管你是小白还是小小白，轻松上手，使用起来都无障碍</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20200630073840692.png#x160" alt=""></p>
<h3 id="5、功能完备"><a href="#5、功能完备" class="headerlink" title="5、功能完备"></a>5、功能完备</h3><p>支持泛型，支持流处理超大文本，支持枚举，支持序列化和反序列化扩展。</p>
<blockquote>
<p>话外音：我这一家就够了，你要的，这都有</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20200630074119345.png#x260" alt=""></p>
<hr>
<h2 id="Why-Not-Fastjson？"><a href="#Why-Not-Fastjson？" class="headerlink" title="Why Not Fastjson？"></a>Why Not Fastjson？</h2><p><img data-src="https://img-blog.csdnimg.cn/20200620162515660.png" alt=""><br>文首有表态本文我是有态度和有偏向的，因此不来几点原因实则不妥。那么我就针对于官网列出的5点（见上），给出个人观点供以参考。是否言过于辞，咱们拿出另外一个JSON库做出对比，本文以Jackson为例。</p>
<hr>
<h3 id="版本约定"><a href="#版本约定" class="headerlink" title="版本约定"></a>版本约定</h3><p>因为要做比较嘛，所以对使用的JSON库做出版本约定：</p>
<ul>
<li>Jackson：2.10.1<ul>
<li>演示代码均使用最常用的<strong>高层API</strong>，而非底层API。毕竟用底层API去PK Fastjson并不公平，毕竟那并不常用</li>
</ul>
</li>
<li>Fastjson：1.2.72<ul>
<li>only one jar</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1、速度上并没有那么的快"><a href="#1、速度上并没有那么的快" class="headerlink" title="1、速度上并没有那么的快"></a>1、速度上并没有那么的快</h3><p>速度快/性能高是Fastjson <strong>最最最最最最</strong> 大的“卖点”，可谓是<strong>立身之本</strong>，从它的命名以及它的logo设计上你都能感受到这一点。</p>
<p>没有调研就没有发言权，本文针对于<strong>最常用</strong>的使用场景来一波测试对比（对比尽量公正，切勿钻牛角尖）。关于Fastjson和Jackson在性能PK这一块，网上的案例有不少，我自己也书写了多个场景的比较代码。但最终我还是决定引用Robin的结果展示给大家，我看了他的测试方案（代码）更加专业些：<a href="https://zhuanlan.zhihu.com/p/99123002" target="_blank" rel="noopener">几种常用 JSON 库性能比较</a>，结论如下两张图</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200701161604410.png#x260" alt="序列化"><br><img data-src="https://img-blog.csdnimg.cn/20200701161604416.png#x260" alt="反序列化"><br>总的结论：除了<code>Json-lib</code>是来搞笑的（它早已停止更新，切勿在生产上使用），Fastjson、Jsckson、Gson三者不分伯仲，差异性较小。<br><img data-src="https://img-blog.csdnimg.cn/20200620155220213.png" alt=""></p>
<blockquote>
<p>综合各种测试case，网上的 + 我自己写的测试用例，三者在性能方面除了Gson稍微差点外，Jackson和Fastjson在速度上可认为是差不多的（甚至Jackson综合性能表现更好）</p>
</blockquote>
<p><strong>既然差异性这么小，Fastjson一味的强调它是最快的真的有意义吗？</strong></p>
<hr>
<h4 id="JSON的解析速度绝不会制约系统的性能"><a href="#JSON的解析速度绝不会制约系统的性能" class="headerlink" title="JSON的解析速度绝不会制约系统的性能"></a>JSON的解析速度绝不会制约系统的性能</h4><p>比如我们一次REST调用环节全流程可能100ms；其中操作一次数据库，可能需要几十ms；序列化反序列化一次json <strong>一般只需要几ms</strong>；也就是说不同的json库，性能相差都在毫秒间；在一次REST调用全流程里，不同的JSON库在性能表现上影响甚微。</p>
<p>在现代应用程序中，即使最慢的Gson，也是满足需求的；解析文档速度的快慢，并不能作为选型的唯一标准，可能连主要标准都算不上。对IO优化、网络优化、并行处理等优化措施，远比选用一个更快的库更有效。</p>
<p>言而总之，如果你选择一个JSON库把性能当作了一个标准，就犯了方向性的错误。</p>
<hr>
<h3 id="2、并没有那么的流行"><a href="#2、并没有那么的流行" class="headerlink" title="2、并没有那么的流行"></a>2、并没有那么的流行</h3><p>使用广不广泛、流行度有多高这玩意是相对的。有一个最直观的数据，那就是在Maven中的引用量，我截图如下：<br><img data-src="https://img-blog.csdnimg.cn/2020070116254166.png" alt=""><br><img data-src="https://img-blog.csdnimg.cn/20200701162604932.png" alt=""><br><img data-src="https://img-blog.csdnimg.cn/20200701162620171.png" alt=""><br>从usages数值上看，似乎不在一个量级上。当然这么比较我个人认为不算特别客观，主要原因有二：</p>
<ol>
<li>开源的技术发展的越早，使用者越多，主流框架越支持（比如Spring MVC内置Jackson支持），就会形成聚集效应，赢者通吃</li>
<li>Fastjson起步较晚，且主要发力于国内</li>
</ol>
<p>不可否认Fastjson在国内的流行度是非常高的，甚至超过Jackson。否则最近一次的安全漏洞也不会有那么多人吃瓜嘛，但是这种“使用广泛”你也得辩证性的去看，毕竟在中国Java领域里，阿里巴巴是绝对的执牛耳者。</p>
<p>Fastjson的流行，是有着内在的原因的，比如这个无奈：<br><img data-src="https://img-blog.csdnimg.cn/20200702142954225.png?#x260" alt=""></p>
<hr>
<h3 id="3、测试真的完备吗？"><a href="#3、测试真的完备吗？" class="headerlink" title="3、测试真的完备吗？"></a>3、测试真的完备吗？</h3><p>额，这个我只能说：Fastjson自己知道就成，并无必要当作亮点show出来，毕竟使用者只关心出bug、出漏洞的频率和严重性，并不关心工程内部是如何保证健壮性的。</p>
<p>在使用者眼中：不出bug，一行单测没有都没关系。出了严重bug，有上万个test case也难以让人信服。</p>
<hr>
<h3 id="4、API真的简单吗？"><a href="#4、API真的简单吗？" class="headerlink" title="4、API真的简单吗？"></a>4、API真的简单吗？</h3><p>答：真的。文上有解释，这也许可能大概是你选择使用Jackson作为JSON库最重要的理由。 </p>
<p>当然，API使用简单针对于simple场景，对于复杂场景它也并不能简单应对。道理很简单，POP is simple,OOP is Complex。但恰好的是，在互联网应用场景中使用JSON库，大多属于简单场景，因此Fastjson把它当做一个亮点我觉得是无可厚非的。</p>
<hr>
<h3 id="5、功能并没有那么完备"><a href="#5、功能并没有那么完备" class="headerlink" title="5、功能并没有那么完备"></a>5、功能并没有那么完备</h3><p>官网强调了它是支持泛型、枚举等类型的序列化、反序列化的。但是对着JavaBean + JSON规范来讲，Fastjson有不少功能缺失（没遵循规范），这是A哥最为忍受不了的地方，因为它已经不能实现我的功能了。如果你基于它做过中间件开发、框架开发或者是DDD驱动设计开发，相信你也深有体会：<br><img data-src="https://img-blog.csdnimg.cn/20200702151128425.png?#x60" alt=""></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>真理是相对的，没有绝对的真理。真理是让人明白道理的，不是用来诡辩的，更不是用来抬扛的。</p>
<p>同样的，Fastjson还是Jackson也就没有标准的答案，各位还是结合自己的具体情况，见仁见智。本文只是阐述我的<strong>个人观点</strong>，表达了我的使用倾向，供以你决策时参考。</p>
<p>如果你和我一样，也想把<code>Jackson</code>作为你的<strong>唯一</strong> JSON库，那就关注我吧，接下来我会把付费专栏里的内容全部搬过来给你，免费助你平滑过渡到这个世界上最好的JSON库。<br><img data-src="https://img-blog.csdnimg.cn/20200630074132924.png?#x260" alt=""></p>]]></content>
      <categories>
        <category>A哥学Jackson</category>
      </categories>
      <tags>
        <tag>Jackson</tag>
        <tag>Fastjson</tag>
        <tag>安全漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>系统设计：你的service要用Dependency Injection吗?</title>
    <url>/x2y/5715d235.html</url>
    <content><![CDATA[<blockquote>
<p>当大潮退去，才知道谁在裸泳。<br><strong>作者</strong>：A哥（YourBatman）<br><strong>公众号</strong>：BAT的乌托邦（ID：BAT-utopia）<br><strong>文末是否有彩蛋</strong>：有</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>各位小伙伴大家好，我是A哥。<strong>以下文章来源于硅谷成长攻略 ，作者大西Xi</strong>。</p>
<p>依赖注入，它不仅仅是Spring，而是一种通用思想。本文硅谷大佬用简短的语句道出了其核心思想，值得参阅。</p>
<hr>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我最近在给一个Go service升级重构framework。我和一个朋友提了下，他点评到，搞这种基础升级，就是悟道啊，类似于《禅与摩托车维修艺术》。<br><img data-src="https://img-blog.csdnimg.cn/2020061807003859.png#x200" alt=""><br>他这个说法挺有道理的，大家平时写业务代码，更多是站在地面想着怎么快速完成目标。只有趁升级的时候，才有空飞在1000公里天上，想想为啥要这么设计的哲学问题。</p>
<p>今天就给大家介绍一个重要的基本设计原则：Dependency Injection。这个设计模式在复杂的业务service非常有用，没有它，每次改一个模块的初始化接口，你都要把用到这个模块的代码都改一遍，非常麻烦。</p>
<p><strong>今天很多主流的开源framework都用到了它</strong>，比如：</p>
<ul>
<li>Guice: Google 维护的一个基于Java的 lightweight dependency injection framework</li>
<li>Fx: Uber 维护的一个基于Go的dependency injection framework</li>
<li>AngularJS: Google 维护的基于JavaScript的前端 framework</li>
<li>Wire: Google维护的Compile-time Dependency Injection for Go</li>
</ul>
<hr>
<h3 id="什么是Dependency-Injection？"><a href="#什么是Dependency-Injection？" class="headerlink" title="什么是Dependency Injection？"></a>什么是Dependency Injection？</h3><p>这个翻译成中文叫做依赖注入，用大白话解释就是即插即用。</p>
<p>举个例子，假设你的service里面有个模块A叫“笔记本”，它有个依赖叫“耳机”，用了这个设计原则，你需要听音乐，只用插”耳机“就可以了。后端service中常见的“耳机”依赖有哪些？比如Logging，输出Metrics等。<br><img data-src="https://img-blog.csdnimg.cn/20200618070204992.png#x200" alt=""><br>下面的代码是用 <strong>Dependency Injection</strong> 创建模块A的伪代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">func <span class="title">CreateLaptopService</span><span class="params">()</span> *LaptopService </span>&#123;</span><br><span class="line">	panic(wire.Build(</span><br><span class="line">		wire.Struct(<span class="keyword">new</span>(Logger), <span class="string">"*"</span>),</span><br><span class="line">		NewHttpClient,</span><br><span class="line">		NewHeadphoneService,</span><br><span class="line">	))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="不用这个原则，有什么后果？"><a href="#不用这个原则，有什么后果？" class="headerlink" title="不用这个原则，有什么后果？"></a>不用这个原则，有什么后果？</h3><p>你需要自己搞一堆耳机的原材料，然后自己组装配置。模块A需要耳机的时候，手动装一遍，模块B需要耳机的时候，再手动装一遍。<br><img data-src="https://img-blog.csdnimg.cn/20200618070513198.png#x200" alt=""><br>下面是不用Dependency Injection，创建模块A的伪代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">func <span class="title">CreateLaptopService</span><span class="params">()</span> *LaptopService </span>&#123;</span><br><span class="line">	logger := &amp;Logger&#123;&#125;</span><br><span class="line">	headphone := &amp;Headphone&#123;&#125;</span><br><span class="line">	client := NewHttpClient(logger)</span><br><span class="line">	<span class="keyword">return</span> NewLaptopService(logger,client,headphone)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果service很简单，还可以忍受。但是在业务很复杂时，项目里有上百个依赖的时候就更痛苦了。每次配置”耳机“，你都需要手动把所有模块的接口配置一遍。<br><img data-src="https://img-blog.csdnimg.cn/2020061807072948.png#x200" alt=""><br>下面是不用<strong>Dependency Injection</strong>，再创建模块B的伪代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">func <span class="title">CreateDesktopService</span><span class="params">()</span> *DesktopService </span>&#123;</span><br><span class="line">	logger := &amp;Logger&#123;&#125;</span><br><span class="line">	headphone := &amp;Headphone&#123;&#125;</span><br><span class="line">	client := NewHttpClient(logger)</span><br><span class="line">	cdDisk := &amp;CdDisk&#123;&#125;</span><br><span class="line">	cdDrive := &amp;CdDrive&#123;cdDisk&#125;</span><br><span class="line">	headphone := &amp;Headphone&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> NewLaptopService(logger, client, headphone, cdDrive)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="优点一：减少依赖关系、方便重复使用"><a href="#优点一：减少依赖关系、方便重复使用" class="headerlink" title="优点一：减少依赖关系、方便重复使用"></a>优点一：减少依赖关系、方便重复使用</h4><p>有了Dependency Injection，每次配置时，模块A和模块B都是连接到同一个设置的耳机，你只要组装一次耳机。即使有100个模块都需要用耳机，你也只需要组装一次。<br><img data-src="https://img-blog.csdnimg.cn/2020061807103662.png#x200" alt=""></p>
<h4 id="优点二：提高可维护性"><a href="#优点二：提高可维护性" class="headerlink" title="优点二：提高可维护性"></a>优点二：提高可维护性</h4><p>而对于更复杂的场景，模块B依赖于一个”CD机“，而”CD机“又需要一个”CD碟片“。如果有100个类似的模块都有”CD机“，而你需要做的只是更改”CD机”里的CD碟片，有了Dependency Injection，你也可以省去在“电子厂”里面翻找所有”CD机“的时间，只需要换一张”CD碟片“。</p>
<h4 id="优点三：简化测试流程"><a href="#优点三：简化测试流程" class="headerlink" title="优点三：简化测试流程"></a>优点三：简化测试流程</h4><p>每次升级时，只需要测试”耳机“本身的性能，测试不需要和使用”耳机“的代码有任何关联。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后，划一下重点，Dependency Injection适用的场景，是复杂的大型系统，有很多个服务相互依赖的情况。它能够避免一些重复劳动带来的小错误，提高生产力。如果是一个人写的小玩具，那杀鸡就不用牛刀啦。</p>]]></content>
      <categories>
        <category>系统设计</category>
      </categories>
      <tags>
        <tag>依赖注入</tag>
        <tag>Dependency Injection</tag>
      </tags>
  </entry>
  <entry>
    <title>技术​选型的艺术</title>
    <url>/x2y/da0c5a61.html</url>
    <content><![CDATA[<blockquote>
<p>当大潮退去，才知道谁在裸泳。<br><strong>作者</strong>：A哥（YourBatman）<br><strong>公众号</strong>：BAT的乌托邦（ID：BAT-utopia）<br><strong>文末是否有彩蛋</strong>：有</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>各位小伙伴大家好，我是A哥。<strong>以下文章来源于softech华山论剑 ，作者徐凌云</strong>。</p>
<p>技术选型是个很大的话题。「灵活」与「高开发效率」是技术选型最看重的两点。感谢徐总的分享，很受用。</p>
<hr>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>关于技术选型，我们不少技术从业的朋友容易进一些误区，而这些误区大多俗话是某种技术开发思维定势在作怪。选型怕遇到喷子，也怕诋毁性总结。<br><img data-src="https://img-blog.csdnimg.cn/20200616195916535.png#x200" alt=""><br>技术选型没选好，每往前走一步，都可能变成挨揍的理由，也是让人心碎得理由。</p>
<hr>
<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>我相信自驱动的团队学习，意识提升，分析度量，团队信任，勇敢能做好选型的更好实践。当然技术选型中也存在着天时、地利、人和。技术选型的能力是一个各方面综合作用的能力，而不是仅仅我们认为的技术范畴。</p>
<p>很多技术同学对新技术有天生得冲动，有时候开发人员自己玩的很high，但项目却玩死了，这是作为技术管理者需要面对的魔鬼。这是件很悲哀的事情，我们需要抑制内心深处的魔鬼，技术只有跟业务有机的结合起来，产出所追求的价值，才是有意义的。</p>
<p>在工作中完成一次技术选型，绝不能简单的仅仅从纯技术角度出发思考。一次看似偶然的选型会给后续工作带来方向性的影响，这里的影响指的不光是技术层面，更多的是管理层面。这就如同在公司一次公开的项目招标中，考虑绝不仅仅是解决方案本身的优劣，更重要的考量方案的成本是否符合预期，方案提供方的实力、诚信度，甚至还要从商业模式上去思考未来的合作方式是什么，等等。而这一切，都能在一次技术选型的过程中，得以体现。下面就从几个主要阐述下选型中遇到的常见问题。团队的稳定性重要性要远大于一些其他的因素的重要性。</p>
<hr>
<h2 id="技术选型误区与雷区"><a href="#技术选型误区与雷区" class="headerlink" title="技术选型误区与雷区"></a>技术选型误区与雷区</h2><p><img data-src="https://img-blog.csdnimg.cn/2020061620004568.png#x200" alt=""><br>做任何决策时，搜集资料，无论是在简书，掘金，公众号还是csdn这些平台上，亦或是开源项目地址和官网上，请记住：最重要的不是它告诉了你什么，而是它对你隐瞒了什么，这些隐瞒的信息最终会置你于险境。</p>
<p>搜集资料的时候如果资料的作者对某项技术具有显著的倾向性时，请深入想想，他向你推荐的每一项优点是否真的“对你”有价值，以及它背后的代价是什么。比如，推崇“自由”的技术往往不够“严谨”，如果你的产品需要严谨，那么请把“自由”看做减分项而不是加分项。比如，推崇“体积小”的技术在现在动辄几T硬盘、几M带宽的环境下，到底对你来说有多大价值？它是不是因为没有其它的优点了才把这种细枝末节亮出来吸引你？</p>
<p>如何避免减少技术选型踩坑或者踏雷呢，在这里我们需要一些原则和意识进行精确的指导。</p>
<hr>
<h2 id="技术选型原则"><a href="#技术选型原则" class="headerlink" title="技术选型原则"></a>技术选型原则</h2><p><img data-src="https://img-blog.csdnimg.cn/20200616200218627.png#x200" alt=""><br>我们为了团队影响力适度使用新技术，也鼓励在各方面情况需要的时候造点轮子，但是前提是稳定第一，并且还要善于应用新技术和自己造成熟了的轮子。</p>
<hr>
<h2 id="技术选型的意识"><a href="#技术选型的意识" class="headerlink" title="技术选型的意识"></a>技术选型的意识</h2><p><img data-src="https://img-blog.csdnimg.cn/20200616200246635.png#x200" alt=""></p>
<h3 id="生命周期的意识"><a href="#生命周期的意识" class="headerlink" title="生命周期的意识"></a>生命周期的意识</h3><p>《聊聊架构》这本书，贯穿全书的词恐怕就是生命周期了。系统都有他系统特性所带的生命周期，从生到死，经历少年、中年、老年三个阶段。复杂度的管理贯穿系统的整个生命周期,就像进化论的自然选择一样，不停的优化着系统，不停的断舍离，保持着系统的生命力。</p>
<h3 id="度量意识"><a href="#度量意识" class="headerlink" title="度量意识"></a>度量意识</h3><p>《人月神话》是把软件工程的过程量化的国内最早的一本书。没有度量无法说服自己，更别谈说服团队。</p>
<h3 id="突破定势思维"><a href="#突破定势思维" class="headerlink" title="突破定势思维"></a>突破定势思维</h3><p>突破自己的技术思维定势的意识个体技术认知是有局限的，如何来打破这种局限? 学习，分享，交流，提升，这也是技术创新的基础。</p>
<h3 id="权衡取舍意识"><a href="#权衡取舍意识" class="headerlink" title="权衡取舍意识"></a>权衡取舍意识</h3><p>选型也是一种精细化选择，权衡取舍意识我们技术和工程领域的朋友很多都是完美主义者,追求完美，但是我么要明白没有银弹。</p>
<p>技术选型的取舍也是一种取舍的艺术。不仅仅是限于技术视野的综合判断力的体现。</p>
<p>有时候不必纠结于技术本身的挑战踩坑的认可自己的观念，而是在遇到技术难题，长时间无法解决的时候，可以选择绕口，曲线超车。不把过多经历放在细微之处，而把精力聚焦到核心问题上。</p>
<h3 id="职责划分意识"><a href="#职责划分意识" class="headerlink" title="职责划分意识"></a>职责划分意识</h3><p>做好选型也需要格局，不仅仅是深深认识到业务规模是发展变化的，技术是演进迭代的，还有企业的商业战略(技术人也要培养商业敏感度)。还有技术选型谁主导，谁参与，谁监督。</p>
<p>运维需要参与吗，测试需要参与吗，安全部门需要参与吗，当然谁需要参与取决于选型的对象的规模和选型的目的。</p>
<h3 id="风险意识"><a href="#风险意识" class="headerlink" title="风险意识"></a>风险意识</h3><p>需要识别好风险，在清楚风险的基础上，考虑推进过程中的影响面以及推进过程需要把握的度。特别强调关于已知的未知 和 未知的未知进行区分，一个人花了四个月时间试图弄清楚为什么会出现 GC 停顿，结果发现是因为他往文件中写入了统计信息。显然，他事先并不知道会发生这样的事情。软件中的很多 bug 都是这样的。我们并不知道系统里存在这些 bug，它们都是”未知的未知”。</p>
<p>一个项目最好超过30%得新技术，对于完全未知的新技术，很难控制使用过程中出现的风险。如果技术leader不能得到下属的尊重，很可能受到惩罚。</p>
<h3 id="产品意识"><a href="#产品意识" class="headerlink" title="产品意识"></a>产品意识</h3><p>作为使用者是否有能力解决问题，给你一本亿级流量，但是需求是只需要做个管理系统给国企下面一个部门的办公室几个行政人员使用，而且可能一个月也就使用几次。这其实反应了技术人员的产品意识。</p>
<p>很多技术人员喜欢玩酷的东西，愿意探索新的领域，把不可能的变成可能，但是很多时候，他们做出来的东西很难使用。</p>
<h3 id="技术发展的史学观意识"><a href="#技术发展的史学观意识" class="headerlink" title="技术发展的史学观意识"></a>技术发展的史学观意识</h3><p>中国近现代是一部师夷长技以制夷的历史，而当年的中国逐步从这种现状转变成自主创新的国家，虽然完全自主创新的科技少之又少，但是这种变化标志着中国对科技的认知和科技长远发展树立了一个里程碑,而这一点在计算机应用领域更是淋漓尽致，造福每一个当代人。我深信多读历史才能增长智慧。</p>
<p>只有了解技术的发展历史，才能更好，更精准，更稳的做好技术选型。喜欢深入研究技术的从业人员多半会喜欢读一些技术发展史，如《数学之美》这本书就是历史的看从信息论到计算机的发展史。这本书是本不错的计算机从业人员的计算机启蒙书籍。</p>
<hr>
<h2 id="技术选型考量因素"><a href="#技术选型考量因素" class="headerlink" title="技术选型考量因素"></a>技术选型考量因素</h2><p><img data-src="https://img-blog.csdnimg.cn/20200616200506546.png#x200" alt=""></p>
<h3 id="成本考量"><a href="#成本考量" class="headerlink" title="成本考量"></a>成本考量</h3><p>在开发层面，造轮子和开源是我们技术从业同学绕不开的两个问题。很多技术领导害怕<strong>重造轮子</strong>, 大多数技术领导层希望尽量避免造轮子。我们都知道重造轮子会耗费人力和时间成本。前段<strong>技术琐话</strong>右导组织过一场造轮子的讨论，有几个同学的观点挺有意思。一个同学提出，造轮子的几个正面论调：自我展示和他人超越；自我保护和代码安全；自我超越和代码专利。</p>
<p>还有个同学说到开源不易，做得不好没人用，做得太好又投入不起。所谓的造轮子是小事，重要的是解决开源能更好的提供服务，商业更好的服务开源，只有达成良性循环才能有更好的开源，有更全面的服务，商业与开源相辅相成。还有个同学聊的很多，大体提到三点，认知问题和商业利益以及自我能力提升，认为自己的需求独一无二，现有的库就是在某个点上满足不了，对现有的轮子理解不知比如老轮子没有规格说明书，或者接口太复杂，不知道怎么用，搞明白太难，不相信老轮子。</p>
<p>譬如老轮子可能有后门、漏洞（想想OpenSSL的心脏出血漏洞）、后期万一要修改没把握等，反正是觉得自己造轮子心里更踏实，需要对老轮子上添加新功能，然而老轮子代码难读无人可问，不知道何时能弄明白，看不到结果，容易放弃，眼界有限，不知道已有这样的轮子，版权原因无法使用第三方库，比如Google Android实现JVM（Google曾因为一行代码而和Oracle打官司），比如阿里YunOS自己实现JVM不想让自己产品的关键技术掌握在别人手里，也不想让自己的核心用户数据流经别人的系统，别人的轮子不开放，我就是要赶紧造（山寨）一个出来以便获得话语权或商业利益，就想锻炼自己，因为造轮子对自己的设计、编码能力有很大好处，对理解业务也有很大好处。</p>
<p>当你造轮子的时候，你要考虑到总有一天还可能会换轮子，互联网行业换轮子是一种高风险操作，有时候我们也偶尔要说服自己，自己造轮子反倒是可能挖坑了。因为确实遇到了一些技术小伙伴参数调优没研究透，遇到问题就认为组件或者框架不好，想自己造轮子的。之所以提到造轮子和开源的问题，是因为做技术选型很多时候我们都会遇到这两个问题。无论是造轮子还是开源项目，代码的可读性和可维护性也是很重要的考量因素。<br><img data-src="https://img-blog.csdnimg.cn/20200616200558269.png#x200" alt=""><br>开发效率还是执行效率，这个选择是个老生常谈的问题。对于不同阶段的公司和项目会有不同的选择。新的商业项目更趋向于选择开发效率优先。因为商业模式的尽早验证比其他因素更重要。老项目优化更多提到执行效率，性能调优等问题。</p>
<h3 id="团队考量"><a href="#团队考量" class="headerlink" title="团队考量"></a>团队考量</h3><p>选大家熟悉的，方便开发，排查问题。</p>
<p>康威定律深刻地影响着很多方面，技术选型也不例外。特别是做宏观技术选型时，必须考虑它在最终技术架构中的位置，以及与团队沟通结构的匹配程度。即使是一项很先进的技术，假如它与体系中的其它技术栈不匹配，也可能导致翻车。</p>
<p>当选择多个第三方库的时候更要加倍小心，因为它们开发时互相不知道彼此的存在，特别是对于一些较新的技术，可能都没人把它们搭配使用过。除了开发架构之外，还要考虑更广泛的运维架构。</p>
<p>除非你是个前后端 + DevOps 全栈，否则就需要尽早对组织架构方面的因素进行验证并排除风险。也就是说，在一个可控的演习环境中，用一个小型案例，完整地走一遍开发、上线、发新版的流程。在这个过程中，一些显著的风险将会暴露出来，要评估其影响，来决定如何选型。</p>
<p>我认为技术管理者身上必须有一个特质:技术布道。充分激发团队的技术热情，感染团队里的每个成员，是技术管理者必备的人格魅力。一项技术适不适合团队，只有用了才知道。但是技术管理者大可不必亲力亲为，尤其是CTO，总监级别的管理者，只需要指定技术目标，保持一定的技术热情即可，最后再积极配合进行技术布道。</p>
<p>不同的企业，不同的部门，不同的团队管理模式不同，技术文化不同，当然就很可能在技术选型上发生不一样的故事，像一个技术同学的团队teamleader+业务架构师+技术架构，进行民主决策，少数服从多数。这个方式体现了组织架构的重要性，技术架构师和业务架构师以及teamleader。有的企业有技术架构委员会，会参与大项目的技术选型的评审，有些时候可能他们对待选型的对象所选择的技术并不太熟悉的时候，他们最差也能站在自己技术经验的角度考量一些可能会遇到的问题。提到这个主要强调组织架构对技术选型的影响力，《架构即未来》这本书，对弹性，高效的组织架构做了很详细的阐述。</p>
<p>方案1/2/3…N,综合评价，倾向选型优缺点详细列明，如果某个环节可能会出现问题，风险备案是什么。并且附上开发计划排期，关键事件的里程碑和时间截点。相信上面也是能看得懂的，这个时候就看要你个人游说能力了。那这样好不好，有一句话说的好，人捋顺了，事就好办了。但是也有另一面，因人而废制度，就变成了人治，谁的嗓音高，谁的权限大，谁就有话语权，这样的组织长久不了，团队会潜移默化的形成个因人而成事，因人而废法这样的团队你呆个两三年出来之后基本就知会唯唯诺诺，很难养成自己的独立思考和决策能力。</p>
<p>那究竟事制度重要还是人重要呢，这是另一个层面的讨论。这个话题的思考从《大江大河》里面老水的因人成事，因人废事那句话开始。因为我认为错的人好的制度，未必能办成好事，但是犯错误的可能性会低一些。对的人好的制度是比较完美的状态。<br><img data-src="https://img-blog.csdnimg.cn/2020061620071465.png#x200" alt=""><br>先客观的从团队各维度梳理团队现状，然后据此选型，要知道选型错误只能团队来承受。阿波罗神庙上镌刻着一句警世名言-了解你自己。千万不要懒于梳理，懒于总结盲从潮流。惰性确实是技术发展的驱动力之一, 而过于懒惰却不是。</p>
<p>团队技术选型自然会选择团队所有成员熟悉的技术，否则会出现开发节奏问题。比如所有人熟悉 Java，小部分人熟悉 Scala 的情况下，需要忍痛割爱选择即使从其他层面考虑更适合的 Scala 语言。一般情况下，某项技术至少需要 1 – 2 位高级工程师解答遇到的所有相关问题，这位工程师需要从源码级别理解这项技术。优先选择成熟技术。</p>
<p>技术选型一定要考虑当前团队人员的技术组成。对于一些比较基础的技术的选型，比如语言和框架、数据库等等，往往最合适的选择就是团队最熟悉的技术。如果打算选择不同的技术的话，那就要考虑下团队是否有人能够 Hold 住了。另一个必须要考虑的是招聘，如果使用的是比较小众的技术，那么当需要扩充团队的时候，招聘人员会比较困难。</p>
<p>还有一点就是，虽然技术选型需要考虑团队人员的喜好，但千万不要因为某几个人的个人喜好，来决定技术的选型。还是通过细致的分析和实验来进行选型。而决策者也需要看的更长远一些，推动团队技术向前发展。</p>
<p>我们经常会遇到，一项新技术在公司内久久难以推行,因为业务主管的阻挠。即使排除利益纠葛，仍然会发现一种发自内心的不信任存在。而这种不信任，又往往来源于对同事工作的不认可。</p>
<p>对于技术管理者，在技术选型时，重点还需注意团队人员流动性。人员流动带来的损失比大多数人所认为的要大得多。人员流动会带走知识和文化。企业要避免损失，就要把这些知识和文化尽可能记录在代码中。</p>
<p>当然，这并不意味着应该要求大量写注释，而应该使用那些能留存知识的技术，比如类型系统和规范化命名。类型系统和规范化命名可以半强制性地要求开发人员把原本只存在于自己脑子里的知识记录到代码中。如果更有追求一点，可以再尝试普及单元测试。这样，当他离开的时候，即使没有文档，这些知识也仍然能留存下来。从效果上说，代码往往比文档和注释更好。而文化的留存则更加困难，事实上，代码中的奇葩注释往往留存的是负面文化。应该在代码中留存的文化，是严谨、专业的工作态度。虽然自由也是文化的一部分，甚至在管理领域是非常值得向往的文化，但在工程领域，它往往是一种负面文化，因为软件开发领域并没有公认的法律甚至道德。你可以想象一下管理领域中没有约束的自由会导致怎样的后果。</p>
<p>所以，要想应对人员流动的风险，除非你有信心留存知识与文化，否则就应该在技术选型时，倾向于选择更加严谨的、隐式信息更少的技术。</p>
<h3 id="项目产品考量"><a href="#项目产品考量" class="headerlink" title="项目产品考量"></a>项目产品考量</h3><p>短生命周期的产品通常要求快速起步：门槛低、书写自由、不强制遵循任何最佳实践。当它的使命结束时，代码会被直接抛弃。所以，对于这类产品，“快糙猛”的技术是较好的选择，当然，能做到“快精猛”更佳。</p>
<p>而长生命周期的产品则会强烈要求可维护性，因为它们在很长时间内都是不可报废的。甚至对于一些生命线产品，连重写都会要求在重写期间线上系统平稳过渡，一点点迁移到新技术。</p>
<p>这种要求对团队的工程化能力是个极端的考验。如果没有相应的工程能力，其代价甚至会高于用新技术重新写一个功能相同的系统。</p>
<p>稳定第一的项目比如银行项目，虽然不少银行也研究新技术，但是较少用在生产，因为银行受到评级和监管约束，一旦将新技术引入线上，会导致评级下降，监管问询等。</p>
<p>探索型产品往往也是短周期产品，但是同时也有自己的特点。它要求快速，但往往同时会要求高质量。探索型的产品如果证明了可行性，那么过渡到长生命周期的可能性很大。</p>
<p>这就要求它最好是一个微内核系统，提前留出一些扩展的空间。当然，设计微内核系统对架构师的能力具有相当的考验，如果没有一个优秀的架构师，建议还是不要刻意做任何预留，优先保障系统的简单性。</p>
<p>除此之外，探索型产品的技术栈必须支持可靠的、自动化的重构。因为探索型产品的迭代速度很快，如果完全靠人工去添加功能并手动重构，那么一旦出现 BUG，将给此产品的用户体验带来严重的负面影响。</p>
<p>所以，除非由于人才储备等原因而被迫做出折中，否则探索型产品的技术栈一定要快速而严谨。而对守成型产品的选型则会侧重于与现有技术栈的相似程度和无缝整合能力。如果整合时需要借助很多技巧，那么可能你就是在给自己挖坑。</p>
<p>在引入新技术的过程中，要尽可能符合现有的开发流程、基础设施和开发习惯。当然，如果现有的这些已经严重过时，那么应该找新老技术的专家，共同帮你设计一个路线图，让你可以平稳地引入新技术，这份投资绝对值得。如果老技术已经有新版本，则应该优先考虑升级它。不要幻想换个技术栈就能解决一切问题，事实上，它带来的问题往往会更多。</p>
<h3 id="业务考量"><a href="#业务考量" class="headerlink" title="业务考量"></a>业务考量</h3><p><strong>所有脱离业务需求的技术方案，都是耍流氓。</strong><br>只有真正契合业务上下文的方案才是好的方案，而每个项目都有自己的特殊性，需要把项目上下文尽可能了解清楚，找出项目成败最核心的1到2个标准，以此作为基础来做选择题。譬如说，创业项目，灵活是明显的述求，产品推出后必然会面对朝令夕改的需求，如何快速反应是选型的重点。再譬如说，陈年项目性能遇到瓶颈需要重构，再往下挖可能原有系统吞吐量不成问题，但瞬时响应太差，选型时就需要特别注意这个点。</p>
<hr>
<h2 id="如何做好技术选型"><a href="#如何做好技术选型" class="headerlink" title="如何做好技术选型"></a>如何做好技术选型</h2><p><img data-src="https://img-blog.csdnimg.cn/2020061620092176.png#x200" alt=""><br>如果我们从天时，地利，人和这几方面去梳理当前业务的情况，会发现很多我们原本没有注意的问题。我们必须从业务角度去梳理企业业务规划，业务战略以及当前业务遇到的痛点和难点，组织架构。团队成员的技术特征以及技术栈偏好。还有当前使用的技术情况等。</p>
<p>梳理当前能解决我们需求的开源项目或者工具，并分析一些核心指标能满足我们大部分的需求进行筛选并列出表格。从中我们梳理一些选型中会考量的核心指标，并把核心指标对应的权重做出表格，让相关人给对应的指标分配合适的权重，综合相关人的权重算出合适的权重。做出指标和权重的表格，让参与选型的相关人进行指标值打分。对打分结果进行计算，对不同的待选项的得分高低进行筛选。切记筛选核心指标要细致准确。</p>
<p>技术选型最好罗列至少3个以上的待选，并在选好型之后，还附加一个备选技术方案来兜底。我们应该了解选型对象的不同，有时候核心考量指标可能差距偏大。以大数据平台为例：<br><img data-src="https://img-blog.csdnimg.cn/20200616200956669.png#x200" alt=""><br>这些指标是我和技术分享@华山论剑@湖北群组中的大数据平台架构师wander聊过后梳理的。因为在从业早期，对不同的选型对象，所偏向的指标在某几个点上是有很大差距的，大数据平台，中间件，云平台等等。</p>
<p>有一个点可能是共通的，就是无论是什么技术产品或者项目，我们都需要有个人能体系化的熟悉选型对象涉及的技术并了解相关生态，基于这点我们排除团队，成本等因素更可能做一个靠谱执行顺利的技术选型。</p>
<hr>
<h2 id="常见选型案例"><a href="#常见选型案例" class="headerlink" title="常见选型案例"></a>常见选型案例</h2><p>开发语言，开发工具，项目管理工具，知识库，中间件，框架，存储，监控运维平台的选型是我们经常会遇到的。</p>
<p>通常我们选型会考虑一些通用的选型指标，具体的选型可以在通用选型的基础上具体化对应的指标，亦可根据选型的特殊性在通用选型的基础上筛选核心指标。<br><img data-src="https://img-blog.csdnimg.cn/20200616201034747.png#x200" alt=""><br>以API网关为例，在某公有云公司的时候，当时开发一个人，运维属于跨部门沟通没有垂直SRE，由于当时公有云在发展初期的样子，规划是整个公有云的开放平台和网关，IAAS和PAAS部门几十条产品线陆续在开发结束等着接入API网关把能力开放给大客户。IAAS部门高级中间和产品高级技术总监对项目赶的很紧，但是人力投入不够，为什么人力投入不够，这个涉及到领导各方面意识的错位，这点错位一直到半年之后的一次公司重大组织架构调整之后才有所改观，对于网关和开放平台的主要研发来说，一个人从各部门沟通，方案，设计，维护，测试各个层面来讲，承受的压力都不小。2017年的时候可选的开源网关不如如今这么多，当时比较多的zuul1被技术圈的朋友在设计上和性能上诟病，sc gateway。从技术栈上看，lua栈的有kong和orange，基于OR自研。go栈的悟空，tyk，自研。java栈的zuul1，sc gateway刚开始版本v1在进行中(下半年才开始推广中小企业应用)，zuul2一直未发。</p>
<p>面对当时的情况，有几个想法：1 找一个功能强大，口碑较好，方便易用的(如kong)快速验证上线，后期做二次开发。2 基于内部的RPC框架做开发，但是当时公有云部分正在去集团的RPC框架，纠结了一会。3 基于go语言改造一套，但是问题是我们部门多是java栈的，我对lua的比go熟一些，公有云很多是go栈的，又是一个纠结。真是天时，地利，人和三点都不沾。当时的处境如同，老板给你递了两个烂核桃，你还不得不吃。</p>
<p>还是得一步一步来，而且要快速去验证，于是快速对kong的社区和源码进行查阅，并快速部署，去验证。任何新东西的引入都会踩坑，我验证的过程中发现对于kong集群的通信，节点数据一致性，konga管理后台的配置和使用，kong的部署安装，数据库的支持，运维部署的复杂度等等都或多或少要不就是坑，要不就是不符合国内使用习惯和架构设计风格，但是唯一就是插件很丰富，功能很多。其实如果时间充裕一点，不是一个人做，我宁可选择java自研或者go自研。或者说当时kong不成熟吧，与kong的国外研发团队沟通的过程中却是也觉得，他们技术的深度可以，然后再不断的踩坑中进行着kong的二开之路。我相信这次选型不是一次充分的选型，当下可选的API网关很多，开源的也太多，soul，APISIX进入Apache基金会，sc gateway的成熟等等新成员陆续出现。</p>
<p>API网关除了上面通用的选型要素还应该注意什么呢。大多数人会说协议支持，路由粒度及策略，负载策略，安全扩展，高性能这样几块，这些属于技术要素里面我们需要考虑的细项。</p>
<p>我们根据通用选型指标给出对应的专家打分权重，筛选了几个备选的API网关：APISIX，soul，kong，tyk等。注意三个以下备选行不算有选择。</p>
<p>接下来基于通用指标考量之后，我们进行细化指标考量。<br><img data-src="https://img-blog.csdnimg.cn/20200616201126135.png#x200" alt=""><br>带着以上指标去快速调研和验证，并填充上面表格，根据当前的选型背景选择合适的。至于具体如何量化的对网关进行选型，因为考虑到不同的团队面对的情况不一样，将在下一篇 API网关的设计中去聊API网关的量化要素。</p>
<p>题外话，最近和一些技术圈的兄弟准备发起《技术价值分享会(湖北) 暨老乡会》的聚会，希望技术朋友们，特别是老家在湖北的技术从业朋友，不管你在北京还是深圳，广州，或者在杭州，苏州，成都，武汉，我们都很欢迎和期待您的加入。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>凌云</code>：技术价值分享会(湖北) 暨老乡会发起人。湖北武汉人，计算机硕士研究生，在校期间主要研究方向是人工智能算法的优化算法和软件质量度量模型。相关论文《脉冲神经网络图像分割的编码方法》发表于计算机工程期刊，《改进粒子群的软件质量综合评价方法研究》，《粒子群算法改进策略研究》也被一些论文和期刊引用。岗位从研发到架构到架构管理，涉及行业包括在线教育，数字社区，智慧交通，公有云，电商，重资产长租等领域。同时也参与中间件开发及负责开放平台，服务框架，安全威胁建模等领域。在新华网负责过教育平台技术架构，后被朋友推荐去京东，在京东云和京东商城主要致力于API网关，流量网关和开放平台方面的研发和架构，目前是重资产长租领域独角兽企业技术架构委员会委员，softech华山论剑作者。致力于最有价值的技术传播分享，推动轻松高效的技术氛围建设，希望能顺利推动湖北地区技术氛围建设与技术坏境的良性转变。同时也希望组建我们的技术从业者足球队和篮球队，提升技术从业人员”健康第一”的意识。</p>
<p>特别值得介绍的是我们的发起人团队都是<strong>87到95的一群年轻阳光的小伙子</strong>。如果您自驱动的学习，乐于分享，热爱开源，并执着于技术，如果你是一个利他、阳光、正气、勇敢、执着、创新的技术从业者或者在校学子，欢迎扫码加入。如果你是湖北地区或者漂在一线城市的湖北技术从业人员或学子，我们也欢迎你加入，我们在这等你。</p>
<p>进群之前先弄清楚下图几个问题，弄清楚再看切合度加入。<br><img data-src="https://img-blog.csdnimg.cn/20200616201224376.png#x200" alt=""><br><img data-src="https://img-blog.csdnimg.cn/20200616201241376.png#x200" alt=""></p>]]></content>
      <categories>
        <category>技术管理</category>
      </categories>
      <tags>
        <tag>技术选型</tag>
        <tag>网关</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA命令行缩短器助你解决此问题：Command line is too long. Shorten command line</title>
    <url>/x2y/b934cc4f.html</url>
    <content><![CDATA[<blockquote>
<p>当大潮退去，才知道谁在裸泳。<br><strong>作者</strong>：A哥（YourBatman）<br><strong>公众号</strong>：BAT的乌托邦（ID：BAT-utopia）<br><strong>文末是否有彩蛋</strong>：有</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>各位小伙伴大家好，我是A哥。最近遇到两个问题，都是关于IDEA的（言外之意和代码无关），很是让我“生气”呀（关键是浪费时间）。在痛定思痛后，我决定写此专栏，来专门分享/记录使用<code>IntelliJ IDEA</code>过程中遇到的那些奇葩问题和解决方案，以帮助你缩短日常排错时间，这么一思考好像还功德无量呢😄。</p>
<p><code>IntelliJ IDEA</code>作为Java开发者中最为流行的开发工具（eclipse粉勿喷），熟练掌握它（包括排雷）对提升编码效率能有显著提升。但工具毕竟是工具，这么长时间使用IDEA以来，每个人或多或少的都遇到过关于IDEA七七八八、奇奇怪怪的问题，这些与代码舞棍，但它很容易<strong>偷走</strong>你的时间，半天又更或者是一天之久。</p>
<blockquote>
<p>说明：千万不要忽视对IDEA的研究，因为把它玩熟练了它就相当于你的物理外挂</p>
</blockquote>
<p>本专栏内容<strong>并非</strong> IDEA教程，而是着眼于分享IDEA使用过程中，那些我遇到（或者大家遇到）的但又不是能够很快速解决，总之就是比较棘手的问题的汇总，有一种错题本的意思有木有。总之就是希望它能够帮助到大家迅速定位or解决问题，避免不必要的时间浪费，毕竟咱们的主业还是敲代码嘛~<br><img data-src="https://img-blog.csdnimg.cn/20200607164702294.png#x200" alt=""></p>
<hr>
<h2 id="版本约定"><a href="#版本约定" class="headerlink" title="版本约定"></a>版本约定</h2><p>本文内容若没做特殊说明，均基于以下版本：</p>
<ul>
<li>IntelliJ IDEA：<code>2020.1.2</code>旗舰版</li>
</ul>
<hr>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>使用IDEA这么久，虽然之前时不时地的跟IDEA问题“交过手”，但真正促使我决定写此专栏的原因还是源自于前两天使用IDEA启动Spring Boot程序时的这个报错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Error running <span class="string">'Application'</span>: Command line is too <span class="keyword">long</span>. Shorten command line <span class="keyword">for</span> Application or also <span class="keyword">for</span> Spring Boot <span class="keyword">default</span> configuration.</span><br></pre></td></tr></table></figure>
<p><img data-src="https://img-blog.csdnimg.cn/20200607141445942.png#x80" alt=""><br>说实话这个错误我前所未见，看起来还蛮有意思，因此决定研究一番。这不，把研究结果分享给大家，信息共享。</p>
<p>为了解释好这个问题，我们得先来做些功课，知晓写概念。</p>
<hr>
<h2 id="控制台首行路径"><a href="#控制台首行路径" class="headerlink" title="控制台首行路径"></a>控制台首行路径</h2><p>在IDEA里，你每次启动一个main函数时，控制台第一行输出的“日志”称作为：<strong>控制台首行路径</strong>。这里，我运行一个最最最简单的程序，看看它长啥样，程序如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，控制台输出如下截图：<br><img data-src="https://img-blog.csdnimg.cn/202006071446358.png#x100" alt=""><br>相信小伙伴每天都能看见它但大概率不会注意到它，我也不例外。你想不到的是，恰巧这行“日志”就成为了本文今天的<strong>主角</strong>，会围绕它来展阐述。</p>
<blockquote>
<p>特别说明：如果你是用外置tomcat驱动应用启动的话效果不是这样子的。因为它使用的是tomcat的脚本来启动，所以首行日志形如这样：<code>D:\developer\apache-tomcat-9.0.34\bin\catalina.bat run</code></p>
</blockquote>
<hr>
<h3 id="首行路径内容"><a href="#首行路径内容" class="headerlink" title="首行路径内容"></a>首行路径内容</h3><p>知道了什么叫首行路径，那么它的内容才是我们要关心的。如上截图中，细心的你会发现最后是<code>...</code>省略号，因此内容绝不止你现在看到的那么简单。你可以鼠标点击一下，展开全部内容，截图如下：<br><img data-src="https://img-blog.csdnimg.cn/20200607145503910.png#x15" alt=""><br>这<strong>一行</strong>实在太长了，无法横向截图全部展示出来，因此我把它复制出来放在文本编辑器中查看：<br><img data-src="https://img-blog.csdnimg.cn/2020060715041445.png#x200" alt=""><br>这个截图是<strong>一行</strong>哦（只是我在文本编辑器了自动折行了而已），仍旧不能看到全部内容，因为字数真的太多了，总字数统计如下：<br><img data-src="https://img-blog.csdnimg.cn/20200607150518466.png#x80" alt=""><br>仅仅一行，字数超过26000个。咋舌吧：第一行控制台“日志”竟然输出了超过2.6w个字符。从内容结构上来看，这是一个command命令：<strong>调用java.exe程序启动一个java进程的命令</strong>。</p>
<hr>
<h2 id="为何启动抛错Command-line-is-too-long"><a href="#为何启动抛错Command-line-is-too-long" class="headerlink" title="为何启动抛错Command line is too long"></a>为何启动抛错Command line is too long</h2><p>99.99%的情况下，你可以在IDEA里正常启动你的应用，即使首行路径很长很长。但是直到当我启动我的这个Spring Boot应用时，弹出红色提示：<br><img data-src="https://img-blog.csdnimg.cn/20200607141445942.png#x80" alt=""><br>直接禁止了我的running运行。提示内容中文释义为：运行“Application”时出错：<strong>命令行太长</strong>。缩短应用程序或Spring Boot默认配置的命令行。我相信如果你也是第一次见到此case，表情和我一样是这样的：<br><img data-src="https://img-blog.csdnimg.cn/20200607151511391.png#x160" alt=""><br>main方法都启不动了，那还得了。遇到这种情况，我只能使用百度大法（谷歌大法）了：<br><img data-src="https://img-blog.csdnimg.cn/20200607151831469.png#x200" alt=""><br>一看能搜出这么多结果，我也就不慌了，按照“教程”很容易的把问题解决了。另外呢，通过此次搜索到的结果聊两句题外话：</p>
<ol>
<li>虽然Result Count不少，但是我发现实质上内容几乎一毛一样，真乃天下文章一大抄</li>
<li>访问量并不代表文章质量高，只是它刚好命中了关键字而已，比如标题党</li>
</ol>
<p>我得出如此感悟，也是促使我写本文的原因之一。<strong>因为A哥的文章一贯如此，是有些B格的</strong>。接下来以点带面，把这部分内容帮大家展开展开，解决问题并非最终目的，而是为了：记得牢，能装x，一切为了加薪。</p>
<hr>
<h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>出现此问题的直接原因是：IDEA集成开发环境运行你的“源码”的时候（注意是源码基础上运行，并非打好的jar包哦），是通过命令（首行那个非常非常长的）来启动Java进程的。这个命令主要包含两大部分：</p>
<ol>
<li><code>vm/程序</code>参数。也就是你看到的那些-XX -D等参数，这部分理论上可以无限长但实际上一般不会太长</li>
<li><code>-classpath</code>参数，它用于指定运行时jar包路径（因为jar包理论上是可以在任何地方的），这部分可能性就多了</li>
</ol>
<p>关键就在于<code>-classpath</code>参数，<strong>它可以非常长</strong>，你依赖的jar包越多此路径就越长；你的base基路径越长它就越长；倘若你还要做复杂的Junit单元测试，那加入的jar包就更多长度可能就越长喽。总的来说：此part是<strong>很有可能</strong>超长从而导致<code>Command line is too long</code>现象的。</p>
<p>如果类路径太长（可能性大），或者您有许多VM参数（可能性小），则无法启动该程序。原因是<strong>大多数操作系统</strong>都有命令行长度限制。在这种情况下，IntelliJ IDEA将提供尝试缩短类路径的能力。</p>
<hr>
<h3 id="IDEA老版本方案"><a href="#IDEA老版本方案" class="headerlink" title="IDEA老版本方案"></a>IDEA老版本方案</h3><p>针对此问题，在之前版本（确切的说是2017.3之前的版本），需要通过XML文件配置来解决：找到工程下的<code>.idea/workspace.xml</code>这个文件，添加如下项：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">name</span>=<span class="string">"PropertiesComponent"</span>&gt;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">&lt;!-- 这句是你需要添加的项 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dynamic.classpath"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">	...</span><br><span class="line"><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>再次启动程序发现问题解决。我有理由相信，在这个时间节点上应该没有人用这么古老的版本了吧，但你在网上搜的文章大多数都还是这种解决方案，因此请务必注意甄别哦（2017.3以后的版本请参照下面方案解决）。</p>
<blockquote>
<p>所以我不是说了麽，任何不指定版本的解决方案、源码分析文章都是不太负责任的。作为一个程序员，应该适当提高自己的版本意识</p>
</blockquote>
<hr>
<h3 id="IDEA新版本方案：命令行缩短器"><a href="#IDEA新版本方案：命令行缩短器" class="headerlink" title="IDEA新版本方案：命令行缩短器"></a>IDEA新版本方案：命令行缩短器</h3><p>在IDEA的<code>2017.3</code>版本中提供了一项新特性：命令行缩短器。旨在用来解决此类问题，也就是说<strong>从此版本开始</strong>，不再需要通过XML文件来编辑IDE的设置那么麻烦了，而是直接在界面操作即可：<br><img data-src="https://img-blog.csdnimg.cn/20200607154204781.png#x200" alt=""><br>最初，IntelliJ IDEA尝试将长类路径写入<strong>文本文件</strong>（这意味着应用程序是中间类加载器）。但是不幸的是，这不适用于某些框架，例如JMock。然后，IntelliJ IDEA尝试使用或多或少的标准方法，即将长类路径打包到<strong>classpath.jar</strong>中。不幸的是，对于其他一些框架，这也不起作用。</p>
<blockquote>
<p>总结：这两种方案都不是100%完美的，具体情况具体分析</p>
</blockquote>
<p>从上对话框中可以看到IDEA一共提供了三种命令行缩短器供你选择：</p>
<ol>
<li>none。这是默认选项。IDE不会缩短长类路径。如果命令行超出操作系统限制，<strong>则IDEA将无法运行您的应用程序</strong></li>
<li>jar manifest。IDE通过<strong>临时classpath.jar</strong>传递长类路径。原始类路径在<code>MANIFEST.MF</code>中定义为classpath.jar中的类路径属性</li>
<li>classpath file。IDE将把长类路径写入文本文件</li>
</ol>
<hr>
<h4 id="jar-manifest方式"><a href="#jar-manifest方式" class="headerlink" title="jar manifest方式"></a>jar manifest方式</h4><p>选择此种方式，运行测试程序，首行<strong>全部内容</strong>展示如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\developer\jdks\<span class="number">1.8</span><span class="number">.0_241</span>\bin\java.exe -XX:TieredStopAtLevel=<span class="number">1</span> -noverify </span><br><span class="line">	-Dspring.output.ansi.enabled=always -Dcom.sun.management.jmxremote </span><br><span class="line">	-Dspring.jmx.enabled=<span class="keyword">true</span> -Dspring.liveBeansView.mbeanDomain </span><br><span class="line">	-Dspring.application.admin.enabled=<span class="keyword">true</span> </span><br><span class="line">	<span class="string">"-javaagent:C:\Program Files\JetBrains\IntelliJ IDEA 2020.1.1\lib\idea_rt.jar=5975:C:\Program Files\JetBrains\IntelliJ IDEA 2020.1.1\bin"</span> -Dfile.encoding=UTF-<span class="number">8</span> </span><br><span class="line">	-classpath C:\Users\xxx\AppData\Local\Temp\classpath1199511058.jar </span><br><span class="line">	com.xxx.Application</span><br></pre></td></tr></table></figure>
<p>区别主要在于<code>-classpath</code>这一行，它不再是把所有jar的路径展示出来，而是“封装”到了一个jar文件里，这一下子让<strong>命令长度</strong>大幅减少，能够100%保证不会超长了，所以启动也就不会报错喽。</p>
<p>另外，在IDEA里你直接单击此jar路径是可以预览器内容的（真贴心）：<br><img data-src="https://img-blog.csdnimg.cn/20200607160409685.png#x200" alt=""><br>当然，你也可以在你磁盘里找到此jar文件，然后查看其内容（说明：请确保<strong>hold住线程了</strong>再去找对应文件，否则临时文件是线程结束后就删除了的）：<br><img data-src="https://img-blog.csdnimg.cn/20200607160536376.png#x100" alt=""><br><strong>特别强调</strong>：我在实践过程中，使用此种方式出现过jar包没有被加载进来的情况，在此提醒各位，若你也有类似现象发生，请切换成使用classpath file方式吧。</p>
<blockquote>
<p>毕竟官方也说了：这两种路径缩短方式，对某些框架可能存在不兼容情况，just可能而已哦~</p>
</blockquote>
<hr>
<h4 id="classpath-file方式"><a href="#classpath-file方式" class="headerlink" title="classpath file方式"></a>classpath file方式</h4><p>选择此种方式，运行测试程序，首行<strong>全部内容</strong>展示如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\developer\jdks\<span class="number">1.8</span><span class="number">.0_241</span>\bin\java.exe -XX:TieredStopAtLevel=<span class="number">1</span> -noverify </span><br><span class="line">	-Dspring.output.ansi.enabled=always -Dcom.sun.management.jmxremote </span><br><span class="line">	-Dspring.jmx.enabled=<span class="keyword">true</span> -Dspring.liveBeansView.mbeanDomain </span><br><span class="line">	-Dspring.application.admin.enabled=<span class="keyword">true</span> </span><br><span class="line">	<span class="string">"-javaagent:C:\Program Files\JetBrains\IntelliJ IDEA 2020.1.1\lib\idea_rt.jar=5975:C:\Program Files\JetBrains\IntelliJ IDEA 2020.1.1\bin"</span> -Dfile.encoding=UTF-<span class="number">8</span> </span><br><span class="line">	-classpath C:\Users\xxx\AppData\Local\Temp\idea_classpath921151059</span><br><span class="line">	com.xxx.Application</span><br></pre></td></tr></table></figure>
<p>有了上面的描述，这个就不用A哥赘述了。</p>
<hr>
<hr>
<h2 id="扩展知识：windows系统命令最大长度"><a href="#扩展知识：windows系统命令最大长度" class="headerlink" title="扩展知识：windows系统命令最大长度"></a>扩展知识：windows系统命令最大长度</h2><p>这属于扩展知识，延伸阅读内容。</p>
<p>既然已经知道出现此问题的原因是命令超长了而“报错”，A哥就想那<strong>windows命令最长允许多少字符呢</strong>？带着这个问题，我开始了一番苦心寻找，最后终于在windows官网找到了我想要的答案。地址在这：<a href="https://docs.microsoft.com/zh-cn/windows/win32/api/processenv/nf-processenv-setenvironmentvariablea?redirectedfrom=MSDN" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/windows/win32/api/processenv/nf-processenv-setenvironmentvariablea?redirectedfrom=MSDN</a></p>
<p>在Windows上，命令行长度最大为<strong>32767</strong>个字符（和shell长度、命令提示符长度的区别）。当提供足够大的类路径时，将违反此限制，并且Windows拒绝执行该命令并抛出错误代码87。推荐的解决方案有如下两种：</p>
<ol>
<li>将所有jar复制到一个公共文件夹，例如<code>c:\jars</code>，然后将其包括在内。这样，每个jar都有一个<strong>短路径</strong>，即<code>c:\jars</code>（而不是长路径<code>c:\program files\app\lib\app-jar1.jar</code>），并且应该可以将这个路径们控制在38kb之内</li>
<li>如果步骤1不起作用，则可以将单个jar提取到一个文件夹中，并创建一个包含所有提取文件的<strong>新jar</strong>。这样就只需要引入这个新jar就可以了</li>
</ol>
<p>这是两种解决问题的思想：短路径方式（简单高效）和打包方式（100%能解决问题）</p>
<blockquote>
<p>别问A哥为毛只给出windows的最大长度，没有Mac的吗？我只能说，我很穷所以用的是windows本，Mac的我不关心😄</p>
</blockquote>
<hr>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>今日份思考题比较简单</p>
<ol>
<li>为毛你的<strong>Spring Boot应用</strong>在生产环境下从来不用担心出现Command line is too long这种错误？</li>
<li>有哪些<strong>有效的方式</strong>可以避免你的开发环境出现此问题？</li>
</ol>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>IDEA踩坑系列第一篇到这就结束了，算不算精彩呢？我个人觉得还可以😄。此专栏后续将不定期的更新，除了我自己准备外，同时也<strong>非常欢迎</strong>各位小伙伴能把平时遇到的IDEA遇到的棘手问题反馈给我（最好有解决方案哦），咱们一起把这个事做好，也算造福于大家嘛，毕竟我一个人碰见的case实则有限，有建议的可以下方扫码加我好友私聊我。</p>]]></content>
      <categories>
        <category>IDEA踩坑系列</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>命令行缩短器</tag>
      </tags>
  </entry>
  <entry>
    <title>想用@Autowired注入static静态成员？官方不推荐你却还偏要这么做</title>
    <url>/x2y/8d076785.html</url>
    <content><![CDATA[<blockquote>
<p>当大潮退去，才知道谁在裸泳。<br><strong>作者</strong>：A哥（YourBatman）<br><strong>公众号</strong>：BAT的乌托邦（ID：BAT-utopia）<br><strong>文末是否有彩蛋</strong>：有</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>各位小伙伴大家好，我是A哥。通过本专栏前两篇的学习，相信你对static关键字在Spring/Spring Boot里的应用有了全新的认识，能够解释工作中遇到的大多数问题/疑问了。本文继续来聊聊static关键字更为常见的一种case：使用<code>@Autowired</code>依赖注入静态成员(属性)。</p>
<p>在Java中，针对static静态成员，我们有一些最基本的常识：静态变量（成员）它是<strong>属于类</strong>的，而非属于实例对象的属性；同样的静态方法也是属于类的，普通方法（实例方法）才属于对象。而Spring容器管理的都是<strong>实例对象</strong>，包括它的<code>@Autowired</code>依赖注入的均是容器内的对象实例，所以对于static成员是不能直接使用<code>@Autowired</code>注入的。</p>
<blockquote>
<p>这很容易理解：类成员的初始化较早，并不需要依赖实例的创建，所以这个时候Spring容器可能都还没“出生”，谈何依赖注入呢？</p>
</blockquote>
<p>这个示例，你或许似曾相识：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SonHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Son son;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Son <span class="title">getSon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> son;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后“正常使用”这个组件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SonHolder sonHolder;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transaction</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	sonHolder.getSon().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，结果抛错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.NullPointerException</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>很明显，<code>getSon()</code>得到的是一个null，所以给你扔了个NPE。<br><img data-src="https://img-blog.csdnimg.cn/20200606065710511.png#x200" alt=""></p>
<hr>
<h2 id="版本约定"><a href="#版本约定" class="headerlink" title="版本约定"></a>版本约定</h2><p>本文内容若没做特殊说明，均基于以下版本：</p>
<ul>
<li>JDK：<code>1.8</code></li>
<li>Spring Framework：<code>5.2.2.RELEASE</code></li>
</ul>
<hr>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>说起<code>@Autowired</code>注解的作用，没有人不熟悉，<strong>自动装配</strong>嘛。根据此注解的定义，它似乎能使用在很多地方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, </span><br><span class="line">	ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired &#123;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本文我们重点关注它使用在FIELD成员属性上的case，标注在static静态属性上是本文讨论的中心。</p>
<blockquote>
<p>说明：虽然Spring官方现在并不推荐字段/属性注入的方式，但它的便捷性仍无可取代，因此在做<strong>业务开发</strong>时它仍旧是主流的使用方式</p>
</blockquote>
<hr>
<h2 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h2><p>假如有这样一个场景需求：创建一个教室(Room)，需要传入一批学生和一个老师，此时我需要对这些<strong>用户</strong>按照规则（如名字中含有test字样的示为测试帐号）进行数据合法性校验和过滤，然后才能正常走创建逻辑。此case还有以下特点：</p>
<ul>
<li>用户名字/详细信息，需要远程调用（如FeignClient方式）从UC中心获取<ul>
<li>因此很需要做桥接，提供防腐层</li>
</ul>
</li>
<li>该过滤规则功能性很强，工程内很多地方都有用到<ul>
<li>有点工具的意思有木有 </li>
</ul>
</li>
</ul>
<p>阅读完“题目”感觉还是蛮简单的，很normal的一个业务需求case嘛，下面我来模拟一下它的实现。</p>
<p>从UC用户中心获取用户数据（使用本地数据模拟远程访问）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟去远端用户中心，根据ids批量获取用户数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yourbatman</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/5 7:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UCClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟远程调用的结果返回（有正常的，也有测试数据）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getByIds</span><span class="params">(List&lt;Long&gt; userIds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userIds.stream().map(uId -&gt; &#123;</span><br><span class="line">            User user = <span class="keyword">new</span> User();</span><br><span class="line">            user.setId(uId);</span><br><span class="line">            user.setName(<span class="string">"YourBatman"</span>);</span><br><span class="line">            <span class="keyword">if</span> (uId % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                user.setName(user.getName() + <span class="string">"_test"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：实际情况这里可能只是一个<code>@FeignClient</code>接口而已，本例就使用它mock喽</p>
</blockquote>
<p>因为过滤测试用户的功能过于<strong>通用</strong>，并且规则也需要收口，须对它进行封装，因此有了我们的<strong>内部</strong>帮助类<code>UserHelper</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工具方法：根据用户ids，按照一定的规则过滤掉测试用户后返回结果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yourbatman</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/5 7:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UCClient ucClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getAndFilterTest</span><span class="params">(List&lt;Long&gt; userIds)</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; users = ucClient.getByIds(userIds);</span><br><span class="line">        <span class="keyword">return</span> users.stream().filter(u -&gt; &#123;</span><br><span class="line">            Long id = u.getId();</span><br><span class="line">            String name = u.getName();</span><br><span class="line">            <span class="keyword">if</span> (name.contains(<span class="string">"test"</span>)) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"id=%s name=%s是测试用户，已过滤\n"</span>, id, name);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，它内部需依赖于<code>UCClient</code>这个远程调用的结果。封装好后，我们的业务Service层任何组件就可以尽情的“享用”该工具啦，形如这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务服务：教室服务</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yourbatman</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/5 7:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoomService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserHelper userHelper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(List&lt;Long&gt; studentIds, Long teacherId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为学生和老师统称为user 所以可以放在一起校验</span></span><br><span class="line">        List&lt;Long&gt; userIds = <span class="keyword">new</span> ArrayList&lt;&gt;(studentIds);</span><br><span class="line">        userIds.add(teacherId);</span><br><span class="line">        List&lt;User&gt; users = userHelper.getAndFilterTest(userIds);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...  排除掉测试数据后，执行创建逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"教室创建成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>书写个测试程序来模拟Service业务调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(DemoTest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟接口调用/单元测试</span></span><br><span class="line">        RoomService roomService = context.getBean(RoomService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        roomService.create(Arrays.asList(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">3L</span>, <span class="number">4L</span>, <span class="number">5L</span>, <span class="number">6L</span>), <span class="number">101L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，结果输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">id=<span class="number">2</span> name=YourBatman_test是测试用户，已过滤</span><br><span class="line">id=<span class="number">4</span> name=YourBatman_test是测试用户，已过滤</span><br><span class="line">id=<span class="number">6</span> name=YourBatman_test是测试用户，已过滤</span><br><span class="line">教室创建成功</span><br></pre></td></tr></table></figure>
<p>一切都这么美好，相安无事的，那为何还会有本文指出的问题存在呢？正所谓“不作死不会死”，总有那么一些“追求极致”的选手就喜欢玩花，下面姑且让我猜猜你为何想要依赖注入static成员属性呢？<br><img data-src="https://img-blog.csdnimg.cn/20200607071214299.png#x200" alt=""></p>
<hr>
<h3 id="帮你猜猜你为何有如此需求？"><a href="#帮你猜猜你为何有如此需求？" class="headerlink" title="帮你猜猜你为何有如此需求？"></a>帮你猜猜你为何有如此需求？</h3><p>从上面示例类的命名中，我或许能猜出你的用意。<code>UserHelper</code>它被命名为一个工具类，而一般我们对工具类的理解是：</p>
<ol>
<li>方法均为static工具方法</li>
<li>使用越便捷越好<ol>
<li>很明显，static方法使用是最便捷的嘛</li>
</ol>
</li>
</ol>
<p>现状是：使用<code>UserHelper</code>去处理用户信息还得先<code>@Autowired</code>注入它的实例，实属不便。因此你想方设法的想把<code>getAndFilterTest()</code>这个方法变为静态方法，这样通过类名便可直接调用而并不再依赖于注入UserHelper实例了，so你想当然的这么“优化”：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">static</span> UCClient ucClient;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;User&gt; <span class="title">getAndFilterTest</span><span class="params">(List&lt;Long&gt; userIds)</span> </span>&#123;</span><br><span class="line">		... <span class="comment">// 处理逻辑完全同上</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>属性和方法都添加上static修饰，这样使用方通过类名便可直接访问（无需注入）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoomService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(List&lt;Long&gt; studentIds, Long teacherId)</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 通过类名直接调用其静态方法</span></span><br><span class="line">		List&lt;User&gt; users = UserHelper.getAndFilterTest(userIds);</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，结果输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">07</span>:<span class="number">22</span>:<span class="number">49.359</span> [main] INFO org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor - Autowired annotation is not supported on <span class="keyword">static</span> fields: <span class="keyword">static</span> cn.yourbatman.temp.component.UCClient cn.yourbatman.temp.component.UserHelper.ucClient</span><br><span class="line"><span class="number">07</span>:<span class="number">22</span>:<span class="number">49.359</span> [main] INFO org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor - Autowired annotation is not supported on <span class="keyword">static</span> fields: <span class="keyword">static</span> cn.yourbatman.temp.component.UCClient cn.yourbatman.temp.component.UserHelper.ucClient</span><br><span class="line">...</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.NullPointerException</span><br><span class="line">	at cn.yourbatman.temp.component.UserHelper.getAndFilterTest(UserHelper.java:<span class="number">23</span>)</span><br><span class="line">	at cn.yourbatman.temp.component.RoomService.create(RoomService.java:<span class="number">26</span>)</span><br><span class="line">	at cn.yourbatman.temp.DemoTest.main(DemoTest.java:<span class="number">19</span>)</span><br></pre></td></tr></table></figure>
<p>以为天衣无缝，可结果并不完美，抛异常了。我特意多粘贴了两句info日志，它们告诉了你为何抛出NPE异常的原因：<strong>@Autowired不支持标注在static字段/属性上</strong>。<br><img data-src="https://img-blog.csdnimg.cn/20200607072738933.png#x200" alt=""></p>
<hr>
<h2 id="为什么-Autowired不能注入static成员属性"><a href="#为什么-Autowired不能注入static成员属性" class="headerlink" title="为什么@Autowired不能注入static成员属性"></a>为什么@Autowired不能注入static成员属性</h2><p>静态变量是属于<strong>类本身</strong>的信息，当类加载器加载静态变量时，Spring的上下文环境<strong>还没有</strong>被加载，所以不可能为静态变量绑定值（这只是最表象原因，并不准确）。同时，Spring也不鼓励为静态变量注入值（言外之意：并不是不能注入），因为它认为这会增加了耦合度，对测试不友好。</p>
<p>这些都是表象，那么实际上Spring是如何“操作”的呢？我们沿着<code>AutowiredAnnotationBeanPostProcessor</code>输出的这句info日志，倒着找原因，这句日志的输出在这：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AutowiredAnnotationBeanPostProcessor：</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建@Autowired注入元数据方法</span></span><br><span class="line"><span class="comment">// 简单的说就是找到该Class类下有哪些是需要做依赖注入的</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> InjectionMetadata <span class="title">buildAutowiringMetadata</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 循环递归，因为父类的也要管上</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">// 遍历所有的字段（包括静态字段）</span></span><br><span class="line">		ReflectionUtils.doWithLocalFields(targetClass, field -&gt; &#123;</span><br><span class="line">			<span class="keyword">if</span> (Modifier.isStatic(field.getModifiers())) &#123;</span><br><span class="line">				logger.info(<span class="string">"Autowired annotation is not supported on static fields: "</span> + field);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">			...</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="comment">// 遍历所有的方法（包括静态方法）</span></span><br><span class="line">		ReflectionUtils.doWithLocalMethods(targetClass, method -&gt; &#123;</span><br><span class="line">			<span class="keyword">if</span> (Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">				logger.info(<span class="string">"Autowired annotation is not supported on static methods: "</span> + method);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">			...</span><br><span class="line">		&#125;);</span><br><span class="line">		...</span><br><span class="line">		targetClass = targetClass.getSuperclass();</span><br><span class="line">	&#125; <span class="keyword">while</span> (targetClass != <span class="keyword">null</span> &amp;&amp; targetClass != Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这几句代码道出了Spring为何不给static静态字段/静态方法执行<code>@Autowired</code>注入的<strong>最真实原因</strong>：扫描Class类需要注入的元数据的时候，直接选择忽略掉了static成员（包括属性和方法）。</p>
<p>那么这个处理的入口在哪儿呢？是否在这个阶段时Spring真的无法给static成员完成赋值而选择忽略掉它呢，我们继续最终此方法的调用处。此方法唯一调用处是<code>findAutowiringMetadata()</code>方法，而它被调用的地方有三个：</p>
<p>调用处一：执行时机较早，在<code>MergedBeanDefinitionPostProcessor</code>处理bd合并期间就会解析出需要注入的元数据，然后做check。它会作用于每个bd身上，所以上例中的2句info日志第一句就是从这输出的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AutowiredAnnotationBeanPostProcessor：</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line">	InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, <span class="keyword">null</span>);</span><br><span class="line">	metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用处二：在<code>InstantiationAwareBeanPostProcessor</code>也就是<strong>实例创建好后</strong>，给属性赋值阶段（也就是<code>populateBean()</code>阶段）执行。所以它也是会作用于每个bd的，上例中2句info日志的第二句就是从这输出的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AutowiredAnnotationBeanPostProcessor：</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">	InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		metadata.inject(bean, beanName, pvs);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用处三：这个方法比较特殊，它表示对于带有任意<strong>目标实例</strong>（已经不仅是Class，而是实例本身）直接调用的“本地”处理方法实行注入。这是Spring提供给“外部”使用/注入的一个public公共方法，比如给容器外的实例注入属性，还是比较实用的，本文下面会介绍它的使用办法</p>
<blockquote>
<p>说明：此方法Spring自己并不会主动调用，所以不会自动输出日志（这也是为何调用处有3处，但日志只有2条的原因）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AutowiredAnnotationBeanPostProcessor：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processInjection</span><span class="params">(Object bean)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">	Class&lt;?&gt; clazz = bean.getClass();</span><br><span class="line">	InjectionMetadata metadata = findAutowiringMetadata(clazz.getName(), clazz, <span class="keyword">null</span>);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		metadata.inject(bean, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这部分源码，从底层诠释了Spring为何不让你<code>@Autowired</code>注入static成员的原因。既然这样，难道就没有办法满足我的“诉求”了吗？答案是有的，接着往下看。</p>
<hr>
<h2 id="间接实现static成员注入的N种方式"><a href="#间接实现static成员注入的N种方式" class="headerlink" title="间接实现static成员注入的N种方式"></a>间接实现static成员注入的N种方式</h2><p>虽然Spring会忽略掉你直接使用<strong>@Autowired + static成员</strong>注入，但还是有很多方法来<strong>绕过</strong>这些限制，实现对静态变量注入值。下面A哥介绍2种方式，供以参考：</p>
<p>方式一：以set方法作为跳板，在里面实现对static静态成员的赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> UCClient ucClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUcClient</span><span class="params">(UCClient ucClient)</span> </span>&#123;</span><br><span class="line">        UserHelper.ucClient = ucClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方式二：使用<code>@PostConstruct</code>注解，在里面为static静态成员赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> UCClient ucClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ApplicationContext applicationContext;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserHelper.ucClient = applicationContext.getBean(UCClient<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然称作是2种方式，但其实我认为思想只是一个：<strong>延迟为static成员属性赋值</strong>。因此，基于此思想<strong>确切的说</strong>会有N种实现方案（只需要保证你在使用它之前给其赋值上即可），各位可自行思考，A哥就没必要一一举例了。</p>
<hr>
<h3 id="高级实现方式"><a href="#高级实现方式" class="headerlink" title="高级实现方式"></a>高级实现方式</h3><p>作为<strong>福利</strong>，A哥在这里提供一种更为高（zhuang）级（bi）的实现方式供以你学习和参考：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutowireStaticSmartInitializingSingleton</span> <span class="keyword">implements</span> <span class="title">SmartInitializingSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AutowireCapableBeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当所有的单例Bena初始化完成后，对static静态成员进行赋值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterSingletonsInstantiated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为是给static静态属性赋值，因此这里new一个实例做注入是可行的</span></span><br><span class="line">        beanFactory.autowireBean(<span class="keyword">new</span> UserHelper());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UserHelper类<strong>不再需要</strong>标注<code>@Component</code>注解，也就是说它不再需要被Spirng容器管理（static工具类确实不需要交给容器管理嘛，毕竟我们不需要用到它的实例），这从某种程度上也是节约开销的表现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">static</span> UCClient ucClient;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，结果输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">08</span>:<span class="number">50</span>:<span class="number">15.765</span> [main] INFO org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor - Autowired annotation is not supported on <span class="keyword">static</span> fields: <span class="keyword">static</span> cn.yourbatman.temp.component.UCClient cn.yourbatman.temp.component.UserHelper.ucClient</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.NullPointerException</span><br><span class="line">	at cn.yourbatman.temp.component.UserHelper.getAndFilterTest(UserHelper.java:<span class="number">26</span>)</span><br><span class="line">	at cn.yourbatman.temp.component.RoomService.create(RoomService.java:<span class="number">26</span>)</span><br><span class="line">	at cn.yourbatman.temp.DemoTest.main(DemoTest.java:<span class="number">19</span>)</span><br></pre></td></tr></table></figure>
<p>报错。当然喽，这是我故意的，虽然抛异常了，但是看到我们的进步了没：<strong>info日志只打印一句了</strong>（自行想想啥原因哈）。不卖关子了，正确的姿势还得这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> UCClient ucClient;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUcClient</span><span class="params">(UCClient ucClient)</span> </span>&#123;</span><br><span class="line">        UserHelper.ucClient = ucClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次运行程序，<strong>一切正常</strong>（info日志也不会输出喽）。这么处理的好处我觉得有如下三点：</p>
<ol>
<li>手动管理这种case的依赖注入，更可控。而非交给Spring容器去自动处理</li>
<li>工具类<strong>本身</strong>并不需要加入到Spring容器内，这对于有大量这种case的话，是可以节约开销的</li>
<li>略显高级，装x神器（可别小看装x，这是个中意词，你的加薪往往来来自于装x成功）</li>
</ol>
<p>当然，你也可以这么玩：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutowireStaticSmartInitializingSingleton</span> <span class="keyword">implements</span> <span class="title">SmartInitializingSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AutowiredAnnotationBeanPostProcessor autowiredAnnotationBeanPostProcessor;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterSingletonsInstantiated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        autowiredAnnotationBeanPostProcessor.processInjection(<span class="keyword">new</span> UserHelper());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依旧可以正常work。这不正是上面介绍的<strong>调用处三</strong>麽，马上就学以致用了有木有，开心吧😄。<br><img data-src="https://img-blog.csdnimg.cn/20200607085820115.png#x200" alt=""></p>
<hr>
<h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><p>有这种使用需求的小伙伴需要明晰什么才叫真正的util工具类？若你的工具类存在外部依赖，依赖于Spring容器内的<strong>实例</strong>，那么它就称不上是工具类，就请不要把它当做static来用，容易玩坏的。你现在能够这么用<strong>恰好是</strong>得益于Spring管理的实例默认都是<strong>单例</strong>，所以你赋值一次即可，倘若某天真变成多例了呢（即使可能性极小）？</p>
<p>强行这么撸，是有隐患的。同时也打破了优先级关系、生命周期关系，容易让“初学者”感到迷糊。当然若你坚持这么使用也未尝不可，那么请做好相关规范/归约，比如使用上面我推荐的高（zhuang）级（bi）使用方式是一种较好的选择，这个时候<strong>手动管理</strong>往往比自动来得更安全，降低后期可能的维护成本。</p>
<hr>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li>在解析类的<code>@Autowired</code>注入元数据的时候，Spring工厂/容器明明已经准备好了，理论上已经<strong>完全具备</strong>帮你完成注入/赋值的能力，既然这样，为何Spring还偏要“拒绝”这么干呢？可直接注入static成员不香吗？</li>
<li>既然<code>@Autowired</code>不能注入static属性，那么static方法呢？@Value注解呢？ </li>
</ol>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了Spring依赖注入和static的关系，从使用背景到原因分析都做了相应的阐述，A哥觉得还是蛮香的，对你帮助应该不小吧。</p>
<p>最后，我想对小伙伴说：依赖注入的<strong>主要目的</strong>，是让容器去产生一个对象的实例然后管理它的生命周期，然后<strong>在生命周期中</strong>使用他们，这会让单元测试工作更加容易（什么？不写单元测试，那你应该关注我喽，下下下个专栏会专门讲单元测试）。而如果你使用静态变量/类变量就<strong>扩大了</strong>使用范围，使得不可控了。这种static field是<strong>隐含共享</strong>的，并且是一种global全局状态，Spring并不推荐你去这么做，因此使用起来务必当心~</p>]]></content>
      <categories>
        <category>Spring static关键字</category>
      </categories>
      <tags>
        <tag>Spring Framework</tag>
        <tag>static</tag>
        <tag>@Autowired</tag>
      </tags>
  </entry>
  <entry>
    <title>static关键字有何魔法？竟让Spring Boot搞出那么多静态内部类</title>
    <url>/x2y/fa005713.html</url>
    <content><![CDATA[<blockquote>
<p>当大潮退去，才知道谁在裸泳。<br><strong>作者</strong>：A哥（YourBatman）<br><strong>公众号</strong>：BAT的乌托邦（ID：BAT-utopia）<br><strong>文末是否有彩蛋</strong>：有</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>各位小伙伴大家好，我是A哥。<a href="https://mp.weixin.qq.com/s/VTB9f8S6TYeuNVd4Z71zUw" target="_blank" rel="noopener">上篇文章</a>了解了<strong>static关键字 + @Bean方法</strong>的使用，知晓了它能够提升Bean的优先级，在@Bean方法前标注static关键字，特定情况下可以避免一些烦人的“警告”日志的输出，排除隐患让工程变得更加安全。我们知道static关键字它不仅可使用在方法上，那么本文将继续挖掘static在Spring环境下的用处。</p>
<p>根据所学的JavaSE基础，static关键字除了能够修饰方法外，还能使用在这两个地方：</p>
<ol>
<li>修饰类。确切的说，应该叫修饰<strong>内部类</strong>，所以它叫静态内部类</li>
<li>修饰成员变量</li>
</ol>
<blockquote>
<p>其实static还可以修饰代码块、static静态导包等，但很明显，这些与本文无关</p>
</blockquote>
<p>接下来就以这为两条主线，分别研究static在对应场景下的作用，本文将聚焦在静态内部类上。<br><img data-src="https://img-blog.csdnimg.cn/20200601065329491.png#x200" alt=""></p>
<hr>
<h2 id="版本约定"><a href="#版本约定" class="headerlink" title="版本约定"></a>版本约定</h2><p>本文内容若没做特殊说明，均基于以下版本：</p>
<ul>
<li>JDK：<code>1.8</code></li>
<li>Spring Framework：<code>5.2.2.RELEASE</code></li>
</ul>
<hr>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>说到Java里的static关键字，这当属最基础的入门知识，是Java中常用的关键字之一。你平时用它来修饰变量和方法了，但是对它的了解，即使放在JavaSE情景下知道这些还是<strong>不够的</strong>，问题虽小但这往往反映了你对Java基础的了解程度。</p>
<p>当然喽，本文并不讨论它在JavaSE下使用，毕竟咱们还是<strong>有一定逼格的</strong>专栏，需要进阶一把，玩玩它在Spring环境下到底能够迸出怎么样的火花呢？比如静态内部类~</p>
<hr>
<h2 id="Spring下的静态内部类"><a href="#Spring下的静态内部类" class="headerlink" title="Spring下的静态内部类"></a>Spring下的静态内部类</h2><p>static修饰类<strong>只有一种情况</strong>：那就是这个类属于内部类，这就是我们津津乐道的<strong>静态内部类</strong>，形如这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String innerName;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Integer innerAge;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 无法访问外部类的成员变量</span></span><br><span class="line">            <span class="comment">//System.out.println(name);</span></span><br><span class="line">            System.out.println(age);</span><br><span class="line"></span><br><span class="line">            System.out.println(innerName);</span><br><span class="line">            System.out.println(innerAge);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 静态内部类的实例化并不需要依赖于外部类的实例</span></span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际开发中，静态内部类的使用场景是非常之多的。</p>
<hr>
<h3 id="认识静态-普通内部类"><a href="#认识静态-普通内部类" class="headerlink" title="认识静态/普通内部类"></a>认识静态/普通内部类</h3><p>由于一些小伙伴对普通内部类 vs 静态内部类傻傻分不清，为了方便后续讲解，本处把<strong>关键要素</strong>做简要对比说明：</p>
<ol>
<li>静态内部类可以声明静态or实例成员(属性和方法)；而普通内部类则<strong>不可以</strong>声明静态成员(属性和方法)</li>
<li>静态内部类实例的创建<strong>不依赖于</strong>外部类；而普通外部类实例创建必须先有外部类实例才行（绑定关系拿捏得死死的，不信你问郑凯）</li>
<li>静态内部类<strong>不能</strong>访问外部类的实例成员；而普通内部类可以随意访问(不管静态or非静态)  –&gt; 我理解这是普通内部类能 <strong>“存活”</strong> 下来的最大理由了吧😄</li>
</ol>
<p>总之，普通内部类和外部类的关系属于<strong>强绑定</strong>，而静态内部类几乎不会受到外部类的限制，可以游离<strong>单独使用</strong>。既然如此，那为何还需要static静态内部类呢，直接单独写个Class类岂不就好了吗？存在即合理，这么使用的原因我个人觉得有如下两方面思考，供以你参考：</p>
<ul>
<li>静态内部类是弱关系并不是没关系，比如它还是可以访问外部类的static的变量的不是（即便它是private的）</li>
<li><strong>高内聚的体现</strong> </li>
</ul>
<p>在传统<code>Spirng Framework</code>的配置类场景下，你可能鲜有接触到static关键字使用在类上的场景，但这在Spring Boot下使用非常频繁，比如属性配置类的典型应用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"server"</span>, ignoreUnknownFields = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerProperties</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// server.port = xxx </span></span><br><span class="line">	<span class="comment">// server.address = xxx</span></span><br><span class="line">	<span class="keyword">private</span> Integer port;</span><br><span class="line">	<span class="keyword">private</span> InetAddress address;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// tomcat配置</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tomcat</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// server.tomcat.protocol-header = xxx</span></span><br><span class="line">		<span class="keyword">private</span> String protocolHeader;</span><br><span class="line">		...</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// tomcat内的log配置</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Accesslog</span> </span>&#123;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// server.tomcat.accesslog.enabled = xxx</span></span><br><span class="line">			<span class="keyword">private</span> <span class="keyword">boolean</span> enabled = <span class="keyword">false</span>;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种嵌套case使得代码（配置）的key <strong>内聚性非常强</strong>，使用起来更加方便。试想一下，如果你<strong>不使用</strong>静态内部类去集中管理这些配置，每个配置都单独书写的话，像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"server"</span>, ignoreUnknownFields = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerProperties</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"server.tomcat"</span>, ignoreUnknownFields = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TomcatProperties</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"server.tomcat.accesslog"</span>, ignoreUnknownFields = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccesslogProperties</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这代码，就问你，如果是你同事写的，你骂不骂吧！用<strong>臃肿</strong>来形容还是个中意词，层次结构体现得也非常的不直观嘛。因此，对于这种属性类里使用静态内部类是非常适合，内聚性一下子高很多~</p>
<p>除了在内聚性上的作用，在Spring Boot中的<code>@Configuration</code>配置类下（特别常见于自动配置类）也能经常看到它的身影：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// web MVC个性化定制配置</span></span><br><span class="line">	<span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line">	<span class="meta">@Import</span>(EnableWebMvcConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">	@<span class="title">EnableConfigurationProperties</span>(</span>&#123; WebMvcProperties<span class="class">.<span class="keyword">class</span>, <span class="title">ResourceProperties</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">	@<span class="title">Order</span>(0)</span></span><br><span class="line"><span class="class">	<span class="title">public</span> <span class="title">static</span> <span class="title">class</span> <span class="title">WebMvcAutoConfigurationAdapter</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EnableWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">DelegatingWebMvcConfiguration</span> <span class="keyword">implements</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用静态内部类把相似配置类<strong>归并</strong>在一个 <strong>.java文件</strong> 内，这样多个static类还可<strong>公用</strong>外部类的属性、方法，也是一种高内聚的体现。同时static关键字提升了初始化的优先级，比如本例中的<code>EnableWebMvcConfiguration</code>它会优先于外部类加载~</p>
<p>关于static静态内部类优先级相关是<strong>重点</strong>，静态内部类的优先级会更高吗？使用普通内部能达到同样效果吗？拍脑袋直接回答是没用的，带着这两个问题，接下来A哥举例领你一探究竟…</p>
<hr>
<h3 id="static静态配置类提升配置优先级"><a href="#static静态配置类提升配置优先级" class="headerlink" title="static静态配置类提升配置优先级"></a>static静态配置类提升配置优先级</h3><p>自己先构造一个Demo，场景如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    OuterConfig() &#123;</span><br><span class="line">        System.out.println(<span class="string">"OuterConfig init..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Parent <span class="title">parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Parent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerConfig</span> </span>&#123;</span><br><span class="line">        InnerConfig() &#123;</span><br><span class="line">            System.out.println(<span class="string">"InnerConfig init..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function">Daughter <span class="title">daughter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Daughter();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpring</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> AnnotationConfigApplicationContext(TestSpring<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动程序，结果输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InnerConfig init...</span><br><span class="line">OuterConfig init...</span><br><span class="line">Daughter init...</span><br><span class="line">Parent init...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果细节：似乎都是按照字母表的顺序来执行的。I在前O在后；D在前P在后；</p>
</blockquote>
<p>看到这个结果，如果你就过早的得出结论：静态内部类优先级高于外部类，那么就太随意了，图样图森破啊。<strong>大胆猜想，小心求证</strong> 应该是程序员应有的态度，那么继续往下看，在此基础上我新增加一个静态内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    OuterConfig() &#123;</span><br><span class="line">        System.out.println(<span class="string">"OuterConfig init..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Parent <span class="title">parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Parent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PInnerConfig</span> </span>&#123;</span><br><span class="line">        PInnerConfig() &#123;</span><br><span class="line">            System.out.println(<span class="string">"PInnerConfig init..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function">Son <span class="title">son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Son();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerConfig</span> </span>&#123;</span><br><span class="line">        InnerConfig() &#123;</span><br><span class="line">            System.out.println(<span class="string">"InnerConfig init..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function">Daughter <span class="title">daughter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Daughter();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我先解释下我这么做的意图：</p>
<ol>
<li>增加一个字母P开头的内部类，自然顺序P在O（外部类）后面，消除影响</li>
<li>P开头的内部类在源码摆放顺序上<strong>故意</strong>放在了I开头的内部类的<strong>上面</strong>，同样为了消除字母表顺序带来的影响<ol>
<li>目的：看看是按照字节码顺序，还是字母表顺序呢？</li>
</ol>
</li>
<li>PInnerConfig里面的@Bean实例为Son，字母表顺序是三者中最为靠后的，但字节码却在中间，这样也能够消除影响</li>
</ol>
<p>运行程序，结果输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InnerConfig init...</span><br><span class="line">PInnerConfig init...</span><br><span class="line">OuterConfig init...</span><br><span class="line">Daughter init...</span><br><span class="line">son init...</span><br><span class="line">Parent init...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果细节：外部类貌似总是滞后于内部类初始化；同一类的多个内部类之间顺序是按照字母表顺序（自然排序）初始化而非字节码顺序；@Bean方法的顺序依照了类的顺序</p>
</blockquote>
<p><strong>请留意本结果和上面结果是否有区别</strong>，你应该若有所思。</p>
<p>这是单.java文件的case（所有static类都在同一个.java文件内），接下来我在同目录下<strong>增加</strong> 2个.java文件（请自行留意类名第一个字母，我将不再赘述我的设计意图）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件一：</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A_OuterConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    A_OuterConfig() &#123;</span><br><span class="line">        System.out.println(<span class="string">"A_OuterConfig init..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">String <span class="title">a_o_bean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A_OuterConfig a_o_bean init..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PInnerConfig</span> </span>&#123;</span><br><span class="line">        PInnerConfig() &#123;</span><br><span class="line">            System.out.println(<span class="string">"A_OuterConfig PInnerConfig init..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function">String <span class="title">a_p_bean</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"A_OuterConfig a_p_bean init..."</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerConfig</span> </span>&#123;</span><br><span class="line">        InnerConfig() &#123;</span><br><span class="line">            System.out.println(<span class="string">"A_OuterConfig InnerConfig init..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function">String <span class="title">a_i_bean</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"A_OuterConfig a_i_bean init..."</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件二：</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Z_OuterConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Z_OuterConfig() &#123;</span><br><span class="line">        System.out.println(<span class="string">"Z_OuterConfig init..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">String <span class="title">z_o_bean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Z_OuterConfig z_o_bean init..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PInnerConfig</span> </span>&#123;</span><br><span class="line">        PInnerConfig() &#123;</span><br><span class="line">            System.out.println(<span class="string">"Z_OuterConfig PInnerConfig init..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function">String <span class="title">z_p_bean</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Z_OuterConfig z_p_bean init..."</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerConfig</span> </span>&#123;</span><br><span class="line">        InnerConfig() &#123;</span><br><span class="line">            System.out.println(<span class="string">"Z_OuterConfig InnerConfig init..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function">String <span class="title">z_i_bean</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Z_OuterConfig z_i_bean init..."</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，结果输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A_OuterConfig InnerConfig init...</span><br><span class="line">A_OuterConfig PInnerConfig init...</span><br><span class="line">A_OuterConfig init...</span><br><span class="line">InnerConfig init...</span><br><span class="line">PInnerConfig init...</span><br><span class="line">OuterConfig init...</span><br><span class="line">Z_OuterConfig InnerConfig init...</span><br><span class="line">Z_OuterConfig PInnerConfig init...</span><br><span class="line">Z_OuterConfig init...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A_OuterConfig a_i_bean init...</span><br><span class="line">A_OuterConfig a_p_bean init...</span><br><span class="line">A_OuterConfig a_o_bean init...</span><br><span class="line">Daughter init...</span><br><span class="line">son init...</span><br><span class="line">Parent init...</span><br><span class="line">Z_OuterConfig z_i_bean init...</span><br><span class="line">Z_OuterConfig z_p_bean init...</span><br><span class="line">Z_OuterConfig z_o_bean init...</span><br></pre></td></tr></table></figure>
<p>这个结果大而全，是有说服力的，通过这几个示例可以总结出如下结论：</p>
<ol>
<li><strong>垮.java文件</strong> （垮配置类）之间的顺序，是由自然顺序来保证的（字母表顺序）<ol>
<li>如上：下加载A打头的配置类（含静态内部类），再是O打头的，再是Z打头的</li>
</ol>
</li>
<li><strong>同一.java文件内部</strong>，static静态内部类<strong>优先于</strong>外部类初始化。若有多个静态内部类，那么按照类名自然排序初始化（并非按照定义顺序哦，请务必注意）<ol>
<li>说明：一般内部类只可能与外部类“发生关系”，与兄弟之间不建议有任何联系，否则顺序控制上你就得当心了。毕竟靠自然顺序去保证是一种弱保证，容错性太低</li>
</ol>
</li>
<li><strong>同一.java文件内</strong>，不同类内的@Bean方法之间的执行顺序，保持同2一致（也就说你的@Bean所在的@Configuration配置类先加载，那你就优先被初始化喽）<ol>
<li>同一Class内多个@Bean方法的执行顺序，上篇文章<a href="https://mp.weixin.qq.com/s/VTB9f8S6TYeuNVd4Z71zUw" target="_blank" rel="noopener">static关键字真能提高Bean的优先级吗？答：真能</a> 就已经说过了哈，请移步参见</li>
</ol>
</li>
</ol>
<p>总的来说，当static标注在class类上时，在<strong>同.java文件内</strong>它是能够提升优先级的，这对于<code>Spring Boot</code>的自动配置非常有意义，主要体现在如下两个方法：</p>
<ul>
<li>static静态内部类配置优先于外部类加载，从而静态内部类里面的@Bean也<strong>优先于</strong>外部类的@Bean先加载</li>
<li>既然这样，那么Spring Boot自动配置就可以结合此特性，就可以进行具有优先级的<code>@Conditional</code>条件判断了。这里我举个官方的例子，你便能感受到它的魅力所在：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignClientsConfiguration</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="keyword">public</span> Feign.<span class="function">Builder <span class="title">feignBuilder</span><span class="params">(Retryer retryer)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Feign.builder().retryer(retryer);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Configuration</span></span><br><span class="line">	<span class="meta">@ConditionalOnClass</span>(&#123; HystrixCommand<span class="class">.<span class="keyword">class</span>, <span class="title">HystrixFeign</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">	<span class="title">protected</span> <span class="title">static</span> <span class="title">class</span> <span class="title">HystrixFeignConfiguration</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line">		<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">		<span class="meta">@ConditionalOnProperty</span>(name = <span class="string">"feign.hystrix.enabled"</span>)</span><br><span class="line">		<span class="keyword">public</span> Feign.<span class="function">Builder <span class="title">feignHystrixBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> HystrixFeign.builder();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>HystrixFeign.builder()</code>它属于静态内部类，所以这个@Bean肯定是优先于外部的<code>Feign.builder()</code>先加载的。所以这段逻辑可解释为：优先使用<code>HystrixFeign.builder()</code>（若条件满足），否则使用<code>Feign.builder().retryer(retryer)</code>作为兜底。通过此例你应该再一次感受到<strong>Bean的加载顺序之于Spring应用的重要性</strong>，特别在Spring Boot/Cloud下此特性尤为凸显。</p>
<p>你以为记住这几个结论就完事了？不，这明显不符合A哥的逼格嘛，下面我们就来继续挖一挖吧。<br><img data-src="https://img-blog.csdnimg.cn/20200602131928138.png#x200" alt=""></p>
<hr>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>关于<code>@Configuration</code>配置类的顺序问题，事前需强调两点：</p>
<ol>
<li>不同 <strong>.java文件</strong> 之间的加载顺序是不重要的，Spring官方也强烈建议使用者不要去依赖这种顺序<ol>
<li>因为无状态性，因此你在使用过程中可以认为垮<code>@Configuration</code>文件之前的初始化顺序<strong>是不确定的</strong></li>
</ol>
</li>
<li><strong>同一.javaw文件</strong>内也可能存在多个<code>@Configuration</code>配置类（比如静态内部类、普通内部类等），它们之间的顺序是我们<strong>需要关心</strong>的，并且需要强依赖于这个顺序编程（比如Spring Boot）</li>
</ol>
<p><code>@Configuration</code>配置类只有是被<code>@ComponentScan</code>扫描进来（或者被Spring Boot自动配置加载进来）才需要讨论顺序（倘若是构建上下文时自己手动指好的，那顺序就已经定死了嘛），实际开发中的配置类也确实是酱紫的，一般都是通过扫描被加载。接下来我们看看<code>@ComponentScan</code>是如何扫描的，把此注解的解析步骤（伪代码）展示如下：</p>
<blockquote>
<p>说明：本文并不会着重分析@ComponentScan它的解析原理，只关注本文“感兴趣”部分</p>
</blockquote>
<p>1、解析配置类上的<code>@ComponentScan</code>注解(们)：本例中<code>TestSpring</code>作为扫描入口，会扫描到A_OuterConfig/OuterConfig等配置类们</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConfigurationClassParser#doProcessConfigurationClass：</span><br><span class="line"></span><br><span class="line">	<span class="comment">// **最先判断** 该配置类是否有成员类（普通内部类）</span></span><br><span class="line">	<span class="comment">// 若存在普通内部类，最先把普通内部类给解析喽（注意，不是静态内部类）</span></span><br><span class="line">	<span class="keyword">if</span> (configClass.getMetadata().isAnnotated(Component<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())) </span>&#123;</span><br><span class="line">		processMemberClasses(configClass, sourceClass);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历该配置类上所有的@ComponentScan注解</span></span><br><span class="line">	<span class="comment">// 使用ComponentScanAnnotationParser一个个解析</span></span><br><span class="line">	<span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">		Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions = <span class="keyword">this</span>.componentScanParser.parse(componentScan,...);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 继续判断扫描到的bd是否是配置类，递归调用</span></span><br><span class="line">		... </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>细节说明：关于最先解析内部类时需要特别注意，Spring通过<code>sourceClass.getMemberClasses()</code>来获取内部类们：只有普通内部类属于这个，static静态内部类<strong>并不属于</strong>它，这点很重要哦</p>
</blockquote>
<p>2、解析该注解上的basePackages/basePackageClasses等属性值得到一些扫描的<strong>基包</strong>，委托给ClassPathBeanDefinitionScanner去完成扫描</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ComponentScanAnnotationParser#parse</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用ClassPathBeanDefinitionScanner扫描，基于类路径哦</span></span><br><span class="line">	scanner.doScan(StringUtils.toStringArray(basePackages));</span><br></pre></td></tr></table></figure>
<p>3、遍历<strong>每个基包</strong>，从文件系统中定位到资源，把符合条件的<strong>Spring组件</strong>（强调：这里只指外部@Configuration配置类，还没涉及到里面的@Bean这些）注册到BeanDefinitionRegistry注册中心</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ComponentScanAnnotationParser#doScan</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">		<span class="comment">// 这个方法是本文最需要关注的方法</span></span><br><span class="line">		Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">		<span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">			...</span><br><span class="line">			<span class="comment">// 把该配置**类**(并非@Bean方法)注册到注册中心</span></span><br><span class="line">			registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>到这一步就完成了Bean定义的注册，此处可以验证一个结论：<strong>多个配置类之间，谁先被扫描到，就先注册谁，对应的就是谁最先被初始化</strong>。那么这个顺序到底是咋样界定的呢？那么就要来到这中间<strong>最为重要</strong>（本文最关心）的一步喽：<code>findCandidateComponents(basePackage)</code>。</p>
<blockquote>
<p>说明：Spring 5.0开始增加了<code>@Indexed</code>注解为云原生做了准备，可以让scan扫描动作在编译期就完成，但这项技术还不成熟，暂时几乎无人使用，因此本文仍旧只关注经典模式的实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPathScanningCandidateComponentProvider#scanCandidateComponents</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 最终返回的候选组件们</span></span><br><span class="line">	Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 得到文件系统的路径，比如本例为classpath*:com/yourbatman/**/*.class</span></span><br><span class="line">	String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +</span><br><span class="line">					resolveBasePackage(basePackage) + <span class="string">'/'</span> + <span class="keyword">this</span>.resourcePattern;</span><br><span class="line">	<span class="comment">// 从文件系统去加载Resource资源文件进来</span></span><br><span class="line">	<span class="comment">// 这里Resource代表的是一个本地资源：存在你硬盘上的.class文件</span></span><br><span class="line">	Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);</span><br><span class="line">	<span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class="line">				candidates.add(sbd);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的信息量是很大的，分解为如下两大步：</p>
<ol>
<li>通过ResourcePatternResolver从磁盘里加载到<strong>所有的</strong> .class资源Resource[]。这里面<strong>顺序信息</strong>就出现了，加载磁盘Resource资源的过程很复杂，总而言之它依赖于你os文件系统。所以关于资源的顺序可简单理解为：<strong>你磁盘文件里是啥顺序它就按啥顺序加载进来</strong></li>
</ol>
<blockquote>
<p>注意：不是看.java源代码顺序，也不是看你<code>target</code>目录下的文件顺序（该目录是经过了IDEA反编译的结果，无法反应真实顺序），而是编译后看你的<strong>磁盘上的</strong>.class文件的文件顺序</p>
</blockquote>
<ol start="2">
<li>遍历每一个Resource资源，并不是每个资源都会成为candidates候选，它有个<strong>双重过滤</strong>（对应两个isCandidateComponent()方法）：<ol>
<li>过滤一：使用TypeFilter执行过滤，看看是否被排除；再看看是否满足<code>@Conditional</code>条件</li>
<li>过滤二：它有两种case能满足条件（任意满足一个case即可）<ol>
<li><code>isIndependent()</code>是独立类（top-level类 or 静态内部类属于独立类） <strong>并且</strong> isConcrete()是具体的（非接口非抽象类）</li>
<li><code>isAbstract()</code>是抽象类 <strong>并且</strong> 类内存在标注有<code>@Lookup</code>注解的方法</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>基于以上例子，磁盘中的.class文件情况如下：<br><img data-src="https://img-blog.csdnimg.cn/20200602135110469.png#x180" alt=""><br>看着这个顺序，再结合上面的打印结果，是不是感觉得到了解释呢？既然@Configuration类（外部类和内部类）的顺序确定了，那么@Bean就跟着定了喽，因为毕竟配置类也得遍历一个一个去执行嘛（有依赖关系的case除外）。</p>
<blockquote>
<p>特别说明：理论上不同的操作系统（如windows和Linux）它们的文件系统是有差异的，对文件存放的顺序是可能不同的（比如$xxx内部类可能放在后面），但<strong>现实状况</strong>它们是一样的，因此各位同学对此无需担心跨平台问题哈，这由JVM底层来给你保证。</p>
</blockquote>
<p>什么，关于此解析步骤你想要张流程图？好吧，你知道的，这个A哥会放到本专栏的<strong>总结篇</strong>里统一供以你白嫖，关注我公众号吧~</p>
<hr>
<h4 id="静态内部类在容器内的beanName是什么？"><a href="#静态内部类在容器内的beanName是什么？" class="headerlink" title="静态内部类在容器内的beanName是什么？"></a>静态内部类在容器内的beanName是什么？</h4><p>看到这个截图你就懂了：在不同.java文件内，静态内部类是不用担心重名问题的，这不也就是内聚性的一种体现麽。<br><img data-src="https://img-blog.csdnimg.cn/20200602140854236.png#x160" alt=""><br>说明：beanName的生成其实和你注册Bean的方式有关，比如@Import、Scan方式是不一样的，这里就不展开讨论了，知道有这个差异就成。</p>
<hr>
<h2 id="进阶：Spring下普通内部类表现如何？"><a href="#进阶：Spring下普通内部类表现如何？" class="headerlink" title="进阶：Spring下普通内部类表现如何？"></a>进阶：Spring下普通内部类表现如何？</h2><p>我们知道，从内聚性上来说，普通内部类似乎也可以达到目的。但是相较于静态内部类在Spring容器内对优先级的问题，它的表现可就没这么好喽。基于以上例子，把所有的static关键字<strong>去掉</strong>，就是本处需要的case。</p>
<p>reRun测试程序，结果输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A_OuterConfig init...</span><br><span class="line">OuterConfig init...</span><br><span class="line">Z_OuterConfig init...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A_OuterConfig InnerConfig init...</span><br><span class="line">A_OuterConfig a_i_bean init...</span><br><span class="line">A_OuterConfig PInnerConfig init...</span><br><span class="line">A_OuterConfig a_p_bean init...</span><br><span class="line">A_OuterConfig a_o_bean init...</span><br><span class="line"></span><br><span class="line">InnerConfig init...</span><br><span class="line">Daughter init...</span><br><span class="line">PInnerConfig init...</span><br><span class="line">son init...</span><br><span class="line">Parent init...</span><br><span class="line"></span><br><span class="line">Z_OuterConfig InnerConfig init...</span><br><span class="line">Z_OuterConfig z_i_bean init...</span><br><span class="line">Z_OuterConfig PInnerConfig init...</span><br><span class="line">Z_OuterConfig z_p_bean init...</span><br><span class="line">Z_OuterConfig z_o_bean init...</span><br></pre></td></tr></table></figure>
<p>对于这个结果A哥不用再做详尽分析了，看似比较复杂其实有了上面的分析还是比较容易理解的。主要有如下两点需要注意：</p>
<ol>
<li>普通内部类它不是一个独立的类（也就是说<code>isIndependent() = false</code>），所以它并不能像静态内部类那样预先就被<strong>扫描进去</strong>，如图结果展示：<br><img data-src="https://img-blog.csdnimg.cn/20200602143335570.png#x200" alt=""></li>
<li>普通内部类初始化之前，<strong>一定</strong>得先初始化外部类，所以类本身的优先级是低于外部类的（不包含@Bean方法哦）</li>
<li>普通内部类属于外部类的memberClasses，因此它会在解析<strong>当前外部类</strong>的第一步<code>processMemberClasses()</code>时被解析</li>
<li>普通内部类的beanName和静态内部类是有差异的，如下截图：<br><img data-src="https://img-blog.csdnimg.cn/2020060214460054.png#x260" alt=""></li>
</ol>
<hr>
<h2 id="思考题："><a href="#思考题：" class="headerlink" title="思考题："></a>思考题：</h2><p>请思考：为何使用普通内部类得到的是这个结果呢？建议copy我的demo，自行走一遍流程，多动手总是好的</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文一如既往的很干哈。写本文的<strong>原动力</strong>是因为真的太多小伙伴在看Spring Boot自动配置类的时候，无法理解为毛它有些@Bean配置要单独写在一个<strong>static静态类</strong>里面，感觉挺费事；方法前直接价格static不香吗？通过<strong>这篇文章 + 上篇文章</strong>的解读，相信A哥已经给了你答案了。</p>
<p>static关键字在Spring中使用的这个专栏，下篇将进入到可能是你<strong>更关心</strong>的一个话题：为毛static字段不能使用@Autowired注入的分析，下篇见~</p>]]></content>
      <categories>
        <category>Spring static关键字</category>
      </categories>
      <tags>
        <tag>Spring Framework</tag>
        <tag>Spring Boot</tag>
        <tag>static</tag>
      </tags>
  </entry>
  <entry>
    <title>static关键字真能提高Bean的优先级吗？答：真能</title>
    <url>/x2y/6abf4a82.html</url>
    <content><![CDATA[<blockquote>
<p>当大潮退去，才知道谁在裸泳。<br><strong>作者</strong>：A哥（YourBatman）<br><strong>公众号</strong>：BAT的乌托邦（ID：BAT-utopia）<br><strong>文末是否有彩蛋</strong>：有</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>各位小伙伴大家好，我是A哥。关于Spring初始化Bean的顺序问题，是个老生常谈的话题了，结论可总结为一句话：<strong>全局无序，局部有序</strong>。<code>Spring Bean</code>整体上是无序的，而现实是大多数情况下我们<strong>真的</strong>无需关心，无序就无序呗，无所谓喽。但是（此处应该有但是哈），我有理由相信，对于有一定从业经验的Javaer来说，或多或少都经历过Bean初始化顺序带来的“困扰”，也许是因为没有对你的功能造成影响，也许可能是你全然“不知情”，所以最终就不了了之~</p>
<p>隐患终归隐患，依照<strong>墨菲定律</strong>来讲，担心的事它总归是会发生的。A哥经常“教唆”程序员要<strong>面向工资编程</strong>，虽然这价值观有点扭曲，但不可否认很多小伙伴真是这么想的（命中你了没有😄），稍加粉饰了而已。话粗理不粗哦，almost所有的Javaer都在用Spring，你凭什么工资比你身边同事的高呢？<br><img data-src="https://img-blog.csdnimg.cn/20200530222152352.png#x200" alt=""><br>Spring对Bean的（生命周期）管理是它最为核心的能力，同时也是<strong>很复杂、很难掌握</strong>的一个知识点。现在就可以启动你的工程，有木有这句日志：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">"Bean 'xxx' of type [xxxx] is not eligible for getting processed by all BeanPostProcessors"</span> </span><br><span class="line">	+ <span class="string">"(for example: not eligible for auto-proxying)"</span></span><br></pre></td></tr></table></figure>
<p>这是一个典型的<strong>Spring Bean过早初始化</strong>问题，搜搜看你日志里是否有此句喽。这句日志是由Spring的<code>BeanPostProcessorChecker</code>这个类负责输出，含义为：你的Bean xxx不能被所有的<code>BeanPostProcessors</code>处理到（有的生命周期触达不到），提醒你注意。此句日志在低些的版本里是<strong>warn警告</strong>级别，在本文约定的版本里官方把它改为了info级别。</p>
<blockquote>
<p>绝大多数情况下，此句日志的输出不会对你的功能造成影响，因此无需搭理。这也是Spring官方为何把它从warn调低为info级别的原因</p>
</blockquote>
<p>我在CSDN上写过一篇“Spring Bean过早初始化导致的误伤”的文章，<strong>访问量达近4w</strong>：<br><img data-src="https://img-blog.csdnimg.cn/20200531065807513.png#x50" alt=""><br>从这个数据（访问量）上来看，这件事“并不简单”，遇到此麻烦的小伙伴不在少数且确实难倒了一众人。关于Spring Bean的顺序，全局是不可控的，但是局部上它提供了多种方式来方便使用者提高/降低优先级（比如前面的<a href="https://mp.weixin.qq.com/s/bNQMoTyrr8pYEHYdIjHW8A" target="_blank" rel="noopener">使用@AutoConfigureBefore调整配置顺序竟没生效？</a>这篇文章），本文就聊聊<strong>static关键字对于提供Bean的优先级</strong>的功效。<br><img data-src="https://img-blog.csdnimg.cn/20200531070853300.jpg#x200" alt=""></p>
<hr>
<h2 id="版本约定"><a href="#版本约定" class="headerlink" title="版本约定"></a>版本约定</h2><p>本文内容若没做特殊说明，均基于以下版本：</p>
<ul>
<li>JDK：<code>1.8</code></li>
<li>Spring Framework：<code>5.2.2.RELEASE</code></li>
</ul>
<hr>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>本文采用从 <strong>问题提出-结果分析-解决方案-原理剖析</strong> 这4个步骤，层层递进的去感受static关键字在Spring Bean上的魅力~</p>
<hr>
<h2 id="警告一：来自BeanPostProcessorChecker"><a href="#警告一：来自BeanPostProcessorChecker" class="headerlink" title="警告一：来自BeanPostProcessorChecker"></a>警告一：来自BeanPostProcessorChecker</h2><p>这是<strong>最为常见</strong>的一种警告，特别当你的工程使用了<code>shiro</code>做鉴权框架的时候。在我记忆中这一年来有N多位小伙伴问过我此问题，可见一斑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AppConfig() &#123;</span><br><span class="line">        System.out.println(<span class="string">"AppConfig init..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">BeanPostProcessor <span class="title">postProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyBeanPostProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    MyBeanPostProcessor() &#123;</span><br><span class="line">        System.out.println(<span class="string">"MyBeanPostProcessor init..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AppConfig init...</span><br><span class="line"><span class="number">2020</span>-<span class="number">05</span>-<span class="number">31</span> <span class="number">07</span>:<span class="number">40</span>:<span class="number">50.979</span>  INFO <span class="number">15740</span> --- [           main] trationDelegate$BeanPostProcessorChecker : Bean <span class="string">'appConfig'</span></span><br><span class="line">	 of type [com.yourbatman.config.AppConfig$$EnhancerBySpringCGLIB$$<span class="number">29</span>b523c8] is not eligible <span class="keyword">for</span> getting </span><br><span class="line">	 <span class="function">processed by all <span class="title">BeanPostProcessors</span> <span class="params">(<span class="keyword">for</span> example: not eligible <span class="keyword">for</span> auto-proxying)</span></span></span><br><span class="line"><span class="function">MyBeanPostProcessor init...</span></span><br><span class="line"><span class="function">...</span></span><br></pre></td></tr></table></figure>
<p>结果分析（问题点/冲突点）：</p>
<ol>
<li><code>AppConfig</code>优先于<code>MyBeanPostProcessor</code>进行实例化<ol>
<li>常识是：<code>MyBeanPostProcessor</code>作为一个后置处理器理应是先被初始化的，而<code>AppConfig</code>仅仅是个普通Bean而已，初始化<strong>理应靠后</strong></li>
</ol>
</li>
<li>出现了<code>BeanPostProcessorChecker</code>日志：表示<code>AppConfig</code>这个Bena不能被所有的BeanPostProcessors处理，所以有<strong>可能</strong>会让它“错过”容器对Bean的某些生命周期管理，因此<strong>可能</strong>损失某些能力（比如不能被自动代理），存在<strong>隐患</strong><ol>
<li>但凡只要你工程里出现了<code>BeanPostProcessorChecker</code>输出日志，理应都得引起你的注意，因为这属于Spring的警告日志（虽然新版本已下调为了info级别）</li>
</ol>
</li>
</ol>
<blockquote>
<p>说明：这是一个Info日志，并非warn/error级别。绝大多数情况下你确实无需关注，但是如果你是一个容器开发者，建议请务必解决此问题（毕竟貌似大多数中间件开发者都有一定代码洁癖😄）</p>
</blockquote>
<hr>
<h3 id="解决方案：static关键字提升优先级"><a href="#解决方案：static关键字提升优先级" class="headerlink" title="解决方案：static关键字提升优先级"></a>解决方案：static关键字提升优先级</h3><p>基于上例，我们仅需做如下小改动：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AppConfig：</span><br><span class="line"></span><br><span class="line"><span class="comment">//@Bean</span></span><br><span class="line"><span class="comment">//BeanPostProcessor postProcessor() &#123;</span></span><br><span class="line"><span class="comment">//    return new MyBeanPostProcessor();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法前面加上static关键字</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BeanPostProcessor <span class="title">postProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyBeanPostProcessor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，结果输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyBeanPostProcessor init...</span><br><span class="line">...</span><br><span class="line">AppConfig init...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>那个烦人的<code>BeanPostProcessorChecker</code>日志就不见了，清爽了很多。同时亦可发现<code>AppConfig</code>是在<code>MyBeanPostProcessor</code>之后实例化的，这才符合我们所想的“正常”逻辑嘛。</p>
<hr>
<h2 id="警告二：Configuration配置类增强失败"><a href="#警告二：Configuration配置类增强失败" class="headerlink" title="警告二：Configuration配置类增强失败"></a>警告二：Configuration配置类增强失败</h2><p>这个“警告”就比上一个严重得多了，它有<strong>极大的可能</strong>导致你程序错误，并且你还<strong>很难定位</strong>问题所在。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AppConfig() &#123;</span><br><span class="line">        System.out.println(<span class="string">"AppConfig init..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">BeanDefinitionRegistryPostProcessor <span class="title">postProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyBeanDefinitionRegistryPostProcessor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">///////////////////////////////</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Son <span class="title">son</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Son();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Parent <span class="title">parent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Parent(son());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBeanDefinitionRegistryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    MyBeanDefinitionRegistryPostProcessor() &#123;</span><br><span class="line">        System.out.println(<span class="string">"MyBeanDefinitionRegistryPostProcessor init..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，结果输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AppConfig init...</span><br><span class="line">MyBeanDefinitionRegistryPostProcessor init...</span><br><span class="line"><span class="number">2020</span>-<span class="number">05</span>-<span class="number">31</span> <span class="number">07</span>:<span class="number">59</span>:<span class="number">06.363</span>  INFO <span class="number">37512</span> --- [           main] o.s.c.a.ConfigurationClassPostProcessor  : Cannot enhance</span><br><span class="line">	 <span class="meta">@Configuration</span> bean definition <span class="string">'appConfig'</span> since its singleton instance has been created too early. The typical</span><br><span class="line">	 cause is a non-<span class="keyword">static</span> <span class="meta">@Bean</span> method with a BeanDefinitionRegistryPostProcessor <span class="keyword">return</span> type: Consider declaring</span><br><span class="line">	 such methods as <span class="string">'static'</span>.</span><br><span class="line">...</span><br><span class="line">son init...hashCode() = <span class="number">1300528434</span></span><br><span class="line">son init...hashCode() = <span class="number">1598434875</span></span><br><span class="line">Parent init...</span><br></pre></td></tr></table></figure>
<p>结果分析（问题点/冲突点）：</p>
<ol>
<li>AppConfig竟然比MyBeanDefinitionRegistryPostProcessor的初始化时机还早，这本就不合理</li>
<li>从<code>ConfigurationClassPostProcessor</code>的日志中可看到：<strong>AppConfig配置类enhance增强失败</strong></li>
<li>Son对象竟然被创建了<strong>两个</strong>不同的实例，这将会直接导致功能性错误</li>
</ol>
<p>这三步结果环环相扣，因为1导致了2的增强失败，因为2的增强失败导致了3的创建多个实例，真可谓<strong>一步错，步步错</strong>。需要注意的是：这里ConfigurationClassPostProcessor输出的依旧是info日志（我个人认为，Spring把这个输出调整为warn级别是更为合理的，因为它影响较大）。</p>
<blockquote>
<p>说明：对这个结果的理解基于对Spring配置类的理解，因此强烈建议你进我公众号参阅那个可能是写的最全、最好的Spring配置类专栏学习（文章不多，6篇足矣）</p>
</blockquote>
<p>源码处解释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConfigurationClassPostProcessor：</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对Full模式的配置类尝试使用CGLIB字节码提升</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enhanceConfigurationClasses</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 对Full模式的配置类有个判断/校验</span></span><br><span class="line">	<span class="keyword">if</span> (ConfigurationClassUtils.CONFIGURATION_CLASS_FULL.equals(configClassAttr)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(beanDef <span class="keyword">instanceof</span> AbstractBeanDefinition)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Cannot enhance @Configuration bean definition '"</span> +</span><br><span class="line">					beanName + <span class="string">"' since it is not stored in an AbstractBeanDefinition subclass"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 若判断发现此时该配置类已经是个单例Bean了（说明已初始化完成）</span></span><br><span class="line">		<span class="comment">// 那就不再做处理，并且输出警告日志告知使用者（虽然是info日志）</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (logger.isInfoEnabled() &amp;&amp; beanFactory.containsSingleton(beanName)) &#123;</span><br><span class="line">			logger.info(<span class="string">"Cannot enhance @Configuration bean definition '"</span> + beanName +</span><br><span class="line">					<span class="string">"' since its singleton instance has been created too early. The typical cause "</span> +</span><br><span class="line">					<span class="string">"is a non-static @Bean method with a BeanDefinitionRegistryPostProcessor "</span> +</span><br><span class="line">					<span class="string">"return type: Consider declaring such methods as 'static'."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于配置类增强是在<code>BeanFactoryPostProcessor#postProcessBeanFactory()</code>声明周期阶段去做的，而<code>BeanDefinitionRegistryPostProcessor</code>它会优先于该步骤完成实例化（其实主要是优先级比<code>BeanFactoryPostProcessor</code>高），从而<strong>间接带动</strong> AppConfig提前初始化导致了问题，这便是根本原因所在。</p>
<p>提问点：本处使用了个自定义的<code>BeanDefinitionRegistryPostProcessor</code>模拟了效果，那如果你是使用的<code>BeanFactoryPostProcessor</code>能出来这个效果吗？？？答案是<strong>不能的</strong>，具体原因留给读者思考，可参考：<code>PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors</code>这段流程辅助理解。</p>
<hr>
<h3 id="解决方案：static关键字提升优先级-1"><a href="#解决方案：static关键字提升优先级-1" class="headerlink" title="解决方案：static关键字提升优先级"></a>解决方案：static关键字提升优先级</h3><p>来吧，继续使用static关键字改造一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AppConfig：</span><br><span class="line"></span><br><span class="line"><span class="comment">//@Bean</span></span><br><span class="line"><span class="comment">//BeanDefinitionRegistryPostProcessor postProcessor() &#123;</span></span><br><span class="line"><span class="comment">//    return new MyBeanDefinitionRegistryPostProcessor();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BeanDefinitionRegistryPostProcessor <span class="title">postProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyBeanDefinitionRegistryPostProcessor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，结果输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyBeanDefinitionRegistryPostProcessor init...</span><br><span class="line">...</span><br><span class="line">AppConfig init...</span><br><span class="line">son init...hashCode() = <span class="number">2090289474</span></span><br><span class="line">Parent init...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>完美。</p>
<hr>
<h2 id="警告三：非静态-Bean方法导致-Autowired等注解失效"><a href="#警告三：非静态-Bean方法导致-Autowired等注解失效" class="headerlink" title="警告三：非静态@Bean方法导致@Autowired等注解失效"></a>警告三：非静态@Bean方法导致@Autowired等注解失效</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Parent parent;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AppConfig.parent = "</span> + parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    AppConfig() &#123;</span><br><span class="line">        System.out.println(<span class="string">"AppConfig init..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">BeanFactoryPostProcessor <span class="title">postProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyBeanFactoryPostProcessor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Son <span class="title">son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Son();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Parent <span class="title">parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Parent(son());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    MyBeanFactoryPostProcessor() &#123;</span><br><span class="line">        System.out.println(<span class="string">"MyBeanFactoryPostProcessor init..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，结果输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AppConfig init...</span><br><span class="line"><span class="number">2020</span>-<span class="number">05</span>-<span class="number">31</span> <span class="number">08</span>:<span class="number">28</span>:<span class="number">06.550</span>  INFO <span class="number">1464</span> --- [           main] o.s.c.a.ConfigurationClassEnhancer       : <span class="meta">@Bean</span> method</span><br><span class="line">	 AppConfig.postProcessor is non-<span class="keyword">static</span> and returns an object assignable to Spring<span class="string">'s BeanFactoryPostProcessor</span></span><br><span class="line"><span class="string">	 interface. This will result in a failure to process annotations such as @Autowired, @Resource and </span></span><br><span class="line"><span class="string">	 @PostConstruct within the method'</span>s declaring <span class="meta">@Configuration</span> <span class="class"><span class="keyword">class</span>. <span class="title">Add</span> <span class="title">the</span> '<span class="title">static</span>' <span class="title">modifier</span> <span class="title">to</span> </span></span><br><span class="line"><span class="class">	 <span class="title">this</span> <span class="title">method</span> <span class="title">to</span> <span class="title">avoid</span> <span class="title">these</span> <span class="title">container</span> <span class="title">lifecycle</span> <span class="title">issues</span></span>; see <span class="meta">@Bean</span> javadoc <span class="keyword">for</span> complete details.</span><br><span class="line">MyBeanFactoryPostProcessor init...</span><br><span class="line">...</span><br><span class="line">son init...hashCode() = <span class="number">882706486</span></span><br><span class="line">Parent init...</span><br></pre></td></tr></table></figure>
<p>结果分析（问题点/冲突点）：</p>
<ol>
<li>AppConfig提前于<code>MyBeanFactoryPostProcessor</code>初始化</li>
<li><code>@Autowired/@PostConstruct</code>等注解没有生效，<strong>这个问题很大</strong></li>
</ol>
<blockquote>
<p>需要强调的是：此时的AppConfig是被enhance增强成功了的，这样才有可能进入到<code>BeanMethodInterceptor</code>拦截里面，才有可能输出这句日志（该拦截器会拦截Full模式配置列的所有的@Bean方法的执行）</p>
</blockquote>
<p>这句日志由<code>ConfigurationClassEnhancer.BeanMethodInterceptor</code>输出，含义为：你的@Bean标注的方法是非static的并且返回了一个<code>BeanFactoryPostProcessor</code>类型的实例，这就导致了<strong>配置类</strong>里面的<code>@Autowired, @Resource,@PostConstruct</code>等注解都将得不到解析，这是比较危险的（所以其实这个日志调整为warn级别也是阔仪的）。</p>
<blockquote>
<p>小细节：为毛日志看起来是ConfigurationClassEnhancer这个类输出的呢？这是因为<code>BeanMethodInterceptor</code>是它的静态内部类，和它<strong>共用的</strong>一个logger</p>
</blockquote>
<p>源码处解释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConfigurationClassEnhancer.BeanMethodInterceptor：</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (isCurrentlyInvokedFactoryMethod(beanMethod)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isInfoEnabled() &amp;&amp; BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">beanMethod</span>.<span class="title">getReturnType</span>())) </span>&#123;</span><br><span class="line">			logger.info(String.format(<span class="string">"@Bean method %s.%s is non-static and returns an object "</span> +</span><br><span class="line">							<span class="string">"assignable to Spring's BeanFactoryPostProcessor interface. This will "</span> +</span><br><span class="line">							<span class="string">"result in a failure to process annotations such as @Autowired, "</span> +</span><br><span class="line">							<span class="string">"@Resource and @PostConstruct within the method's declaring "</span> +</span><br><span class="line">							<span class="string">"@Configuration class. Add the 'static' modifier to this method to avoid "</span> +</span><br><span class="line">							<span class="string">"these container lifecycle issues; see @Bean javadoc for complete details."</span>,</span><br><span class="line">					beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>解释为：如果当前正在执行的@Bean方法（铁定不是static，因为静态方法它也拦截不到嘛）返回类型是<code>BeanFactoryPostProcessor</code>类型，那就输出此警告日志来提醒使用者要当心。</p>
<hr>
<h3 id="解决方案：static关键字提升优先级-2"><a href="#解决方案：static关键字提升优先级-2" class="headerlink" title="解决方案：static关键字提升优先级"></a>解决方案：static关键字提升优先级</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AppConfig：</span><br><span class="line"></span><br><span class="line"><span class="comment">//@Bean</span></span><br><span class="line"><span class="comment">//BeanFactoryPostProcessor postProcessor() &#123;</span></span><br><span class="line"><span class="comment">//    return new MyBeanFactoryPostProcessor();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BeanFactoryPostProcessor <span class="title">postProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyBeanFactoryPostProcessor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，结果输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyBeanFactoryPostProcessor init...</span><br><span class="line">AppConfig init...</span><br><span class="line">son init...hashCode() = <span class="number">1906549136</span></span><br><span class="line">Parent init...</span><br><span class="line"><span class="comment">// @PostConstruct注解生效喽</span></span><br><span class="line">AppConfig.parent = com.yourbatman.bean.Parent<span class="meta">@baf</span>1bb3</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>世界一下子又清爽了有木有。</p>
<hr>
<h2 id="原因总结"><a href="#原因总结" class="headerlink" title="原因总结"></a>原因总结</h2><p>以上三个case是有共同点的，粗略的讲导致它们的原因甚至是同一个：<strong>AppConfig这个Bean被过早初始化</strong>。然而我们的解决方案似乎也是同一个：<strong>使用static提升Bean的优先级</strong>。</p>
<p>那么为何AppConfig会被提前初始化呢？为何使用static关键字就没有问题了呢？根本原因可提前剧透：static静态方法属于类，执行静态方法时并不需要初始化所在类的实例；而实例方法属于实例，执行它时必须先初始化所在类的实例。听起来是不是非常的简单，JavaSE的东西嘛，当然只知晓到这个层次肯定是远远不够的，限于篇幅原因，关于Spring是如何处理的<strong>源码级别的分析</strong>我放在了下篇文章，请别走开哟~</p>
<hr>
<h2 id="static静态方法一定优先执行吗？"><a href="#static静态方法一定优先执行吗？" class="headerlink" title="static静态方法一定优先执行吗？"></a>static静态方法一定优先执行吗？</h2><p>看完本文，有些小伙伴就忍不住跃跃欲试了，甚至很武断的得出结论：<strong>static标注的@Bean方法优先级更高</strong>，其实这是错误的，比如你看如下示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppConfig2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AppConfig2()&#123;</span><br><span class="line">        System.out.println(<span class="string">"AppConfig2 init..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Son <span class="title">son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Son();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Daughter <span class="title">daughter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Daughter();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Parent <span class="title">Parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Parent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，结果输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AppConfig2 init...</span><br><span class="line">son init...</span><br><span class="line">Daughter init...</span><br><span class="line">Parent init...</span><br></pre></td></tr></table></figure>
<p>这时候你想让Parent在Son之前初始化，因此你想着在用static关键字来提升优先级，这么做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AppConfig2：</span><br><span class="line"></span><br><span class="line"><span class="comment">//@Bean</span></span><br><span class="line"><span class="comment">//Parent Parent() &#123;</span></span><br><span class="line"><span class="comment">//    return new Parent();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Parent <span class="title">Parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Parent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：你徒劳了，static貌似并没有生效，怎么回事？</p>
<hr>
<h3 id="原因浅析"><a href="#原因浅析" class="headerlink" title="原因浅析"></a>原因浅析</h3><p>为了满足你的好奇心，这里给个浅析，道出关键因素。我们知道@Bean方法（不管是静态方法还是实例方法）最终都会被封装进<code>ConfigurationClass</code>实例里面，使用<code>Set&lt;BeanMethod&gt; beanMethods</code>存储着，关键点在于它是个<code>LinkedHashSet</code>所以是有序的（存放顺序），而存入的顺序底层是由<code>clazz.getDeclaredMethods()</code>来决定的，由此可知@Bean方法执行顺序<strong>和有无static没有半毛钱关系</strong>。<br><img data-src="https://img-blog.csdnimg.cn/20200531093341371.png#x70" alt=""></p>
<blockquote>
<p>说明：<code>clazz.getDeclaredMethods()</code>得到的是Method[]数组，是有序的。这个顺序由字节码（定义顺序）来保证：先定义，先服务。</p>
</blockquote>
<p>由此可见，static并不是<strong>真正意义</strong>上的提高Bean优先级，对于如上你的需求case，你可以使用<code>@DependsOn</code>注解来保证，它也是和Bean顺序息息相关的一个注解，在本专栏后续文章中将会详细讲到。</p>
<p>所以关于@Bean方法的执行顺序的正确结论应该是：在<strong>同一配置类</strong>内，在无其它“干扰”情况下（无<code>@DependsOn、@Lazy等注解</code>），@Bean方法的执行顺序遵从的是定义顺序（后置处理器类型除外）。</p>
<p>小提问：如果是垮@Configuration配置类的情况，顺序如何界定呢？那么这就不是同一层级的问题了，首先考虑的应该是@Configuration配置类的顺序问题，前面有文章提到过配置类是支持<strong>有限的</strong>的@Order注解排序的，具体分析请依旧保持关注A哥后续文章详解哈…</p>
<hr>
<h2 id="static关键字使用注意事项"><a href="#static关键字使用注意事项" class="headerlink" title="static关键字使用注意事项"></a>static关键字使用注意事项</h2><p>在同一个<code>@Configuration</code>配置类内，对static关键字的使用做出如下说明，供以参考：</p>
<ol>
<li>对于普通类型（非后置处理器类型）的@Bean方法，使用static关键字并不能改变顺序（按照方法定义顺序执行），所以别指望它</li>
<li>static关键字一般有且仅用于@Bean方法返回为<code>BeanPostProcessor</code>、<code>BeanFactoryPostProcessor</code>等类型的方法，并且建议此种方法<strong>请务必使用static修饰</strong>，否则容易导致隐患，埋雷</li>
</ol>
<p>static关键字不要滥用（其实任何关键字皆勿乱用），在同一配置类内，<strong>与其说它是提升了Bean的优先级，倒不如说它让@Bean方法静态化从而不再需要依赖所在类的实例即可独立运行</strong>。另外我们知道，static关键还可以修饰（内部）类，那么如果放在类上它又是什么表现呢？同样的，你先思考，下篇文章我们接着聊~</p>
<blockquote>
<p>说明：使用static修饰Class类在<strong>Spring Boot</strong>自动配置类里特别特别常见，所以掌握起来很具价值</p>
</blockquote>
<hr>
<h2 id="思考题："><a href="#思考题：" class="headerlink" title="思考题："></a>思考题：</h2><p>今天的思考题比较简单：为何文首三种case的警告信息都是info级别呢？是否有级别过低之嫌？</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文还是蛮干的哈，不出意外它能够帮你解决你工程中的某些问题，排除掉一些隐患，毕竟墨菲定律被验证了你担心的事它总会发生，防患于未然才能把自己置于安全高地嘛。</p>
<p>你可能诧异，A哥竟能把static关键字在Spring中的应用都能写出个专栏出来，是的，这不是就是本公众号的定位么 ，小而美和拒绝浅尝辄止嘛。对于一些知识（比如本文的static关键字的使用）我并不推崇强行记忆，因为那真的很容易忘，快速使用可以简单记记，但真想记得牢(甚至成为永久记忆)，那必须得去深水区看看。来吧，下文将授之以渔~</p>
<blockquote>
<p>很多小伙伴去强行记忆Spring Boot支持的那17种外部化配置，此时你应该问自己：现在你可能记得，一周以后呢？一个月以后呢？所以你需要另辟蹊径，那就持续关注我吧😄</p>
</blockquote>]]></content>
      <categories>
        <category>Spring static关键字</category>
      </categories>
      <tags>
        <tag>Spring Framework</tag>
        <tag>static</tag>
        <tag>@Bean</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring配置类深度剖析-总结篇(手绘流程图，可白嫖)</title>
    <url>/x2y/1db87a14.html</url>
    <content><![CDATA[<blockquote>
<p>当大潮退去，才知道谁在裸泳。<br><strong>作者</strong>：A哥（YourBatman）<br><strong>公众号</strong>：BAT的乌托邦（ID：BAT-utopia）<br><strong>文末是否有彩蛋</strong>：有</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>各位小伙伴大家好，我是A哥。最近写了好几篇关于Spring <code>@Configuration</code>的文章，收录在<strong>Spring配置类</strong>专栏里，这是本公众号的<strong>第一个</strong>专栏（虽然CSDN里已有几百篇）。虽然写的过程很艰难，但从评价反馈来看都是正向的，聊以安慰呗，比如这个小伙的“三宗最”让我听了很开心啊😄：<br><img data-src="https://img-blog.csdnimg.cn/20200523083520657.png#x130" alt=""><br>虽然每篇文章的阅读量堪忧，毕竟从第一篇文章我就对我自己的公众号定位了嘛：<strong>不求大量流行，只求小众共鸣</strong>。因为我知道愿意坚持看下去系列文章（强依赖于上下文）的小伙伴还是比较少的，但我相信一旦坚持下来我们的共同话题就多了，“臭味相投”嘛，是这样的吧~</p>
<p>在这之前，CSDN里写过几百篇关于Spring的文章，但是总感觉体系性不够，<strong>东打一炮，西放一枪</strong>难免会有失连贯性。我一直认为大多时候技术的相关性、上下文上很必要的，仅靠一篇文章想把一个成型的知识点讲清楚几乎没可能，所以那种容易成为<strong>快餐</strong>，过眼即忘。这不这次我选择在公众号里做些成系列的专题，在CSDN的基础上，<strong>抽取精华，去其糟粕</strong>，以自身能力尽量的做好每一个专栏，普惠于有需要的小伙伴。过程很枯燥和很乏味，愿意看下去的人也不会很多，能坚持下来或许会被自己感动😄。</p>
<p>作为<strong>第一个专栏</strong>的总结篇，一般的都是少文字多流程图，旨在起到一个总览的作用，也为方便快速应付面试~<br><img data-src="https://img-blog.csdnimg.cn/20200523134342508.jpg#x200" alt=""></p>
<hr>
<h2 id="版本约定"><a href="#版本约定" class="headerlink" title="版本约定"></a>版本约定</h2><p>本文内容若没做特殊说明，均基于以下版本：</p>
<ul>
<li>JDK：<code>1.8</code></li>
<li>Spring Framework：<code>5.2.2.RELEASE</code></li>
</ul>
<hr>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>本文以绘制流程图为主，特点是快，缺点是不详，辅以该专栏（关注公众号，进入该专栏。或点击顶部相关推荐直达）前几篇文章可以达到很好的效果。</p>
<hr>
<h2 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h2><ul>
<li><code>@Configuration</code>：标注在类上，表示该类是个Full模式的配置类<ul>
<li>自Spring 5.2.0版本后它加了个<code>proxyBeanMethods</code>属性来显示控制Full模式还是Lite模式，默认是true表示Full模式</li>
</ul>
</li>
<li><code>@Bean</code>：标注在方法上，表示方法生成一个由Spring容器管理的Bean</li>
<li></li>
<li><code>ConfigurationClassPostProcessor</code>：用于引导处理@Configuration配置类的后置处理器。注意：它只是引导处理，并不是实际处理</li>
<li><code>ConfigurationClassUtils</code>：内部工具类。用于判断组件是否是配置类，又或是Full模式/Lite模式，然后在bd元数据里打上标记<ul>
<li>它还会处理一件小事：获取@Configuration配置类上标注的@Order排序值并放进bd里</li>
</ul>
</li>
<li><code>BeanMethod</code>：内部使用的类。用于封装标注有@Bean注解的方法</li>
<li><code>ConfigurationClass</code>：内部使用的类。每一个@Configuration配置类都会被封装为它，内部会包含多个@Bean方法（BeanMethod）</li>
<li><code>ConfigurationClassParser</code>：解析@Configuration配置类，最终以ConfigurationClass对象的形式展示，并且填充它：因为一个配置类可以<code>@Import</code>导入另外一个（或者N多个）其它配置类，所以需要填充</li>
<li><code>ConfigurationClassBeanDefinitionReader</code>：内部使用的类。读取给定的已经解析好的<code>Set&lt;ConfigurationClass&gt;</code>集合，把里面的bd信息注册到<code>BeanDefinitionRegistry</code>里去（这里决定了bd的有序和无序相关问题）</li>
<li></li>
<li><code>ConfigurationClassEnhancer</code>：内部使用的类。配置类增强器，用于对@Configuration类（Full模式）使用CGLIB增强，生成一个代理子类字节码Class对象</li>
<li><code>EnhancedConfiguration</code>：被增强器增强过的配置类，都会自动的让实现此接口（实际是个<code>BeanFactoryAware</code>）接口</li>
<li><code>SpringNamingPolicy</code>：使用CGLIB生成字节码类名名称生成策略 -&gt; 名称中会有<code>BySpringCGLIB</code>字样</li>
<li><code>BeanFactoryAwareMethodInterceptor</code>：CGLIB代理对象拦截器。作用：拦截代理类的<code>setBeanFactory()</code>方法，给对应属性赋值</li>
<li><code>BeanMethodInterceptor</code>：CGLIB代理对象拦截器。作用：拦截所有@Bean方法的执行，以支持可以通过直接调用@Bean方法来管理依赖关系（当然也支持<code>FactoryBean</code>模式）</li>
</ul>
<hr>
<h2 id="配置类解析流程图"><a href="#配置类解析流程图" class="headerlink" title="配置类解析流程图"></a>配置类解析流程图</h2><p><strong>配置类的解析均是交由<code>ConfigurationClassPostProcessor</code>来引导</strong>。在Spring Framework里（非Spring Boot）里，它是<code>BeanDefinitionRegistryPostProcessor</code>处理器的<strong>唯一</strong>实现类，用于引导处理<code>@Configuration</code>配置类。解析入口是<code>postProcessBeanDefinitionRegistry()</code>方法，实际处理委托给了<code>processConfigBeanDefinitions()</code>方法。<br><img data-src="https://img-blog.csdnimg.cn/20200523101507366.png#x700" alt=""></p>
<hr>
<h2 id="配置类增强流程图"><a href="#配置类增强流程图" class="headerlink" title="配置类增强流程图"></a>配置类增强流程图</h2><p>如果一个配置类是Full模式，那么它就需要被CGLIB字节码提升。增强动作委托给<code>enhanceConfigurationClasses(beanFactory)</code>去完成。<br><img data-src="https://img-blog.csdnimg.cn/20200523103748156.png#x700" alt=""></p>
<p>以上是引导/调度的流程图，下面对字节码增强、实际拦截实现流程进行细分描述。</p>
<hr>
<h2 id="生成增强子类字节码流程图"><a href="#生成增强子类字节码流程图" class="headerlink" title="生成增强子类字节码流程图"></a>生成增强子类字节码流程图</h2><p>针对于Full模式配置类的字节码生成，委托给<code>ConfigurationClassEnhancer</code>增强器去完成，最终得到一个CGLIB提升过的子类Class<strong>字节码对象</strong>。<br><img data-src="https://img-blog.csdnimg.cn/20200523105718734.png#x700" alt=""><br>字节码实际是由Enhancer生成，就不用再深入了，那属于CGLIB（甚至ASM）的范畴，很容易头晕，也并无必要。</p>
<hr>
<h2 id="拦截器执行流程图"><a href="#拦截器执行流程图" class="headerlink" title="拦截器执行流程图"></a>拦截器执行流程图</h2><p>拦截器是完成增强<strong>实际逻辑</strong>的核心部件，因此它的执行流程<strong>需要引起重视</strong>。一共有两个“有用”的拦截器，分别画出。</p>
<hr>
<h3 id="BeanFactoryAwareMethodInterceptor拦截流程图"><a href="#BeanFactoryAwareMethodInterceptor拦截流程图" class="headerlink" title="BeanFactoryAwareMethodInterceptor拦截流程图"></a>BeanFactoryAwareMethodInterceptor拦截流程图</h3><p>拦截<code>setBeanFactory()</code>方法的执行<br><img data-src="https://img-blog.csdnimg.cn/20200523112931198.png#x700" alt=""></p>
<hr>
<h3 id="BeanMethodInterceptor拦截流程图"><a href="#BeanMethodInterceptor拦截流程图" class="headerlink" title="BeanMethodInterceptor拦截流程图"></a>BeanMethodInterceptor拦截流程图</h3><p>拦截<code>@Bean</code>方法的执行<br><img data-src="https://img-blog.csdnimg.cn/20200523110819118.png#x700" alt=""></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文作为公众号首个专栏<strong>Spring配置类</strong>的总结篇，主要是对核心处理流程画图阐述，<strong>适合需要快速理解的白嫖党</strong>，毕竟面试最喜欢问的就是让你说说执行流程之类的，因此实用性还是蛮高的，以后的专栏均会仿造此套路来玩。</p>
<p>关于<strong>Spring配置类</strong>这个专栏到这就全部结束了，在此也多谢各位在这期间给我的反馈，让我确定以及肯定了这么坚持下去是有意义的，是被支持的，是能够帮助到同仁们的。我公众号定位为专栏式学习，拒绝浅尝遏止，诚邀你的关注，一起进步。</p>
<blockquote>
<p>Tips：有小伙伴私信我说有没有入门级别的？答案是没有的。主要是觉得入门级文章网上太多了，趋同性很强，所以我这一般会篇进阶,有点工作经验/基础再看效果更佳</p>
</blockquote>]]></content>
      <categories>
        <category>Spring配置类</category>
      </categories>
      <tags>
        <tag>Spring Framework</tag>
        <tag>@Configuration</tag>
        <tag>总结篇</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 2.3.0正式发布：优雅停机、配置文件位置通配符新特性一览</title>
    <url>/x2y/84b12bae.html</url>
    <content><![CDATA[<blockquote>
<p>当大潮退去，才知道谁在裸泳。<br><strong>作者</strong>：A哥（YourBatman）<br><strong>公众号</strong>：BAT的乌托邦（ID：BAT-utopia）<br><strong>文末是否有彩蛋</strong>：有</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>各位小伙伴大家好，我是A哥。北京时间2020-05-15，Spring Boot 2.3.0版本正式发布了，次版本号的升级，一般会有些新特性出来。作为Java Coder的我们有必要一览它的新new Feature，keep下技术节奏嘛。</p>
<p>A哥“第二时间”知道了这个消息，然后在自己本机（请注意：非生产环境）体验了一把，然后再结合Spring Boot官方的<a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.3-Release-Notes" target="_blank" rel="noopener">Release Notes</a>，在这里给你絮叨絮叨。</p>
<hr>
<h2 id="关于版本号"><a href="#关于版本号" class="headerlink" title="关于版本号"></a>关于版本号</h2><p>Spring Boot代码库的版本好采用“国际通用”（我自己yy的）的命名方式：<strong>主版本号.次版本号.修订号</strong>，所以通过版本号就能感受到它的变化到底大不大，你升级时是否需要倍加注意等等。那么此处我就对这种命名方式版本号的各段进行科普一波：</p>
<ul>
<li><strong>主版本号</strong>：完全不兼容。产品定位变化、核心API大规模不兼容（比如包名变了）、架构方式升级不能向下兼容……<ul>
<li>举例：Configuration1.x -&gt; 2.x；Zuul1.x -&gt; 2.x；Spring Boot1.x -&gt; 2.x；Netty4.x -&gt; 5.x</li>
</ul>
</li>
<li><strong>次版本号</strong>：相对兼容。一般是增加新特新，删除掉废弃的API，修改某些API不兼容。总的来说是影响比较小，在可控范围内的，但升级时不可掉以轻心，<strong>必须</strong>做前期调研</li>
<li><strong>修订号</strong>：100%兼容。一般是修复bug、新增无伤大雅的一些特性等，一般想升就升</li>
</ul>
<p>这次Spring Boot升级到2.3.0版本，属于<strong>次版本号</strong>的升级，因此会带有些新特性，还是值得一看的。<br><img data-src="https://img-blog.csdnimg.cn/20200523202933979.png#x200" alt=""></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>Spring Boot v2.2依然是<strong>活跃的</strong>维护的版本，Spring Boot遵循的是<code>Pivotal OSS</code>支持策略，从发布日期起支持主要版本<strong>3年</strong>。但是呢，一般来说在主要/次要版本发布时，将会对上个主要版本至少提供12个月的支持（即使超过了3年），以解决关键的bug或者安全问题。</p>
<p>关于其它版本的维护活跃状态和已经EOL的日期，做出如下说明：</p>
<ul>
<li><code>2.2.x</code>：<strong>支持的版本</strong>。2019.10发布，是现在的活跃的主干</li>
<li><code>2.1.x</code>：<strong>支持的版本</strong>。2018.10发布，会支持到2020.10月底</li>
<li><code>2.0.x</code>：生命已终止的版本。2018.3发布，2019.4.3停止维护</li>
<li><code>1.5.x</code>：生命已终止的版本。2017.1发布，是最后一个1.x分支，2019.8.1停止维护</li>
</ul>
<p>从官网页面也可以看出，只有支持的版本才会被列出来，对使用者是有一定的引导作用的：<br><img data-src="https://img-blog.csdnimg.cn/20200523204026164.png#x200" alt=""></p>
<hr>
<h2 id="简单回忆2-2版本的新特性"><a href="#简单回忆2-2版本的新特性" class="headerlink" title="简单回忆2.2版本的新特性"></a>简单回忆2.2版本的新特性</h2><p>很明显，Spring Boot2.2版本不是本文关心的重点，但为了起到衔接作用，本处把它的核心新特性列一下：</p>
<ol>
<li>Spring Framework 5.2：重大升级，可以看到它为Cloud Native的努力</li>
<li>JUnit 5：从此版本开始，<code>spring-boot-starter-test</code>默认使用<code>JUnit 5</code>作为单元测试框架</li>
<li>支持Java13</li>
<li><strong>性能提升</strong>：表现在对所有的自动配置类改为了<code>@Configuration</code>的Lite模式，提升性能。</li>
<li>新增<code>@ConfigurationPropertiesScan</code>注解，自动扫描<code>@ConfigurationProperties</code>配置类</li>
<li>支持RSocket </li>
</ol>
<p>下面我们来了解下本次升级（2.3.0版本）的新特性，分为主要新特性和其它新特性分开阐述。</p>
<hr>
<h2 id="主要新特性"><a href="#主要新特性" class="headerlink" title="主要新特性"></a>主要新特性</h2><h3 id="优雅停机"><a href="#优雅停机" class="headerlink" title="优雅停机"></a>优雅停机</h3><p><strong>这个新特性深入人心</strong>，是开发者、运维的福音啊。据我了解，很多中小型公司/团队都是使用<code>kill -9</code>（当然有些比较“温柔”的团队也用<code>kill -2</code>）来停服的，这样暴力“停机”很容易造成业务逻辑执行失败，导致在一些业务场景下出现数据不一致现象。虽然我们可以通过一些手段（自研）来避免这个问题，但并不是每个公司/团队都去做了。这不Spring Boot2.3.0版本就内置了这个功能：<strong>优雅停机</strong>。</p>
<blockquote>
<p>小知识：kill -2类似于你的Ctrl + C，会触发shutDownHook事件（从而关闭Spring容器）；kill -9就没啥好说的，杀杀杀</p>
</blockquote>
<p>SB所有四个嵌入式web服务器(Jetty、Reactor Netty、Tomcat和Undertow)以及响应性和基于servlet的web应用<strong>都支持优雅的关闭</strong>。在关闭时，web服务器将<strong>不再允许</strong>新的请求，并将等待完成的请求给个宽限期让它完成。当然这个宽限期是可以设置的：可以使用<code>spring.lifecycle.timeout-per-shutdown-phase=xxx</code>来配置，默认值是30s。</p>
<p><strong>注意，注意，注意</strong>：默认情况下，优雅关机并<code>没有开启</code>（还是立即关机），你仅需添加<code>server.shutdown=graceful</code>配置即可开启优雅关机（取值参见2.3.0新增的Shutdown枚举类，默认值参见<code>AbstractConfigurableWebServerFactory.shutdown</code>属性值）。</p>
<hr>
<h3 id="配置属性的调整"><a href="#配置属性的调整" class="headerlink" title="配置属性的调整"></a>配置属性的调整</h3><p>这个版本中，一些配置属性已<strong>被重命名或弃用</strong>（这会导致不向下兼容，需要特别引起注意），需要你做出调整。</p>
<p>那么如何知道我现在用的哪些属性存在不兼容情况呢？？？官方给了一个很好的解决方案，这里我用个使用示例教你可以这么处理：</p>
<p>现状：在Spring Boot2.2.x环境中你有很多配置，痛点是不知道哪些配置需要配替换成2.3.x中新的。此时你可以在工程下加入这个jar：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-properties-migrator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后<strong>升级你的Spring Boot版本号为2.3.0</strong>，重新启动工程。本处以你配置文件里的<code>spring.http.encoding.enabled=true</code>为例，由于使用了SB的最新版本，因此可以在控制台看到如下日志输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Property source <span class="string">'applicationConfig: [classpath:/application.properties]'</span>:</span><br><span class="line">	Key: spring.http.encoding.enabled</span><br><span class="line">		Line: <span class="number">3</span></span><br><span class="line">		Replacement: server.servlet.encoding.enabled</span><br></pre></td></tr></table></figure>
<p><img data-src="https://img-blog.csdnimg.cn/20200523162357514.png#x120" alt=""><br>日志说够明确了吧。有了这个好帮手，妈妈就不用再担心辣么多的配置项需要自己一个个去核对喽，按照指示一个个的修改即可。</p>
<blockquote>
<p>官方说明：完成迁移后，请确保从项目的依赖项中删除<code>properties-migrator</code>这个模块。</p>
</blockquote>
<p>顺道说一下：升级到2.3.0版本号，属性变化主要是这个：<code>spring.http.</code> -&gt; <code>server.servlet.encoding.、spring.mvc.、spring.codec.</code></p>
<hr>
<h3 id="删除不推荐使用的类-方法-属性"><a href="#删除不推荐使用的类-方法-属性" class="headerlink" title="删除不推荐使用的类/方法/属性"></a>删除不推荐使用的类/方法/属性</h3><p>在该版本中，Spring Boot删除了2.2版本中<strong>不推荐使用</strong>的大多数类，方法和属性。请确保升级之前没有再调用不推荐使用的方法。针对于此，下面我举例那些在2.2版本中还“活着”但被弃用（标记有<code>@Deprecated</code>注解），但在2.3版本中已<strong>完全删除</strong>的类、方法、属性：</p>
<ol>
<li>方法BindResult#orElseCreate</li>
<li>属性LoggingApplicationListener#LOGFILE_BEAN_NAME</li>
<li>类JodaDateTimeJacksonConfiguration</li>
<li>类JestAutoConfiguration</li>
</ol>
<p>即使如此，有些虽然在2.2就已被弃用，但在2.3.0还存在的，如：<code>ConfigurationBeanFactoryMetadata、CompositeHealthIndicator</code></p>
<hr>
<h3 id="配置文件位置支持通配符"><a href="#配置文件位置支持通配符" class="headerlink" title="配置文件位置支持通配符"></a>配置文件位置支持通配符</h3><p>Spring Boot现在在加载配置文件时<strong>支持通配符位置</strong>。默认情况下，jar外部的<code>config/*/</code>位置是被支持的。当配置属性有<strong>多个源时</strong>，比如在<code>Kubernetes</code>这样的环境中非常有用。</p>
<blockquote>
<p>特点说明：jar包外，jar包外，jar包外，放在内部（比如resource目录下是没有此特针的），下面有示例证明</p>
</blockquote>
<p>简单的说，如果你有MySql的配置和Redis配置的话，你就可以把他们分开来放置，隔离性更好目录也更加清晰了：</p>
<ul>
<li>mysql：<code>/config/mysql/application.properties</code></li>
<li>redis：<code>/config/redis/application.properties</code></li>
</ul>
<p>工程目录如下截图：<br><img data-src="https://img-blog.csdnimg.cn/20200523212126237.png#x160" alt=""><br>运行程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ConfigurableApplicationContext context = SpringApplication.run(Boot23Demo1Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line"></span><br><span class="line">    ConfigurableEnvironment environment = context.getEnvironment();</span><br><span class="line">    System.out.println(environment.getProperty(<span class="string">"mysql.name"</span>));</span><br><span class="line">    System.out.println(environment.getProperty(<span class="string">"redis.name"</span>));</span><br><span class="line"></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql</span><br><span class="line">redis</span><br></pre></td></tr></table></figure>

<p>但如果你把文件放在jar包内，形如这样，是<strong>没有效果的</strong>：<br><img data-src="https://img-blog.csdnimg.cn/20200523212434591.png#x200" alt=""><br>输出为null null，因此使用时需要稍加注意哈~</p>
<hr>
<h3 id="web下的日期转换支持配置"><a href="#web下的日期转换支持配置" class="headerlink" title="web下的日期转换支持配置"></a>web下的日期转换支持配置</h3><p>现在时间/日期的转换现在<strong>可以通过</strong>属性进行配置了，这补充了对格式化日期值的现有支持。比如对于MVC和WebFlux来说，它们的配置项分别如下：</p>
<ul>
<li>spring.mvc.format.date</li>
<li>spring.mvc.format.date-time</li>
<li>spring.mvc.format.time</li>
<li>spring.webflux.format.date</li>
<li>spring.webflux.format.date-time</li>
<li>spring.webflux.format.time</li>
</ul>
<p>这个怎么用，相信大家都会，一看就知道什么含义。但是，但是，但是：<strong>请一定做好充分测试</strong>，并且充分考虑兼容性，因为你这动的是接口层的东西~</p>
<hr>
<hr>
<h2 id="其它新特性"><a href="#其它新特性" class="headerlink" title="其它新特性"></a>其它新特性</h2><h3 id="更改某些依赖最低版本要求"><a href="#更改某些依赖最低版本要求" class="headerlink" title="更改某些依赖最低版本要求"></a>更改某些依赖最低版本要求</h3><p>主要体现在如下两处：</p>
<ol>
<li>如果你使用Gradle构建，支持<code>Gradle 6.3+</code>。当然喽<code>5.6.x</code>也支持，只是标记为@Deprecated不推荐使用了</li>
<li>如果你使用Jetty嵌入式容器，版本要求是<code>Jetty 9.4.22+</code></li>
</ol>
<hr>
<h3 id="核心依赖升级"><a href="#核心依赖升级" class="headerlink" title="核心依赖升级"></a>核心依赖升级</h3><p>Spring Boot 2.3迁移到几个Spring项目的新版本:</p>
<ul>
<li>Spring Data Neumann：你可以理解为它就是之前的Spirng Data工程的升级版</li>
<li>Spring HATEOAS 1.1</li>
<li>Spring Integration 5.3</li>
<li>Spring Kafka 2.5</li>
<li>Spring Security 5.3</li>
<li>Spring Session Dragonfruit</li>
</ul>
<p>Spring Boot 2.3的构建与Spring Boot 2.2基于 <strong>相同的</strong> Spring Framework和Reactor。</p>
<blockquote>
<p>说明：spirng-core么有升级，还是5.2.6版本（SB的2.2.7版本依赖的spring-core也是这个版本）</p>
</blockquote>
<hr>
<h3 id="三方库依赖升级"><a href="#三方库依赖升级" class="headerlink" title="三方库依赖升级"></a>三方库依赖升级</h3><ul>
<li>AssertJ 3.16</li>
<li>Cassandra Driver 4.6</li>
<li>Elasticsearch 7.6</li>
<li>Hibernate Validator 6.1</li>
<li>JUnit Jupiter 5.6</li>
<li>Kafka 2.5</li>
<li>Lettuce 5.3</li>
<li>Micrometer 1.5</li>
<li>MongoDB 4.0</li>
</ul>
<hr>
<h3 id="Spring-Data-Neumann升级带来的变化"><a href="#Spring-Data-Neumann升级带来的变化" class="headerlink" title="Spring Data Neumann升级带来的变化"></a>Spring Data Neumann升级带来的变化</h3><ul>
<li><code>Cassandra</code>：升级到v4版本，带来了一些变化，如<code>ClusterBuilderCustomizer</code>就木有了~</li>
<li><code>Couchbase</code>：升级到v3版本</li>
<li><code>Elasticsearch</code>：已废弃的原生Elasticsearch transport直接被删除了，并且还移除了对Jest的支持。从此版本开始，默认支持<code>Elasticsearch7.5+</code></li>
<li><code>MongoDB</code>：升级到v4版本</li>
</ul>
<hr>
<h3 id="关于Validation"><a href="#关于Validation" class="headerlink" title="关于Validation"></a>关于Validation</h3><p>从此版本开始，<code>spring-boot-starter-web</code>不会再把validation带进来，所以若使用到，你需要自己添加这个<code>spring-boot-starter-validation</code>依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>关于<code>spring-boot-starter-web</code>启动器新、老版本的区别截图：<br><img data-src="https://img-blog.csdnimg.cn/20200523185845525.png#x120" alt=""><br><img data-src="https://img-blog.csdnimg.cn/20200523190109536.png#x120" alt=""></p>
<hr>
<h3 id="移除一些maven插件"><a href="#移除一些maven插件" class="headerlink" title="移除一些maven插件"></a>移除一些maven插件</h3><p>移除了对<code>exec-maven-plugin</code>和<code>maven-site-plugin</code>这两个插件的管理，所以如果你的工程依赖于这两个插件，那么你得显示的导入（指定版本号）。</p>
<hr>
<h3 id="支持Java14"><a href="#支持Java14" class="headerlink" title="支持Java14"></a>支持Java14</h3><p>Spring Boot 2.3增加了对Java 14的支持。当然Java 8和Java 11也还是被支持的。</p>
<hr>
<h3 id="Docker支持"><a href="#Docker支持" class="headerlink" title="Docker支持"></a>Docker支持</h3><p>在Maven和Gradle插件中添加了对构建包含分层内容的jar文件的支持。分层根据<strong>jar内容的更改频率</strong>来分隔它们。这种分离允许更有效地构建Docker映像。未更改的现有层可以与已更改的层一起放在顶部进行重用。</p>
<p>根据您的应用程序，您可能需要调整层的创建方式并添加新层。这可以通过描述如何将jar分成层以及这些层的顺序的配置来完成。</p>
<hr>
<h3 id="Fat-Jar支持优化"><a href="#Fat-Jar支持优化" class="headerlink" title="Fat Jar支持优化"></a>Fat Jar支持优化</h3><p>用Maven和Gradle构建的Fat jar现在包括一个<strong>索引文件</strong>。当jar被分解时，这个索引文件用于确保类路径的顺序与直接执行jar时相同。</p>
<hr>
<h3 id="嵌入式Servlet-Web-Server线程配置"><a href="#嵌入式Servlet-Web-Server线程配置" class="headerlink" title="嵌入式Servlet Web Server线程配置"></a>嵌入式Servlet Web Server线程配置</h3><p>用于配置嵌入式Servlet web服务器使用的线程的配置属性（包括Jetty, Tomcat, 和Undertow）别移动到了专注于threads的组：<code>erver.jetty.threads</code>，<code>server.tomcat.threads</code>，<code>server.undertow.threads</code>。当然喽，旧的配置属性目前<strong>依然保留着</strong>，但被标记为<code>@Deprecated</code>不再推荐使用了~<br><img data-src="https://img-blog.csdnimg.cn/20200523191327508.png#x60" alt=""></p>
<hr>
<h3 id="WebFlux基础路径配置"><a href="#WebFlux基础路径配置" class="headerlink" title="WebFlux基础路径配置"></a>WebFlux基础路径配置</h3><p>现在可以配置WebFlux应用程序的所有web处理程序的基本路径。使用<code>pring.webflux.base-path = xxx</code>配置。</p>
<hr>
<h3 id="活性探测器"><a href="#活性探测器" class="headerlink" title="活性探测器"></a>活性探测器</h3><p>Spring Boot现在内置了关于应用程序可用性的探测的能力，可以<strong>跟踪应用程序是否处于活动状态</strong>以及是否准备好处理流量。如果你配置了<code>management.health.probes.enabled=true</code>，那么健康检查端点就可以查看你应用的活性和就绪列表，这在在Kubernetes上运行时，这是自动完成的。<br><img data-src="https://img-blog.csdnimg.cn/2020052321424955.png#x180" alt=""></p>
<hr>
<h3 id="Actuator增强"><a href="#Actuator增强" class="headerlink" title="Actuator增强"></a>Actuator增强</h3><p>主要是对端点做了些输出、显示上的优化。如：</p>
<ul>
<li><code>/actuator/metrics/</code>：按字母顺序排列，这样你找起来就更方便了</li>
<li>DataSource的<code>HealthIndicator</code>健康指示器，现在进行无查询判断，而<code>Connection</code>仅做连接可用性验证而已</li>
<li>…</li>
</ul>
<hr>
<hr>
<h1 id="好基友Spring-Cloud什么时候跟上？"><a href="#好基友Spring-Cloud什么时候跟上？" class="headerlink" title="好基友Spring Cloud什么时候跟上？"></a>好基友Spring Cloud什么时候跟上？</h1><p>作为Spring Boot的好基友，按照以往的惯例，他俩的步调不一般都保持基本一致。戒指到当前，Spring Cloud的最新版本是<code>Hoxton SR4</code>，那它是否支持最新的Spring Boot2.3.0呢？？？答案是：<strong>不支持，不支持，不支持</strong>。对于Spring Boot这种跨版本升级，一般是有阻断性变化，所以它的机油SC适配上还需要时间。</p>
<p>这不，官方就公布了Spring Cloud支持<code>Spring Boot 2.3.x</code>的里程碑时间点，也就是它的<code>Hoxton.SR5</code>版本发布时间点：<br><img data-src="https://img-blog.csdnimg.cn/20200523215452630.png#x300" alt=""><br>Spring Cloud里程碑地址：<a href="https://github.com/spring-cloud/spring-cloud-release/milestones" target="_blank" rel="noopener">https://github.com/spring-cloud/spring-cloud-release/milestones</a></p>
<hr>
<h1 id="升级建议：等等"><a href="#升级建议：等等" class="headerlink" title="升级建议：等等"></a>升级建议：等等</h1><p>至少要等到2020-5-26号发布后嘛，至少要等到Spring Boot2.3.x跑一段时间之后嘛，<strong>坐在第二排看戏</strong>，才是最舒服最稳妥的。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这是A哥奉给大家的，对Spring Boot2.3.0版本新特性的介绍，希望对你有些帮助。有些人可能会这么说：反正我现在也不用这个版本，没有必要去了解它。其实非也，如果你2.3.0不去了解，2.4.0不去了解，倘若某一天你突然要从2.0.0版本过度过来使用2.5.x版本了，你会“浑身不舒服”的。你品下，是不是这么个道理呢？</p>]]></content>
      <categories>
        <category>新特性</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>优雅停机</tag>
      </tags>
  </entry>
  <entry>
    <title>521我发誓读完本文，再也不会担心Spring配置类问题了</title>
    <url>/x2y/f3b61b38.html</url>
    <content><![CDATA[<blockquote>
<p>当大潮退去，才知道谁在裸泳。<br><strong>作者</strong>：A哥（YourBatman）<br><strong>公众号</strong>：BAT的乌托邦（ID：BAT-utopia）<br><strong>文末是否有彩蛋</strong>：有</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>各位小伙伴大家好，我是A哥。本文对Spring <code>@Configuration</code>配置类继续进阶，虽然有点烧脑，但目的只有一个：为拿高薪备好弹药。如果说上篇文章已经脑力有点“不适”了，那这里得先给你个下马威：本篇文章内容将更加的让你“感觉不适”。</p>
<blockquote>
<p>读本文之前，为确保连贯性，建议你移步先阅读上篇文章内容，直达电梯：<a href="https://mp.weixin.qq.com/s/qKenyoydYm4q2yPnGSdMZw" target="_blank" rel="noopener">你自我介绍说很懂Spring配置类，那你怎么解释这个现象？</a></p>
</blockquote>
<p>为什么有些时候我会建议先阅读上篇文章，这确实是无奈之举。技术的内容一般都具有很强相关性，它是需要有Context上下文支撑的，<strong>所以花几分钟先了解相关内容效果更佳</strong>，磨刀不误砍柴工的道理大家都懂。同时呢，这也是写深度分析类的技术文章的尴尬之处：吃力反而不讨好，需要坚持。<br><img data-src="https://img-blog.csdnimg.cn/202005200813015.png#x200" alt=""></p>
<hr>
<h2 id="版本约定"><a href="#版本约定" class="headerlink" title="版本约定"></a>版本约定</h2><p>本文内容若没做特殊说明，均基于以下版本：</p>
<ul>
<li>JDK：<code>1.8</code></li>
<li>Spring Framework：<code>5.2.2.RELEASE</code></li>
</ul>
<hr>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><a href="https://mp.weixin.qq.com/s/qKenyoydYm4q2yPnGSdMZw" target="_blank" rel="noopener">上篇文章</a>介绍了代理对象两个拦截器其中的前者，即<code>BeanFactoryAwareMethodInterceptor</code>，它会拦截<code>setBeanFactory()</code>方法从而完成给代理类指定属性赋值。通过第一个拦截器的讲解，你能够成功“忽悠”很多面试官了，但仍旧不能够解释我们最常使用中的这个疑惑：<strong>为何通过调用@Bean方法最终指向的仍旧是同一个Bean呢？</strong></p>
<p>带着这个疑问，开始本文的陈诉。请系好安全带，准备发车了…<br><img data-src="https://img-blog.csdnimg.cn/20200520082130796.png#x200" alt=""></p>
<hr>
<h2 id="Spring配置类的使用误区"><a href="#Spring配置类的使用误区" class="headerlink" title="Spring配置类的使用误区"></a>Spring配置类的使用误区</h2><p>根据不同的配置方式，展示不同情况。从Lite模式的使用<strong>产生误区</strong>，到使用Full模式解决问题，最后引出解释为何有此效果的原因分析/源码解析。</p>
<hr>
<h3 id="Lite模式：错误姿势"><a href="#Lite模式：错误姿势" class="headerlink" title="Lite模式：错误姿势"></a>Lite模式：错误姿势</h3><p>配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Son <span class="title">son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        System.out.println(<span class="string">"son created..."</span> + son.hashCode());</span><br><span class="line">        <span class="keyword">return</span> son;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Parent <span class="title">parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Son son = son();</span><br><span class="line">        System.out.println(<span class="string">"parent created...持有的Son是："</span> + son.hashCode());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Parent(son);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    AppConfig appConfig = context.getBean(AppConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(appConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bean情况</span></span><br><span class="line">    Son son = context.getBean(Son<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    Parent parent = context.getBean(Parent<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"容器内的Son实例："</span> + son.hashCode());</span><br><span class="line">    System.out.println(<span class="string">"容器内Person持有的Son实例："</span> + parent.getSon().hashCode());</span><br><span class="line">    System.out.println(parent.getSon() == son);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">son created...<span class="number">624271064</span></span><br><span class="line">son created...<span class="number">564742142</span></span><br><span class="line">parent created...持有的Son是：<span class="number">564742142</span></span><br><span class="line">com.yourbatman.fullliteconfig.config.AppConfig@<span class="number">1</span>a38c59b</span><br><span class="line">容器内的Son实例：<span class="number">624271064</span></span><br><span class="line">容器内Person持有的Son实例：<span class="number">564742142</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<p>结果分析：</p>
<ul>
<li>Son实例被<strong>创建了2次</strong>。很明显这两个<strong>不是同一个</strong>实例<ul>
<li>第一次是由Spring创建并放进容器里（<code>624271064</code>这个）</li>
<li>第二次是由构造parent时创建，只放进了parent里，并没放进容器里（<code>564742142</code>这个）</li>
</ul>
</li>
</ul>
<p>这样的话，<strong>就出问题了</strong>。问题表现在这两个方面：</p>
<ol>
<li>Son对象被创建了两次，<strong>单例模式被打破</strong></li>
<li>对Parent实例而言，它依赖的Son不再是IoC容器内的那个Bean，而是一个非常普通的POJO对象而已。所以这个Son对象将不会享有Spring带来的任何“好处”，这在实际场景中一般都是会有问题的</li>
</ol>
<p>这种情况在生产上是<strong>一定需要避免</strong>，那怎么破呢？下面给出Lite模式下使用的正确姿势。</p>
<hr>
<h3 id="Lite模式：正确姿势"><a href="#Lite模式：正确姿势" class="headerlink" title="Lite模式：正确姿势"></a>Lite模式：正确姿势</h3><p>其实这个问题，现在这么智能的IDE（如IDEA）已经能教你怎么做了：<br><img data-src="https://img-blog.csdnimg.cn/20200517162902739.png#x80" alt=""><br>按照“指示”，可以使用<strong>依赖注入</strong>的方式代替从而避免这种问题，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Bean</span></span><br><span class="line"><span class="comment">// public Parent parent() &#123;</span></span><br><span class="line"><span class="comment">//     Son son = son();</span></span><br><span class="line"><span class="comment">//     System.out.println("parent created...持有的Son是：" + son.hashCode());</span></span><br><span class="line"><span class="comment">//     return new Parent(son);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Parent <span class="title">parent</span><span class="params">(Son son)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"parent created...持有的Son是："</span> + son.hashCode());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Parent(son);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次运行程序，结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">son created...<span class="number">624271064</span></span><br><span class="line">parent created...持有的Son是：<span class="number">624271064</span></span><br><span class="line">com.yourbatman.fullliteconfig.config.AppConfig@<span class="number">667</span>a738</span><br><span class="line">容器内的Son实例：<span class="number">624271064</span></span><br><span class="line">容器内Person持有的Son实例：<span class="number">624271064</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p>bingo，<strong>完美解决了问题</strong>。如果你坚持使用Lite模式，那么请注意它的优缺点哦（Full模式和Lite模式的优缺点见<a href="https://mp.weixin.qq.com/s/rXy9T3VgWvdl6Kje1mwCZA" target="_blank" rel="noopener">这篇文章</a>）。</p>
<p>没有仔细看的同学可能会问：我明明就是按照第一种方式写的，也正常work没问题呀。说你是不细心吧还真是，不信你再回去瞅瞅对比对比。如果你用第一种方式并且能够“正常work”，那请你查查类头上是不是标注有<code>@Configuration</code>注解？<br><img data-src="https://img-blog.csdnimg.cn/20200520104347207.png#x200" alt=""></p>
<hr>
<h3 id="Full模式："><a href="#Full模式：" class="headerlink" title="Full模式："></a>Full模式：</h3><p>Full模式是容错性最强的一种方式，你乱造都行，没啥顾虑。</p>
<blockquote>
<p>当然喽，方法不能是private/final。但一般情况下谁会在配置里final掉一个方法呢？你说对吧~</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Son <span class="title">son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        System.out.println(<span class="string">"son created..."</span> + son.hashCode());</span><br><span class="line">        <span class="keyword">return</span> son;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Parent <span class="title">parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Son son = son();</span><br><span class="line">        System.out.println(<span class="string">"parent created...持有的Son是："</span> + son.hashCode());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Parent(son);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，结果输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">son created...<span class="number">1797712197</span></span><br><span class="line">parent created...持有的Son是：<span class="number">1797712197</span></span><br><span class="line">com.yourbatman.fullliteconfig.config.AppConfig$$EnhancerBySpringCGLIB$$<span class="number">8</span>ef51461<span class="meta">@be</span>64738</span><br><span class="line">容器内的Son实例：<span class="number">1797712197</span></span><br><span class="line">容器内Person持有的Son实例：<span class="number">1797712197</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p><strong>结果是完美的</strong>。它能够保证你通过调用标注有@Bean的方法得到的是IoC容器里面的实例对象，而非重新创建一个。相比较于Lite模式，它还有另外一个区别：它会为配置类生成一个<code>CGLIB</code>的代理子类对象放进容器，而Lite模式放进容器的是原生对象。</p>
<p><strong>凡事皆有代价，一切皆在取舍</strong>。原生的才是效率最高的，是对Cloud Native最为友好的方式。但在实际“推荐使用”上，<strong>业务端开发一般只会使用Full模式</strong>，毕竟业务开发的同学水平是残参差不齐的，容错性就显得至关重要了。</p>
<blockquote>
<p>如果你是容器开发者、中间件开发者…推荐使用Lite模式配置，为容器化、Cloud Native做好准备嘛~</p>
</blockquote>
<p>Full模式既然是面向使用侧为常用的方式，那么接下来就趴一趴Spring到底是施了什么“魔法”，让调用@Bean方法竟然可以不进入方法体内而指向同一个实例。</p>
<hr>
<hr>
<h2 id="BeanMethodInterceptor拦截器"><a href="#BeanMethodInterceptor拦截器" class="headerlink" title="BeanMethodInterceptor拦截器"></a>BeanMethodInterceptor拦截器</h2><p>终于到了今天的主菜。关于前面的流程分析本文就一步跳过，单刀直入分析<code>BeanMethodInterceptor</code>这个拦截器，也也就是所谓的两个拦截器的<strong>后者</strong>。</p>
<blockquote>
<p>温馨提示：亲务必确保已经了解过了上篇文章的流程分析哈，不然下面内容很容易造成你<code>脑力不适</code>的</p>
</blockquote>
<p>相较于上个拦截器，这个拦截器不可为不复杂。官方解释它的作用为：拦截任何标注有<code>@Bean</code>注解的方法的<strong>调用</strong>，以确保正确处理Bean语义，例如<strong>作用域</strong>（请别忽略它）和AOP代理。</p>
<p>复杂归复杂，但没啥好怕的，一步一步来呗。同样的，我会按如下两步去了解它：<strong>执行时机</strong> + <strong>做了何事</strong>。</p>
<hr>
<h3 id="执行时机"><a href="#执行时机" class="headerlink" title="执行时机"></a>执行时机</h3><p>废话不多说，直接结合源码解释。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BeanMethodInterceptor：</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(Method candidateMethod)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (candidateMethod.getDeclaringClass() != Object<span class="class">.<span class="keyword">class</span> &amp;&amp;</span></span><br><span class="line"><span class="class">			!<span class="title">BeanFactoryAwareMethodInterceptor</span>.<span class="title">isSetBeanFactory</span>(<span class="title">candidateMethod</span>) &amp;&amp;</span></span><br><span class="line"><span class="class">			<span class="title">BeanAnnotationHelper</span>.<span class="title">isBeanAnnotated</span>(<span class="title">candidateMethod</span>))</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三行代码，三个条件：</p>
<ol>
<li>该方法不能是Object的方法（即使你Object的方法标注了@Bean，我也不认）</li>
<li>不能是<code>setBeanFactory()</code>方法。这很容易理解，它交给上个拦截器搞定即可</li>
<li><strong>方法必须标注标注有@Bean注解</strong></li>
</ol>
<p>简而言之，<strong>标注有@Bean注解方法<code>执行时</code>会被拦截</strong>。</p>
<p>所以下面例子中的son()和parent()这两个，<strong>以及parent()里面调用的son()方法的执行</strong>它都会拦截（一共拦截3次）~</p>
<blockquote>
<p>小细节：方法只要是个Method即可，<strong>无论是static方法</strong>还是普通方法，都会“参与”此判断逻辑哦</p>
</blockquote>
<hr>
<h3 id="做了何事"><a href="#做了何事" class="headerlink" title="做了何事"></a>做了何事</h3><p>这里是具体拦截逻辑，会比第一个拦截器复杂很多。源码不算非常的多，但牵扯到的东西还真不少，比如AOP、比如Scope、比如Bean的创建等等，<strong>理解起来还蛮费劲的</strong>。</p>
<p>本处以拦截到<code>parent()</code>方法的执行为例，结合源码进行跟踪讲解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BeanMethodInterceptor：</span><br><span class="line"></span><br><span class="line"><span class="comment">// enhancedConfigInstance：被拦截的对象实例，也是代理对象</span></span><br><span class="line"><span class="comment">// beanMethod：parent()方法</span></span><br><span class="line"><span class="comment">// beanMethodArgs：空</span></span><br><span class="line"><span class="comment">// cglibMethodProxy：代理。用于调用其invoke/invokeSuper()来执行对应的方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object enhancedConfigInstance, </span></span></span><br><span class="line"><span class="function"><span class="params">	Method beanMethod, Object[] beanMethodArgs, MethodProxy cglibMethodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过反射，获取到Bean工厂。也就是$$beanFactory这个属性的值~</span></span><br><span class="line">	ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance);</span><br><span class="line">	<span class="comment">// 拿到Bean的名称</span></span><br><span class="line">	String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断这个方法是否是Scoped代理对象 很明显本利里是没有标注的 暂先略过</span></span><br><span class="line">	<span class="comment">// 简答的说：parent()方法头上是否标注有@Scoped注解~~~</span></span><br><span class="line">	<span class="keyword">if</span> (BeanAnnotationHelper.isScopedProxy(beanMethod)) &#123;</span><br><span class="line">		String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName);</span><br><span class="line">		<span class="keyword">if</span> (beanFactory.isCurrentlyInCreation(scopedBeanName)) &#123;</span><br><span class="line">			beanName = scopedBeanName;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ========下面要处理bean间方法引用的情况了========</span></span><br><span class="line">	<span class="comment">// 首先：检查所请求的Bean是否是FactoryBean。也就是bean名称为`&amp;parent`的Bean是否存在</span></span><br><span class="line">	<span class="comment">// 如果是的话，就创建一个代理子类，拦截它的getObject()方法以返回容器里的实例</span></span><br><span class="line">	<span class="comment">// 这样做保证了方法返回一个FactoryBean和@Bean的语义是效果一样的，确保了不会重复创建多个Bean</span></span><br><span class="line">	<span class="keyword">if</span> (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &amp;&amp;</span><br><span class="line">			factoryContainsBean(beanFactory, beanName)) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 先得到这个工厂Bean</span></span><br><span class="line">		Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">		<span class="keyword">if</span> (factoryBean <span class="keyword">instanceof</span> ScopedProxyFactoryBean) &#123;</span><br><span class="line">			<span class="comment">// Scoped proxy factory beans are a special case and should not be further proxied</span></span><br><span class="line">			<span class="comment">// 如果工厂Bean已经是一个Scope代理Bean，则不需要再增强</span></span><br><span class="line">			<span class="comment">// 因为它已经能够满足FactoryBean延迟初始化Bean了~</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 继续增强</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> enhanceFactoryBean(factoryBean, beanMethod.getReturnType(), beanFactory, beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查给定的方法是否与当前调用的容器相对应工厂方法。</span></span><br><span class="line">	<span class="comment">// 比较方法名称和参数列表来确定是否是同一个方法</span></span><br><span class="line">	<span class="comment">// 怎么理解这句话，参照下面详解吧</span></span><br><span class="line">	<span class="keyword">if</span> (isCurrentlyInvokedFactoryMethod(beanMethod)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这是个小细节：若你@Bean返回的是BeanFactoryPostProcessor类型</span></span><br><span class="line">		<span class="comment">// 请你使用static静态方法，否则会打印这句日志的~~~~</span></span><br><span class="line">		<span class="comment">// 因为如果是非静态方法，部分后置处理失效处理不到你，可能对你程序有影像</span></span><br><span class="line">		<span class="comment">// 当然也可能没影响，所以官方也只是建议而已~~~</span></span><br><span class="line">		<span class="keyword">if</span> (logger.isInfoEnabled() &amp;&amp;</span><br><span class="line">				BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">beanMethod</span>.<span class="title">getReturnType</span>())) </span>&#123;</span><br><span class="line">			... <span class="comment">// 输出info日志</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这表示：当前parent()方法，就是这个被拦截的方法，那就没啥好说的 </span></span><br><span class="line">		<span class="comment">// 相当于在代理代理类里执行了super(xxx);</span></span><br><span class="line">		<span class="comment">// 但是，但是，但是，此时的this依旧是代理类</span></span><br><span class="line">		<span class="keyword">return</span> cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// parent()方法里调用的son()方法会交给这里来执行</span></span><br><span class="line">	<span class="keyword">return</span> resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步骤总结：</p>
<ol>
<li>拿到当前BeanFactory工厂对象。该工厂对象通过第一个拦截器<code>BeanFactoryAwareMethodInterceptor</code>已经完成了设值</li>
<li>确定Bean名称。<strong>默认是方法名</strong>，若通过@Bean指定了以指定的为准，若指定了多个值以第一个值为准，后面的值当作Bean的alias别名</li>
<li>判断当前方法(以parent()方法为例)是否是个Scope域代理。也就是方法上是否标注有<code>@Scope</code>注解<ol>
<li>若是域代理类，那旧以它的方式来处理喽。beanName的变化变化为<code>scopedTarget.parent</code></li>
<li>判断<code>scopedTarget.parent</code>这个Bean是否正在创建中…若是的，那就把当前beanName替换为<code>scopedTarget.parent</code>，以后就关注这个名称的Bean了~</li>
<li>试想一下，如果不来这个判断的话，那最终可能的结果是：容器内一个名为parent的Bean，一个名字为<code>scopedTarget.parent</code>的Bean，那岂不又出问题了麽~</li>
</ol>
</li>
<li>判断请求的Bean是否是个FactoryBean工厂Bean。<ol>
<li>若是工厂Bean，那么就需要enhance增强这个Bean，以拦截它的getObject()方法</li>
<li>拦截<code>getObject()</code>的做法是：当执行<code>getObject()</code>方法时转为 -&gt; <code>getBean()</code>方法</li>
<li>为什么需要这么做：是为了确保FactoryBean产生的实例是通过getBean()容器去获取的，而非又自己创建一个出来了</li>
<li><strong>这种case先打个❓，下面会结合代码示例加以说明</strong></li>
</ol>
</li>
<li>判断这个beanMethod是否是<strong>当前正在被调用的工厂方法</strong>。<ol>
<li>若是正在创建的方法，那就好说了，直接<code>super(xxx)</code>执行父类方法体完事~</li>
<li>若不是正在创建的方法，那就需要代理喽，以确保实际调用的仍旧是实际调用<code>getBean</code>方法而保证是同一个Bean</li>
<li><strong>这种case先打个❓，下面会结合代码示例加以说明</strong>。因为这个case是最常见的主线case，所以先把它搞定</li>
</ol>
</li>
</ol>
<p>这是该拦截器的执行步骤，留下两个打❓下面我来一一解释（按照倒序）。</p>
<hr>
<h4 id="多次调用-Bean方法为何不会产生新实例？"><a href="#多次调用-Bean方法为何不会产生新实例？" class="headerlink" title="多次调用@Bean方法为何不会产生新实例？"></a>多次调用@Bean方法为何不会产生新实例？</h4><p><strong>这是最为常见的case</strong>。示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Son <span class="title">son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        System.out.println(<span class="string">"son created..."</span> + son.hashCode());</span><br><span class="line">        <span class="keyword">return</span> son;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Parent <span class="title">parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        notBeanMethod();</span><br><span class="line">        Son son = son();</span><br><span class="line">        System.out.println(<span class="string">"parent created...持有的Son是："</span> + son.hashCode());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Parent(son);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notBeanMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"notBeanMethod invoked by 【"</span> + <span class="keyword">this</span> + <span class="string">"】"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本配置类一共有<strong>三个</strong>方法：</p>
<ul>
<li><strong>son()</strong>：标注有@Bean。</li>
</ul>
<p><img data-src="https://img-blog.csdnimg.cn/20200520173703329.png#x140" alt=""><br>因此它最终交给<code>cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs);</code>方法直接执行父类（也就是目标类）的方法体：<br><img data-src="https://img-blog.csdnimg.cn/20200520174102191.png#x200" alt=""><br>值得注意的是：<strong>此时所处的对象仍旧是代理对象内</strong>，这个方法体只是通过代理类调用了<code>super(xxx)</code>方法进来的而已嘛~</p>
<ul>
<li><strong>parent()</strong>：标注有@Bean。它内部会还会调用notBeanMethod()和son()两个方法</li>
</ul>
<p>同上，会走到目标类的方法体里，开始调用 <strong>notBeanMethod()和son()</strong> 这两个方法，这个时候处理的方式就不一样了：</p>
<ol>
<li>调用<code>notBeanMethod()</code>方法，因为它没有标注@Bean注解，所以不会被拦截 -&gt; 直接执行方法体</li>
<li>调用<code>son()</code>方法，因为它标注有@Bean注解，所以会继续进入到拦截器里。但请注意和上面 <strong>直接调用</strong> son()方法不一样的是：<strong>此时当前正在被invoked的方法是parent()方法，而并非son()方法</strong>，所以他会被交给<code>resolveBeanReference()</code>方法来处理：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BeanMethodInterceptor：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">resolveBeanReference</span><span class="params">(Method beanMethod, Object[] beanMethodArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">		ConfigurableBeanFactory beanFactory, String beanName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前bean（son这个Bean）是否正在创建中... 本处为false嘛</span></span><br><span class="line">	<span class="comment">// 这个判断主要是为了防止后面getBean报错~~~</span></span><br><span class="line">	<span class="keyword">boolean</span> alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 如果该Bean确实正在创建中，先把它标记下，放置后面getBean报错~</span></span><br><span class="line">		<span class="keyword">if</span> (alreadyInCreation) &#123;</span><br><span class="line">			beanFactory.setCurrentlyInCreation(beanName, <span class="keyword">false</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 更具该方法的入参，决定后面使用getBean(beanName)还是getBean(beanName,args)</span></span><br><span class="line">		<span class="comment">// 基本原则是：但凡只要有一个入参为null，就调用getBean(beanName)</span></span><br><span class="line">		<span class="keyword">boolean</span> useArgs = !ObjectUtils.isEmpty(beanMethodArgs);</span><br><span class="line">		<span class="keyword">if</span> (useArgs &amp;&amp; beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Object arg : beanMethodArgs) &#123;</span><br><span class="line">				<span class="keyword">if</span> (arg == <span class="keyword">null</span>) &#123;</span><br><span class="line">					useArgs = <span class="keyword">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 通过getBean从容器中拿到这个实例  本处拿出的就是Son实例喽</span></span><br><span class="line">		Object beanInstance = (useArgs ? beanFactory.getBean(beanName, beanMethodArgs) : beanFactory.getBean(beanName));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 方法返回类型和Bean实际类型做个比较，因为有可能类型不一样</span></span><br><span class="line">		<span class="comment">// 什么时候会出现类型不一样呢？当BeanDefinition定义信息类型被覆盖的时候，就可能出现此现象</span></span><br><span class="line">		<span class="keyword">if</span> (!ClassUtils.isAssignableValue(beanMethod.getReturnType(), beanInstance)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (beanInstance.equals(<span class="keyword">null</span>)) &#123;</span><br><span class="line">				beanInstance = <span class="keyword">null</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				...</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 当前被调用的方法，是parent()方法</span></span><br><span class="line">		Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod();</span><br><span class="line">		<span class="keyword">if</span> (currentlyInvoked != <span class="keyword">null</span>) &#123;</span><br><span class="line">			String outerBeanName = BeanAnnotationHelper.determineBeanNameFor(currentlyInvoked);</span><br><span class="line">			<span class="comment">// 这一步是注册依赖关系，告诉容器：</span></span><br><span class="line">			<span class="comment">// parent实例的初始化依赖于son实例</span></span><br><span class="line">			beanFactory.registerDependentBean(beanName, outerBeanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 返回实例</span></span><br><span class="line">		<span class="keyword">return</span> beanInstance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 归还标记：笔记实际确实还在创建中嘛~~~~</span></span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (alreadyInCreation) &#123;</span><br><span class="line">			beanFactory.setCurrentlyInCreation(beanName, <span class="keyword">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这么一来，执行完parent()方法体里的son()方法后，<strong>实际得到的是容器内的实例</strong>，从而保证了我们这么写是不会有问题的。</li>
</ol>
<ul>
<li><strong>notBeanMethod()</strong>：因为没有标注@Bean，所以它并不会被容器调用，而只能是被上面的<code>parent()</code>方法调用到，并且也不会被拦截（值得注意的是：因为此方法不需要被代理，所以此方法可以是<code>private final</code>的哦~）</li>
</ul>
<p>以上程序的运行结果是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">son created...<span class="number">347978868</span></span><br><span class="line">notBeanMethod invoked by 【com.yourbatman.fullliteconfig.config.AppConfig$$EnhancerBySpringCGLIB$$ec611337@<span class="number">12591</span>ac8】</span><br><span class="line">parent created...持有的Son是：<span class="number">347978868</span></span><br><span class="line">com.yourbatman.fullliteconfig.config.AppConfig$$EnhancerBySpringCGLIB$$ec611337@<span class="number">12591</span>ac8</span><br><span class="line">容器内的Son实例：<span class="number">347978868</span></span><br><span class="line">容器内Person持有的Son实例：<span class="number">347978868</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p>可以看到，<strong>Son自始至终都只存在一个实例</strong>，这是符合我们的预期的。</p>
<hr>
<h5 id="Lite模式下表现如何？"><a href="#Lite模式下表现如何？" class="headerlink" title="Lite模式下表现如何？"></a>Lite模式下表现如何？</h5><p>同样的代码，在Lite模式下（去掉@Configuration注解即可），不存在“如此复杂”的代理逻辑，所以上例的运行结果是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">son created...<span class="number">624271064</span></span><br><span class="line">notBeanMethod invoked by 【com.yourbatman.fullliteconfig.config.AppConfig@<span class="number">21</span>a947fe】</span><br><span class="line">son created...<span class="number">90205195</span></span><br><span class="line">parent created...持有的Son是：<span class="number">90205195</span></span><br><span class="line">com.yourbatman.fullliteconfig.config.AppConfig@<span class="number">21</span>a947fe</span><br><span class="line">容器内的Son实例：<span class="number">624271064</span></span><br><span class="line">容器内Person持有的Son实例：<span class="number">90205195</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<p>这个结果很好理解，这里我就不再啰嗦了。总之就不能这么用就对了~</p>
<hr>
<h4 id="FactoryBean模式剖析"><a href="#FactoryBean模式剖析" class="headerlink" title="FactoryBean模式剖析"></a>FactoryBean模式剖析</h4><p><code>FactoryBean</code>也是向容器提供Bean的一种方式，如最常见的<code>SqlSessionFactoryBean</code>就是这么一个大代表，因为它比较常用，并且这里也作为此拦截器一个<strong>单独的执行分支</strong>，所以很有必要研究一番。</p>
<p>执行此分支逻辑的条件是：容器内已经存在<code>&amp;beanName</code>和<code>beanName</code>两个Bean。执行的方式是：使用<code>enhanceFactoryBean()</code>方法对<code>FactoryBean</code>进行增强。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConfigurationClassEnhancer：</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个子类代理，拦截对getObject()的调用，委托给当前的BeanFactory</span></span><br><span class="line"><span class="comment">// 而不是创建一个新的实例。这些代理仅在调用FactoryBean时创建</span></span><br><span class="line"><span class="comment">// factoryBean：从容器内拿出来的那个已经存在的工厂Bean实例（是工厂Bean实例）</span></span><br><span class="line"><span class="comment">// exposedType：@Bean标注的方法的返回值类型</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">enhanceFactoryBean</span><span class="params">(Object factoryBean, Class&lt;?&gt; exposedType,</span></span></span><br><span class="line"><span class="function"><span class="params">		ConfigurableBeanFactory beanFactory, String beanName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 看看Spring容器内已经存在的这个工厂Bean的情况，看看是否有final</span></span><br><span class="line">		Class&lt;?&gt; clazz = factoryBean.getClass();</span><br><span class="line">		<span class="keyword">boolean</span> finalClass = Modifier.isFinal(clazz.getModifiers());</span><br><span class="line">		<span class="keyword">boolean</span> finalMethod = Modifier.isFinal(clazz.getMethod(<span class="string">"getObject"</span>).getModifiers());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 类和方法其中有一个是final，那就只能看看能不能走接口代理喽</span></span><br><span class="line">		<span class="keyword">if</span> (finalClass || finalMethod) &#123;</span><br><span class="line">			<span class="comment">// @Bean标注的方法返回值若是接口类型 尝试走基于接口的JDK动态代理</span></span><br><span class="line">			<span class="keyword">if</span> (exposedType.isInterface()) &#123;</span><br><span class="line">				<span class="comment">// 基于JDK的动态代理</span></span><br><span class="line">				<span class="keyword">return</span> createInterfaceProxyForFactoryBean(factoryBean, exposedType, beanFactory, beanName);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 类或方法存在final情况，但是呢返回类型又不是</span></span><br><span class="line">				<span class="keyword">return</span> factoryBean;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">		<span class="comment">// 没有getObject()方法  很明显，一般不会走到这里</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 到这，说明以上条件不满足：存在final且还不是接口类型</span></span><br><span class="line">	<span class="comment">// 类和方法都不是final，生成一个CGLIB的动态代理</span></span><br><span class="line">	<span class="keyword">return</span> createCglibProxyForFactoryBean(factoryBean, beanFactory, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步骤总结：</p>
<ol>
<li>拿到容器内已经存在的这个工厂Bean的类型，看看类上、getObject()方法是否用final修饰了</li>
<li>但凡只需<strong>有一个</strong>被final修饰了，那注定不能使用CGLIB代理了喽，那么就尝试使用基于接口的JDK动态代理：<ol>
<li>若你标注的@Bean返回的是接口类型（也就是<code>FactoryBean</code>类型），那就ok，使用JDK创建个代理对象返回</li>
<li>若不是接口（有final又还不是接口），那老衲无能为力了：原样return返回</li>
</ol>
</li>
<li>若以上条件不满足，表示一个final都木有，那就统一使用CGLIB去生成一个代理子类。大多数情况下，都会走到这个分支上，代理是通过CGLIB生成的<blockquote>
<p>说明：无论是JDK动态代理还是CGLIB的代理实现均非常简单，就是把getObject()方法代理为使用<code>beanFactory.getBean(beanName)</code>去获取实例（要不代理掉的话，每次不就执行你getObject()里面的逻辑了麽，就又会创建新实例啦~）</p>
</blockquote>
</li>
</ol>
<p><strong>需要明确</strong>，此拦截器对FactoryBean逻辑处理分支的目的是：确保你<strong>通过方法调用</strong>拿到<code>FactoryBean</code>后，再调用其<code>getObject()</code>方法（哪怕调用多次）得到的都是同一个示例（容器内的单例）。因此需要对<code>getObject()</code>方法做拦截嘛，让该方法指向到<code>getBean()</code>，永远从容器里面拿即可。</p>
<blockquote>
<p>这个拦截处理逻辑只有在@Bean方法调用时才有意义，比如parent()里调用了son()这样子才会起到作用，否则你就忽略它吧~</p>
</blockquote>
<p>针对于此，下面给出不同case下的代码示例，加强理解。</p>
<hr>
<h5 id="代码示例（重要）"><a href="#代码示例（重要）" class="headerlink" title="代码示例（重要）"></a>代码示例（重要）</h5><p>准备一个<code>SonFactoryBean</code>用于产生Son实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SonFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Son</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Son <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Son();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Son<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且在配置类里把它放好：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FactoryBean&lt;Son&gt; <span class="title">son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SonFactoryBean sonFactoryBean = <span class="keyword">new</span> SonFactoryBean();</span><br><span class="line">        System.out.println(<span class="string">"我使用@Bean定义sonFactoryBean："</span> + sonFactoryBean.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"我使用@Bean定义sonFactoryBean identityHashCode："</span> + System.identityHashCode(sonFactoryBean));</span><br><span class="line">        <span class="keyword">return</span> sonFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Parent <span class="title">parent</span><span class="params">(Son son)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 根据前面所学，sonFactoryBean肯定是去容器拿</span></span><br><span class="line">        FactoryBean&lt;Son&gt; sonFactoryBean = son();</span><br><span class="line">        System.out.println(<span class="string">"parent流程使用的sonFactoryBean："</span> + sonFactoryBean.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"parent流程使用的sonFactoryBean identityHashCode："</span> + System.identityHashCode(sonFactoryBean));</span><br><span class="line">        System.out.println(<span class="string">"parent流程使用的sonFactoryBean："</span> + sonFactoryBean.getClass());</span><br><span class="line">        <span class="comment">// 虽然sonFactoryBean是从容器拿的，但是getObject()你可不能保证每次都返回单例哦~</span></span><br><span class="line">        Son sonFromFactory1 = sonFactoryBean.getObject();</span><br><span class="line">        Son sonFromFactory2 = sonFactoryBean.getObject();</span><br><span class="line">        System.out.println(<span class="string">"parent流程使用的sonFromFactory1："</span> + sonFromFactory1.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"parent流程使用的sonFromFactory1："</span> + sonFromFactory2.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"parent流程使用的son和容器内的son是否相等："</span> + (son == sonFromFactory1));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Parent(sonFromFactory1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    SonFactoryBean sonFactoryBean = context.getBean(<span class="string">"&amp;son"</span>, SonFactoryBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(<span class="string">"Spring容器内的SonFactoryBean："</span> + sonFactoryBean.hashCode());</span><br><span class="line">    System.out.println(<span class="string">"Spring容器内的SonFactoryBean："</span> + System.identityHashCode(sonFactoryBean));</span><br><span class="line">    System.out.println(<span class="string">"Spring容器内的SonFactoryBean："</span> + sonFactoryBean.getClass());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Spring容器内的Son："</span> + context.getBean(<span class="string">"son"</span>).hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我使用<span class="meta">@Bean</span>定义sonFactoryBean：<span class="number">313540687</span></span><br><span class="line">我使用<span class="meta">@Bean</span>定义sonFactoryBean identityHashCode：<span class="number">313540687</span></span><br><span class="line"></span><br><span class="line">parent流程使用的sonFactoryBean：<span class="number">313540687</span></span><br><span class="line">parent流程使用的sonFactoryBean identityHashCode：<span class="number">70807318</span></span><br><span class="line">parent流程使用的sonFactoryBean：<span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">yourbatman</span>.<span class="title">fullliteconfig</span>.<span class="title">config</span>.<span class="title">SonFactoryBean</span>$$<span class="title">EnhancerBySpringCGLIB</span>$$1<span class="title">ccec41d</span></span></span><br><span class="line"><span class="class"><span class="title">parent</span>流程使用的<span class="title">sonFromFactory1</span>：910091170</span></span><br><span class="line"><span class="class"><span class="title">parent</span>流程使用的<span class="title">sonFromFactory1</span>：910091170</span></span><br><span class="line"><span class="class"><span class="title">parent</span>流程使用的<span class="title">son</span>和容器内的<span class="title">son</span>是否相等：<span class="title">true</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">Spring</span>容器内的<span class="title">SonFactoryBean</span>：313540687</span></span><br><span class="line"><span class="class"><span class="title">Spring</span>容器内的<span class="title">SonFactoryBean</span>：313540687</span></span><br><span class="line"><span class="class"><span class="title">Spring</span>容器内的<span class="title">SonFactoryBean</span>：<span class="title">class</span> <span class="title">com</span>.<span class="title">yourbatman</span>.<span class="title">fullliteconfig</span>.<span class="title">config</span>.<span class="title">SonFactoryBean</span></span></span><br><span class="line"><span class="class"><span class="title">Spring</span>容器内的<span class="title">Son</span>：910091170</span></span><br></pre></td></tr></table></figure>
<p>结果分析：<br><img data-src="https://img-blog.csdnimg.cn/20200521075138785.png#x200" alt=""><br>达到了预期的效果：parent在调用son()方法时，得到的是在容器内已经存在的<code>SonFactoryBean</code>基础上CGLIB字节码<code>提升过的实例</code>，<strong>拦截成功</strong>，从而getObject()也就实际是去容器里拿对象的。</p>
<p>通过本例有如下小细节需要指出：</p>
<ol>
<li>原始对象和代理/增强后（不管是CGLIB还是JDK动态代理）的实例的<code>.hashCode()</code>以及<code>.equals()</code>方法是一毛一样的，但是<code>identityHashCode()</code>值（实际内存值）不一样哦，因为是不同类型、不同实例，这点请务必注意</li>
<li>最终存在于容器内的仍旧是原生工厂Bean对象，而非代理后的工厂Bean实例。毕竟拦截器只是拦截了@Bean方法的调用来了个“偷天换日”而已~</li>
<li>若<code>SonFactoryBean</code>上加个final关键字修饰，根据上面讲述的逻辑，那代理对象会使用JDK动态代理生成喽，形如这样（本处仅作为示例，实际使用中请别这么干）：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SonFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Son</span>&gt; </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
再次运行程序，结果输出为：执行的结果一样，只是代理方式不一样而已。从这个小细节你也能看出来Spring对代理实现上的偏向：<strong>优先选择CGLIB代理方式，JDK动态代理方式用于兜底</strong>。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 使用了JDK的动态代理</span></span><br><span class="line">parent流程使用的sonFactoryBean：<span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">sun</span>.<span class="title">proxy</span>.$<span class="title">Proxy11</span></span></span><br><span class="line"><span class="class">...</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示：若你标注了final关键字了，那么请保证@Bean方法返回的是<code>FactoryBean</code>接口，而不能是<code>SonFactoryBean</code>实现类，否则最终无法代理了，原样输出。因为JDK动态代理和CGLIB都搞不定了嘛~</p>
</blockquote>
</li>
</ol>
<hr>
<p>在以上例子的基础上，我给它“加点料”，再看看效果呢：</p>
<p>使用<code>BeanDefinitionRegistryPostProcessor</code>提前就放进去一个名为son的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这两种方式向容器扔bd or singleton bean都行  我就选择第二种喽</span></span><br><span class="line"><span class="comment">// 注意：此处放进去的是BeanFactory工厂，名称是son哦~~~  不要写成了&amp;son</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SonBeanDefinitionRegistryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// registry.registerBeanDefinition("son", BeanDefinitionBuilder.rootBeanDefinition(SonFactoryBean.class).getBeanDefinition());</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        SonFactoryBean sonFactoryBean = <span class="keyword">new</span> SonFactoryBean();</span><br><span class="line">        System.out.println(<span class="string">"初始化时，注册进容器的sonFactoryBean："</span> + sonFactoryBean);</span><br><span class="line">        beanFactory.registerSingleton(<span class="string">"son"</span>, sonFactoryBean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次运行程序，输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">初始化时最早进容器的sonFactoryBean：<span class="number">2027775614</span></span><br><span class="line">初始化时最早进容器的sonFactoryBean identityHashCode：<span class="number">2027775614</span></span><br><span class="line"></span><br><span class="line">parent流程使用的sonFactoryBean：<span class="number">2027775614</span></span><br><span class="line">parent流程使用的sonFactoryBean identityHashCode：<span class="number">1183888521</span></span><br><span class="line">parent流程使用的sonFactoryBean：<span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">yourbatman</span>.<span class="title">fullliteconfig</span>.<span class="title">config</span>.<span class="title">SonFactoryBean</span>$$<span class="title">EnhancerBySpringCGLIB</span>$$1<span class="title">ccec41d</span></span></span><br><span class="line"><span class="class"><span class="title">parent</span>流程使用的<span class="title">sonFromFactory1</span>：2041605291</span></span><br><span class="line"><span class="class"><span class="title">parent</span>流程使用的<span class="title">sonFromFactory1</span>：2041605291</span></span><br><span class="line"><span class="class"><span class="title">parent</span>流程使用的<span class="title">son</span>和容器内的<span class="title">son</span>是否相等：<span class="title">true</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">Spring</span>容器内的<span class="title">SonFactoryBean</span>：2027775614</span></span><br><span class="line"><span class="class"><span class="title">Spring</span>容器内的<span class="title">SonFactoryBean</span>：2027775614</span></span><br><span class="line"><span class="class"><span class="title">Spring</span>容器内的<span class="title">SonFactoryBean</span>：<span class="title">class</span> <span class="title">com</span>.<span class="title">yourbatman</span>.<span class="title">fullliteconfig</span>.<span class="title">config</span>.<span class="title">SonFactoryBean</span></span></span><br><span class="line"><span class="class"><span class="title">Spring</span>容器内的<span class="title">Son</span>：2041605291</span></span><br></pre></td></tr></table></figure>
<p><strong>效果上并不差异</strong>，从日志上可以看到：你配置类上使用@Bean标注的son()<strong>方法体</strong>并没执行了，而是使用的最开始注册进去的实例，差异仅此而已。</p>
<blockquote>
<p>为何是这样的现象？这就不属于本文的内容了，是Spring容器对Bean的实例化、初始化逻辑，本公众号后面依旧会采用专栏式讲解，让你彻底弄懂它。当前有兴趣的可以先自行参考<code>DefaultListableBeanFactory#preInstantiateSingletons</code>的内容~</p>
</blockquote>
<hr>
<h5 id="Lite模式下表现如何？-1"><a href="#Lite模式下表现如何？-1" class="headerlink" title="Lite模式下表现如何？"></a>Lite模式下表现如何？</h5><p>Lite模式下可没这些“加强特性”，所以在Lite模式下（拿掉<code>@Configuration</code>这个注解便可）运行以上程序，结果输出为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我使用<span class="meta">@Bean</span>定义sonFactoryBean：<span class="number">477289012</span></span><br><span class="line">我使用<span class="meta">@Bean</span>定义sonFactoryBean identityHashCode：<span class="number">477289012</span></span><br><span class="line"></span><br><span class="line">我使用<span class="meta">@Bean</span>定义sonFactoryBean：<span class="number">2008966511</span></span><br><span class="line">我使用<span class="meta">@Bean</span>定义sonFactoryBean identityHashCode：<span class="number">2008966511</span></span><br><span class="line">parent流程使用的sonFactoryBean：<span class="number">2008966511</span></span><br><span class="line">parent流程使用的sonFactoryBean identityHashCode：<span class="number">2008966511</span></span><br><span class="line">parent流程使用的sonFactoryBean：<span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">yourbatman</span>.<span class="title">fullliteconfig</span>.<span class="title">config</span>.<span class="title">SonFactoryBean</span></span></span><br><span class="line"><span class="class"><span class="title">parent</span>流程使用的<span class="title">sonFromFactory1</span>：433874882</span></span><br><span class="line"><span class="class"><span class="title">parent</span>流程使用的<span class="title">sonFromFactory1</span>：572191680</span></span><br><span class="line"><span class="class"><span class="title">parent</span>流程使用的<span class="title">son</span>和容器内的<span class="title">son</span>是否相等：<span class="title">false</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">Spring</span>容器内的<span class="title">SonFactoryBean</span>：477289012</span></span><br><span class="line"><span class="class"><span class="title">Spring</span>容器内的<span class="title">SonFactoryBean</span>：477289012</span></span><br><span class="line"><span class="class"><span class="title">Spring</span>容器内的<span class="title">SonFactoryBean</span>：<span class="title">class</span> <span class="title">com</span>.<span class="title">yourbatman</span>.<span class="title">fullliteconfig</span>.<span class="title">config</span>.<span class="title">SonFactoryBean</span></span></span><br><span class="line"><span class="class"><span class="title">Spring</span>容器内的<span class="title">Son</span>：211968962</span></span><br></pre></td></tr></table></figure>
<p>结果解释我就不再啰嗦，有了前面的基础就太容易理解了。</p>
<hr>
<h5 id="为何是-Scope域代理就不用处理？"><a href="#为何是-Scope域代理就不用处理？" class="headerlink" title="为何是@Scope域代理就不用处理？"></a>为何是@Scope域代理就不用处理？</h5><p>要解释好这个原因，和<code>@Scope</code>代理方式的原理知识强相关。限于篇幅，本文就先卖个关子~</p>
<p>关于<code>@Scope</code>我个人觉得足够用5篇以上文章专题讲解，虽然在<code>Spring Framework</code>里使用得比较少，但是在理解<code>Spirng Cloud</code>的自定义扩展实现上显得非常非常有必要，所以你可关注我公众号，会近期推出相关专栏的。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于Spring配置类这个专栏内容，讲解到这就完成99%了，毫不客气的说关于此部分知识真正可以实现“横扫千军”，据我了解没有解决不了的问题了。</p>
<p>当然还剩下1%，那自然是缺少一篇总结篇喽：在下一篇总结篇里，我会用<strong>图文并茂</strong>的方式对Spring配置类相关内容的执行流程进行总结，目的是让你<strong>快速掌握</strong>，应付面试嘛。</p>
<p><strong>本文将近2万字，手真的很累</strong>，如果对你有帮助，帮点个在看哈。最主要的是：关注我的公众号，后期推出的专栏都会很精彩……</p>]]></content>
      <categories>
        <category>Spring配置类</category>
      </categories>
      <tags>
        <tag>Spring Framework</tag>
        <tag>@Configuration</tag>
      </tags>
  </entry>
  <entry>
    <title>你自我介绍说很懂Spring配置类，那你怎么解释这个现象？</title>
    <url>/x2y/6dd28e9b.html</url>
    <content><![CDATA[<blockquote>
<p>当大潮退去，才知道谁在裸泳。<br><strong>作者</strong>：A哥（YourBatman）<br><strong>公众号</strong>：BAT的乌托邦（ID：BAT-utopia）<br><strong>文末是否有彩蛋</strong>：有</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>各位小伙伴大家好，我是A哥。本专栏/系列讲解到这里，关于Spring的<code>@Configuration</code>配置类，应该是可以完成95%以上工作上的使用以及问题的解决。你也绝对算得上是一个“懂它”的Java Coder了，面试自然也就不在话下，基本可以实现“吊打面试官”。</p>
<blockquote>
<p>建议刚“翻开”本专栏的同学去我公众号往前翻翻，前几篇文章能助你投入精力较少，收获大不一样</p>
</blockquote>
<p>虽然你已经可以搞定95%的问题，但还剩5%呢？不要了麽？然而残酷的现实却是这样的，能解决那5%问题的才是真正的王者，他们的薪资往往能高出你一个甚至多个Level，并且在你眼中还好像还“不怎么干活”，不信你品，你细品……<strong>这就是不可替代性/稀缺性的价值……</strong></p>
<p><img data-src="https://img-blog.csdnimg.cn/20200519072132751.png#x200" alt=""></p>
<p>如何提高自己的不可替代性？对于三无的我们，没有办法只能冲着那5%出发呗。对于钟爱于<strong>面向工资编程</strong>的我们，一般还是有更高追求的嘛，毕竟在趋同的程序员视界里，要的就是不一样，所以需要继续打怪升级。</p>
<p>接下来的两篇内容会比较深入，可能会让一些“初学者”感到不适（若感觉不适赶紧往前翻翻补课），希望坚持，毕竟这最终都会反应到你每个月的工资上，<strong>做难事必有所得嘛</strong>。</p>
<blockquote>
<p>我粗浅的认为，对于大多数人来说，工资是衡量个人<strong>市场价值</strong>的唯一/最重要标准。工资20k和22k的两人可认为是差不多的，但40k的人肯定比前者价值高出一截</p>
</blockquote>
<hr>
<h2 id="版本约定"><a href="#版本约定" class="headerlink" title="版本约定"></a>版本约定</h2><p>本文内容若没做特殊说明，均基于以下版本：</p>
<ul>
<li>JDK：<code>1.8</code></li>
<li>Spring Framework：<code>5.2.2.RELEASE</code></li>
</ul>
<p><img data-src="https://img-blog.csdnimg.cn/20200519070957868.gif#x200" alt=""></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>如果说前面是些武功招式，那么接下来就到了内功修炼阶段了。<strong>走得多块得看你手脚是否能灵活会用，而走得多远是由你的体力（内功）决定的</strong>。下面我先以一个示例（可当面试题）开始本文的内容。</p>
<hr>
<h2 id="配置类在Full模式下的“能力”展示"><a href="#配置类在Full模式下的“能力”展示" class="headerlink" title="配置类在Full模式下的“能力”展示"></a>配置类在Full模式下的“能力”展示</h2><p>配置类（标注有@Configuration注解，属于Full模式）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="case1："><a href="#case1：" class="headerlink" title="case1："></a>case1：</h3><p>先来个简单点的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    AppConfig appConfig = context.getBean(AppConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(appConfig.getClass());</span><br><span class="line">    System.out.println(appConfig.getClass().getSuperclass() == AppConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(AopUtils.isCglibProxy(appConfig));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">yourbatman</span>.<span class="title">fullliteconfig</span>.<span class="title">config</span>.<span class="title">AppConfig</span>$$<span class="title">EnhancerBySpringCGLIB</span>$$<span class="title">d38ead10</span></span></span><br><span class="line"><span class="class"><span class="title">true</span></span></span><br><span class="line"><span class="class"><span class="title">false</span></span></span><br></pre></td></tr></table></figure>
<p>结果解释：</p>
<ol>
<li>Full模式的配置类被CGLIB增强了，所以最终放进容器内的实际是代理对象</li>
<li>代理类是由CGLIB生成的子类，所以父类必然就是<strong>目标类</strong></li>
<li>这个为何是false？？？其实这个和<code>AopUtils.isCglibProxy()</code>的实现有关（建议你源码点进去瞄一眼一切都明白了），这个配置类仅仅是被CGLIB代理了，和AOP没毛关系</li>
</ol>
<hr>
<h3 id="case2："><a href="#case2：" class="headerlink" title="case2："></a>case2：</h3><p>这个case会进阶一些。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    AppConfig appConfig = context.getBean(AppConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    Field $$beanFactoryField = ReflectionUtils.findField(appConfig.getClass(), <span class="string">"$$beanFactory"</span>);</span><br><span class="line">    BeanFactory beanFactory = (BeanFactory) $$beanFactoryField.get(appConfig);</span><br><span class="line"></span><br><span class="line">    System.out.println(beanFactory == context.getAutowireCapableBeanFactory());</span><br><span class="line">    System.out.println(beanFactory == context);</span><br><span class="line">    System.out.println(appConfig <span class="keyword">instanceof</span> BeanFactoryAware);</span><br><span class="line">    System.out.println(appConfig.getClass().getInterfaces()[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">context</span>.<span class="title">annotation</span>.<span class="title">ConfigurationClassEnhancer</span>$<span class="title">EnhancedConfiguration</span></span></span><br></pre></td></tr></table></figure>
<p>结果解释：</p>
<ol>
<li>CGLIB字节码提升时，会自动给代理类新增一个名为<code>$$beanFactory</code>的字段/属性，在运行期间给其赋值。所以通过反射可以从<strong>代理实例</strong>里拿到这个属性值，并且值就是<strong>当前BeanFactory</strong><ol>
<li>小细节：一定只能写成<code>(appConfig.getClass(), &quot;$$beanFactory&quot;)</code>而不能是<code>(AppConfig.class, &quot;$$beanFactory&quot;)</code>哦，因为这个Field属于代理类而非目标类</li>
</ol>
</li>
<li>这个结果是false，和配置类本身并无关系，考察的知识点是Spring上下文Bean工厂和内建Bean工程的区别，这里先混个脸熟，下个专栏会详解的</li>
<li>结果为true。你是否想动粗：“劳资”的AppConfig配置类明明就没有实现<code>BeanFactoryAware</code>接口，为毛你给我返回true呢？</li>
<li>解释同上</li>
</ol>
<p>如果面试官通过这样的题目来考你（其实目的是想让你“降薪”），你是否招架得住，成为那5%呢？本文将带你一起继续深挖Spring <code>@Configuration</code>配置里面的“玄机”，看完后你再回来看这几个题目就会感叹了：so easy。</p>
<hr>
<h2 id="何时创建代理？"><a href="#何时创建代理？" class="headerlink" title="何时创建代理？"></a>何时创建代理？</h2><p>我们已然知道Full模式的配置类最终会被CGLIB字节码提升，从而最终放一个代理类对象到Spring容器里。那么我们先来弄清楚创建代理的时机在哪儿~</p>
<p>Spring容器在<code>refresh()</code>启动步骤的<code>AbstractApplicationContext#invokeBeanFactoryPostProcessors</code>这一步会执行所有的<code>BeanFactoryPostProcessor</code>处理器，而此时<code>BeanFactory</code>才刚刚准备好，容器内除了<code>ConfigurationClassPostProcessor</code>之外，并无任何其它<code>BeanFactoryPostProcessor</code>，截图示例如下：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200519080351869.png#x140" alt=""></p>
<blockquote>
<p>可能你会问：既然这么早期，那这个处理器是什么时候放进去的呢？我只能回答：在Bean容器“开山阶段”同几个开山鼻祖一起放进去的。如果你继续追问很多为什么的话，那我只能回答：这不是本专栏讲解的重点所在，放在下个专栏详解，请关注我公众号即可</p>
</blockquote>
<p>既然这样，那么接下来就会会<code>ConfigurationClassPostProcessor</code>这个后置处理器喽。</p>
<hr>
<h2 id="ConfigurationClassPostProcessor"><a href="#ConfigurationClassPostProcessor" class="headerlink" title="ConfigurationClassPostProcessor"></a>ConfigurationClassPostProcessor</h2><p>用于引导处理<code>@Configuration</code>配置类。该后置处理器的优先级是较高的，属于<code>PriorityOrdered</code>分类。</p>
<blockquote>
<p>说明：<code>PriorityOrdered</code>的优先级肯定比<code>Order</code>接口的高</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @since 3.0</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationClassPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span>,</span></span><br><span class="line"><span class="class">		<span class="title">PriorityOrdered</span>, <span class="title">ResourceLoaderAware</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它是一个<code>BeanDefinitionRegistryPostProcessor</code>处理器，所以在容器启动过程中会先后执行如下两个方法：</p>
<hr>
<h3 id="postProcessBeanDefinitionRegistry"><a href="#postProcessBeanDefinitionRegistry" class="headerlink" title="postProcessBeanDefinitionRegistry()"></a>postProcessBeanDefinitionRegistry()</h3><p>从注册进来的配置类（可能是Full模式，可能是Lite模式）里进一步派生bean定义。简而言之：收集到所有的<code>BeanDefinition</code>（后简称为bd）存储起来，包括<code>@Import、@Component</code>等等组件。<strong>并且做出标注：是Full模式的还是Lite模式的配置类</strong>（若非配置组件就不标注哦）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConfigurationClassPostProcessor：</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 生成一个id，放置后面再重复执行</span></span><br><span class="line">		<span class="keyword">int</span> registryId = System.identityHashCode(registry);</span><br><span class="line">		<span class="comment">// 若重复执行  就抛出异常</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"postProcessBeanDefinitionRegistry already called on this post-processor against "</span> + registry);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"postProcessBeanFactory already called on this post-processor against "</span> + registry);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 表示此registry里的bd收集动作，已经做了  避免再重复收集此registry</span></span><br><span class="line">		<span class="keyword">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 根据配置类，收集到所有的bd信息</span></span><br><span class="line">		<span class="comment">// 并且做出mark标注：是Full模式还是Lite模式，和很重要很重要</span></span><br><span class="line">		processConfigBeanDefinitions(registry);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>执行完此方法，已经完成了bd的收集和标记，那接下来就是本文的主菜了：<strong>帮你解答上面case的结果</strong>。</p>
<hr>
<h3 id="postProcessBeanFactory"><a href="#postProcessBeanFactory" class="headerlink" title="postProcessBeanFactory()"></a>postProcessBeanFactory()</h3><p>此方法的作用用一句话可概括为：<strong>为Full模式的Bean使用CGLIB做字节码提升，确保最终生成的是代理类实例放进容器内</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConfigurationClassPostProcessor：</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> factoryId = System.identityHashCode(beanFactory);</span><br><span class="line">		<span class="comment">// 防止重复处理</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.factoriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"postProcessBeanFactory already called on this post-processor against "</span> + beanFactory);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.factoriesPostProcessed.add(factoryId);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 在执行postProcessBeanDefinitionRegistry方法的时就已经将</span></span><br><span class="line">		<span class="comment">// 这个id添加到registriesPostProcessed集合中了</span></span><br><span class="line">		<span class="comment">// 所以到这里就不会再重复执行配置类的解析了（解析@Import、@Bean等）</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.registriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line">			processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 从名字上看，这个方法应该就是为配置类创建代理用的喽</span></span><br><span class="line">		enhanceConfigurationClasses(beanFactory);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 添加了一个后置处理器 它是个SmartInstantiationAwareBeanPostProcessor</span></span><br><span class="line">		<span class="comment">// 它不是本文重点，略</span></span><br><span class="line">		beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ImportAwareBeanPostProcessor(beanFactory));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>达到这一步之前，已经完成了bd的收集和标记（见上一步）。对bd进行实例化之前，针对于<strong>Full模式的配置类</strong>这步骤里会做增强处理，那就是<code>enhanceConfigurationClasses(beanFactory)</code>这个方法。</p>
<hr>
<h3 id="enhanceConfigurationClasses-beanFactory"><a href="#enhanceConfigurationClasses-beanFactory" class="headerlink" title="enhanceConfigurationClasses(beanFactory)"></a>enhanceConfigurationClasses(beanFactory)</h3><p>对一个<code>BeanFactory</code>进行增强，先查找配置类<code>BeanDefinition</code>，再根据Bean定义信息（元数据信息）来决定配置类是否应该被<code>ConfigurationClassEnhancer</code>增强。具体处理代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConfigurationClassPostProcessor：</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enhanceConfigurationClasses</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 最终需要做增强的Bean定义们</span></span><br><span class="line">		Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (String beanName : beanFactory.getBeanDefinitionNames()) &#123;</span><br><span class="line">			BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);</span><br><span class="line">			Object configClassAttr = beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE);</span><br><span class="line">		</span><br><span class="line">			... <span class="comment">// 省略其它情况以及异常情况的处理代码</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 如果是Full模式，才会放进来</span></span><br><span class="line">			<span class="keyword">if</span> (ConfigurationClassUtils.CONFIGURATION_CLASS_FULL.equals(configClassAttr)) &#123;</span><br><span class="line">				configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (configBeanDefs.isEmpty()) &#123;</span><br><span class="line">			<span class="comment">// nothing to enhance -&gt; return immediately</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// ConfigurationClassEnhancer就是对配置类做增强操作的核心类，下面详解</span></span><br><span class="line">		ConfigurationClassEnhancer enhancer = <span class="keyword">new</span> ConfigurationClassEnhancer();</span><br><span class="line">		<span class="comment">// 对每个Full模式的配置类，一个个做enhance()增强处理</span></span><br><span class="line">		<span class="keyword">for</span> (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) &#123;</span><br><span class="line">			AbstractBeanDefinition beanDef = entry.getValue();</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 如果代理了@Configuration类，则始终代理目标类</span></span><br><span class="line">			<span class="comment">// 该属性和自动代理时是相关的，具体参见Spring的自动代理章节描述</span></span><br><span class="line">			beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// CGLIB是给父类生成子类对象的方式实现代理，所以这里指定“父类”类型</span></span><br><span class="line">			Class&lt;?&gt; configClass = beanDef.getBeanClass();</span><br><span class="line">			<span class="comment">// 做增强处理，返回enhancedClass就是一个增强过的子类</span></span><br><span class="line">			Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, <span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">			<span class="comment">// 不相等，证明代理成功，那就把实际类型设置进去</span></span><br><span class="line">			<span class="comment">// 这样后面实例化配置类的实例时，实际实例化的就是增强子类喽</span></span><br><span class="line">			<span class="keyword">if</span> (configClass != enhancedClass) &#123;</span><br><span class="line">				beanDef.setBeanClass(enhancedClass);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>值得注意的是，虽然此方法被设计为public的，但是只被一处使用到。Spring这么做是为了给提供钩子，方便容器开发者做扩展时使用</p>
</blockquote>
<p>步骤总结：</p>
<ol>
<li>从BeanFactory拿出所有的bd信息，一个个判断</li>
<li>如果是配置类<strong>并且是Full模式</strong>，就先存储起来，后面会对它做字节码提升。最终如果一个Full模式的配置类都木有，那直接return，此方法结束。否则继续</li>
<li>对收集到的<strong>每一个</strong> Full模式的配置类，使用<code>ConfigurationClassEnhancer</code>增强器进行字节码提升，生成一个CGLIB子类型<ol>
<li>小细节：此处显示标注了AOP自动代理为：<strong>始终代理目标类</strong></li>
</ol>
</li>
<li>把CGLIB生成的子类型设置到元数据里去：<code>beanDef.setBeanClass(enhancedClass)</code>。这样Spring在最后实例化Bean时，<strong>实际生成的是该代理类型的实例</strong>，从而达到代理/增强的目的</li>
</ol>
<p>该方法执行完成后，执行“结果”我截了张图，供以参考：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200517173547252.png#x160" alt=""><br>这段代码是不难的，理解起来十分简单。但是，我们仍旧还只知道结果，并不清楚原因。凭它还无法解释上文中两个case的现象，所以我们应该端正态度继续深入，看看<code>ConfigurationClassEnhancer</code>增强器到底做了什么事。</p>
<p><strong>在介绍<code>ConfigurationClassEnhancer</code>之前，希望你对CGLIB的使用有那么一定的了解，这样会轻松很多。当然不必过于深究（否则容易怀疑人生），但应该能知道如何使用<code>Enhancer</code>增强器去增强/代理目标类，如何写拦截器等。</strong></p>
<blockquote>
<p>因为之前文章介绍过了CGLIB的基本使用，限于篇幅，此处就不再啰嗦。</p>
</blockquote>
<hr>
<h2 id="ConfigurationClassEnhancer源码分析"><a href="#ConfigurationClassEnhancer源码分析" class="headerlink" title="ConfigurationClassEnhancer源码分析"></a>ConfigurationClassEnhancer源码分析</h2><p><strong>得打起精神了，因为接下来才是本文之精华，让你出彩的地方。</strong></p>
<p>@since 3.0。通过生成一个CGLIB子类来增强<code>@Configuration</code>类与Spring容器进行交互，每个这样的<code>@Bean</code>方法都会被生成的子类所复写。这样子当遇到方法调用时，才有可能通过拦截从而把方法调用引回容器，通过名称获得相应的Bean。</p>
<p>建立在对CGLIB的使用有一定了解的基础上，再来阅读本文会变得轻松许多。该类<strong>有且仅有一个</strong> public方法，如下所示：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200517211615826.png#x60" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConfigurationClassEnhancer：</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Class&lt;?&gt; enhance(Class&lt;?&gt; configClass, <span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">		<span class="comment">// 如果已经实现了该接口，证明已经被代理过了，直接返回呗~</span></span><br><span class="line">		<span class="keyword">if</span> (EnhancedConfiguration<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">configClass</span>)) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> configClass;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 若没被代理过。就先调用newEnhancer()方法创建一个增强器Enhancer</span></span><br><span class="line">		<span class="comment">// 然后在使用这个增强器，生成代理类字节码Class对象</span></span><br><span class="line">		Class&lt;?&gt; enhancedClass = createClass(newEnhancer(configClass, classLoader));</span><br><span class="line">		<span class="keyword">return</span> enhancedClass;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>巨简单有没有。</p>
<blockquote>
<p>为何Spring的源码是开源软件的范本？因为它各种封装、设计模式用得都非常好，甚至对初学者都是友好的，所以说Spring易学难精。</p>
</blockquote>
<p>该public方法的核心，在下面这两个个私有方法上。</p>
<hr>
<h3 id="newEnhancer-和createClass"><a href="#newEnhancer-和createClass" class="headerlink" title="newEnhancer()和createClass()"></a>newEnhancer()和createClass()</h3><p>创建一个新的CGLIB <code>Enhancer</code>实例，并且做好相应配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConfigurationClassEnhancer：</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Enhancer <span class="title">newEnhancer</span><span class="params">(Class&lt;?&gt; configSuperClass, @Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">		Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">		<span class="comment">// 目标类型：会以这个作为父类型来生成字节码子类</span></span><br><span class="line">		enhancer.setSuperclass(configSuperClass);</span><br><span class="line">		<span class="comment">// 让代理类实现EnhancedConfiguration接口，这个接口继承了BeanFactoryAware接口</span></span><br><span class="line">		enhancer.setInterfaces(<span class="keyword">new</span> Class&lt;?&gt;[] &#123;EnhancedConfiguration<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 设置生成的代理类不实现org.springframework.cglib.proxy.Factory接口</span></span><br><span class="line">		enhancer.setUseFactory(<span class="keyword">false</span>);</span><br><span class="line">		<span class="comment">// 设置代理类名称的生成策略：Spring定义的一个生成策略</span></span><br><span class="line">		<span class="comment">// 你名称中会有“BySpringCGLIB”字样</span></span><br><span class="line">		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">		enhancer.setStrategy(<span class="keyword">new</span> BeanFactoryAwareGeneratorStrategy(classLoader));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 设置拦截器/过滤器</span></span><br><span class="line">		enhancer.setCallbackFilter(CALLBACK_FILTER);</span><br><span class="line">		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());</span><br><span class="line">		<span class="keyword">return</span> enhancer;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用增强器生，成代理类的字节码对象</span></span><br><span class="line">	<span class="keyword">private</span> Class&lt;?&gt; createClass(Enhancer enhancer) &#123;</span><br><span class="line">		Class&lt;?&gt; subclass = enhancer.createClass();</span><br><span class="line">		Enhancer.registerStaticCallbacks(subclass, CALLBACKS);</span><br><span class="line">		<span class="keyword">return</span> subclass;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><code>Enhancer</code>是CGLIB的最核心API，通过方法名应该基本清楚了每一步都有什么作用吧。</p>
<blockquote>
<p><code>Enhancer</code>属于CGLIB的核心API，但你发现它的包名是<code>xxx.springframework.xxx</code> 。这是因为CGLIB在Spring内太常用了（强依赖），因此Spring索性就自己fork了一份代码过来~ </p>
</blockquote>
<p>本方法我们需要关注对<code>Enhancer</code>实例的<strong>配置</strong>，有如下关注点：</p>
<ul>
<li>通过它增强的每个类<strong>都实现了<code>EnhancedConfiguration</code>接口</strong>，并且它还是<code>BeanFactoryAware</code>的子接口<ul>
<li>统一实现接口，这和Spring AOP创建代理是不是如出一辙？想一想</li>
<li>实现了<code>BeanFactoryAware</code>接口，这样Spring在创建代理类实例的时候会给注入<code>BeanFactory</code></li>
</ul>
</li>
<li>使用<code>SpringNamingPolicy</code>策略来生成类名称。这就是解释了为何代理类的名你都能看到<strong>BySpringCGLIB</strong>字样</li>
<li>对于代理最为重要的当属过滤器/拦截器<code>org.springframework.cglib.proxy.Callback</code>，它们是实现功能的核心。配置此增强器时设置了<code>CALLBACK_FILTER</code>共三个拦截器</li>
</ul>
<p>关于<code>CALLBACK_FILTER</code>，我们发现在类<code>ConfigurationClassEnhancer</code>最开始处就申明了三个拦截器放进去了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConfigurationClassEnhancer：</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Callback[] CALLBACKS = <span class="keyword">new</span> Callback[] &#123;</span><br><span class="line">			<span class="keyword">new</span> BeanMethodInterceptor(),</span><br><span class="line">			<span class="keyword">new</span> BeanFactoryAwareMethodInterceptor(),</span><br><span class="line">			NoOp.INSTANCE</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<p>如果说前面都是做准备工作，那么拦截器才是运行期真正干活的“人”了。<strong>它能够解答我们今天的疑问~</strong></p>
<hr>
<h2 id="拦截器分析"><a href="#拦截器分析" class="headerlink" title="拦截器分析"></a>拦截器分析</h2><p>什么是动态代理？用通俗的话理解就是：<strong>代理的核心逻辑就是依赖于拦截器实现的</strong>，可见拦截器（也叫增强）之于代理类是何等重要。</p>
<p>上面的三个拦截器中，<code>NoOp.INSTANCE</code>代表什么都没做，因此我们只需要关注前两个。他俩均是<code>MethodInterceptor</code>接口的实现类，均实现了<code>intercept()</code>方法来做具体的拦截操作（他俩均是私有静态内部类哟）。</p>
<blockquote>
<p>说明：本文的两个case用第一个拦截器即可解释，鉴于第二个拦截器<strong>非常的复杂</strong>，所以我把它放在下篇文章详解（已写得差不多了，因为太复杂，篇幅比本文还长）</p>
</blockquote>
<hr>
<h3 id="BeanFactoryAwareMethodInterceptor"><a href="#BeanFactoryAwareMethodInterceptor" class="headerlink" title="BeanFactoryAwareMethodInterceptor"></a>BeanFactoryAwareMethodInterceptor</h3><p>顾名思义，它表示的是<code>BeanFactoryAware</code>方法的拦截器，所以靠猜应该能猜到它拦截的是<code>setBeanFactory(beanFactory)</code>方法。</p>
<blockquote>
<p>说明：Spring所有的拦截器实现的拦截都是方法级别的。虽然也支持构造器的拦截，但并没有内置实现，需要使用者自行扩展（比较复杂，一般并无使用场景）</p>
</blockquote>
<p>相较于下文要讲的第二个拦截器，这个拦截器比较简单。但是它实现的功能可不简约哦，因为它能够解释文首提出的两个case，<strong>让你谈薪更有底气</strong>。</p>
<p>既然是拦截器，就应该按如下两步去了解它：<strong>执行时机 + 做了何事</strong>。</p>
<hr>
<h3 id="执行时机"><a href="#执行时机" class="headerlink" title="执行时机"></a>执行时机</h3><p>执行时机决定了增强逻辑何时执行，毕竟一般来说都不可能是增强所有的嘛。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BeanFactoryAwareMethodInterceptor：</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 当执行到setBeanFactory(xxx)方法时匹配成功</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(Method candidateMethod)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> isSetBeanFactory(candidateMethod);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 此方法标记为public static 是因为下面这个拦截器也会用到</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSetBeanFactory</span><span class="params">(Method candidateMethod)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> (candidateMethod.getName().equals(<span class="string">"setBeanFactory"</span>) &amp;&amp;</span><br><span class="line">					candidateMethod.getParameterCount() == <span class="number">1</span> &amp;&amp;</span><br><span class="line">					BeanFactory<span class="class">.<span class="keyword">class</span> </span>== candidateMethod.getParameterTypes()[<span class="number">0</span>] &amp;&amp;</span><br><span class="line">					BeanFactoryAware<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">candidateMethod</span>.<span class="title">getDeclaringClass</span>()))</span>;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道<code>setBeanFactory()</code>方法是由Spring容器在初始化Bean时回调调用的，而代理类实现了<code>EnhancedConfiguration</code>接口（间接实现了<code>BeanFactoryAware</code>接口），所以该拦截器的执行时机为：<strong>在Spring初始化代理类实例时执行拦截</strong>。</p>
<blockquote>
<p>说明：isSetBeanFactory()判断方法做这么“复杂”主要是为了容错，“担心”你自己定义了一个名为<code>setBeanFactory</code>的方法而“搞错了”。</p>
</blockquote>
<hr>
<h3 id="做了何事"><a href="#做了何事" class="headerlink" title="做了何事"></a>做了何事</h3><p>作为一个拦截器，增强逻辑才是它的核心。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BeanFactoryAwareMethodInterceptor：</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="meta">@Nullable</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 找到本类（代理类）里名为`$$beanFactory`的字段</span></span><br><span class="line">			<span class="comment">// 若没找到直接报错。若找到了此字段，就给此字段赋值</span></span><br><span class="line">			Field field = ReflectionUtils.findField(obj.getClass(), BEAN_FACTORY_FIELD);</span><br><span class="line">			Assert.state(field != <span class="keyword">null</span>, <span class="string">"Unable to find generated BeanFactory field"</span>);</span><br><span class="line">			field.set(obj, args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果用户类（也就是你自己定义的类）自己实现了该接口，那么别担心，也会给你赋值上</span></span><br><span class="line">			<span class="keyword">if</span> (BeanFactoryAware<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">ClassUtils</span>.<span class="title">getUserClass</span>(<span class="title">obj</span>.<span class="title">getClass</span>().<span class="title">getSuperclass</span>()))) </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> proxy.invokeSuper(obj, args);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>从执行时机知道了，它拦截的是<code>setBeanFactory()</code>方法的执行。所以这里的Method就代表的是<code>setBeanFactory()</code>方法，<code>Object[] args</code>的值是<strong>当前容器的BeanFactory工厂</strong>（注意理解这句话）实例。</p>
<p>此拦截器增强完成后，结果截图如下：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200518210424274.png#x100" alt=""><br>好了，介绍到这里本文就先告一段落。如果你是认真的看完了本文的分析，那么现在你再“回到顶部”理解那两个case的结果，你就豁然开朗了。</p>
<blockquote>
<p>建议一定弄懂，我觉得已经很明朗了，所以就不再废话。若有不清楚，可以下方扫码加我微信私聊我吧（或者文末留言）</p>
</blockquote>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>又是一篇关于Spring配置类的长文，只希望对你有帮助才有意义。最为核心的两个增强/拦截器，迫于篇幅和读者的脑力（毕竟理解起来还是比较费劲的），今天只讲一个。我把另外一个<strong>更为重要、更为复杂、<code>更为多金</code>的部分放在了下文专文阐述</strong>，你可关注我公众号保持“收看”。</p>
<blockquote>
<p>下篇码字已经码得差不多了，80%吧。手累了，今天先休息，明天再搞，内容很精彩😄</p>
</blockquote>]]></content>
      <categories>
        <category>Spring配置类</category>
      </categories>
      <tags>
        <tag>Spring Framework</tag>
        <tag>@Configuration</tag>
      </tags>
  </entry>
  <entry>
    <title>配置类需要标注@Configuration却不知原因？那这次就不能给你涨薪喽</title>
    <url>/x2y/8e3281a7.html</url>
    <content><![CDATA[<blockquote>
<p>当大潮退去，才知道谁在裸泳。<br><strong>作者</strong>：A哥（YourBatman）<br><strong>公众号</strong>：BAT的乌托邦（ID：BAT-utopia）<br><strong>文末是否有彩蛋</strong>：有</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>各位小伙伴大家好，我是A哥。这是继上篇文章：<a href="https://mp.weixin.qq.com/s/rXy9T3VgWvdl6Kje1mwCZA" target="_blank" rel="noopener">真懂Spring的@Configuration配置类？你可能自我感觉太良好</a> 的原理/源码解释篇。按照本公众号的定位，原理一般跑不了，虽然很枯燥，但还得做，毕竟做难事必有所得，真的掌握了才有底气谈涨薪嘛。</p>
<p>Tips：鉴于经常有些同学无法区分某个功能/某项能力属于<code>Spring Framework</code>的还是<code>Spring Boot</code>，你可以参考文章里的【版本约定】目录，那里会说明本文的版本依赖，也就是功能所属喽。比如本文内容它就属于<code>Spring Framework</code>，和<code>Spring Boot</code>木有关系。</p>
<hr>
<h2 id="版本约定"><a href="#版本约定" class="headerlink" title="版本约定"></a>版本约定</h2><p>本文内容若没做特殊说明，均基于以下版本：</p>
<ul>
<li>JDK：<code>1.8</code></li>
<li>Spring Framework：<code>5.2.2.RELEASE</code></li>
</ul>
<hr>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>Spring的IoC就像个“大熔炉”，什么都当作Bean放在里面。然而，虽然它们都放在了一起，但是实际在功能上是有区别的，比如我们熟悉的<code>BeanPostProcessor</code>就属于后置处理器功能的Bean，还有本文要讨论的<code>@Configuration</code>配置Bean也属于一种特殊的组件。</p>
<p>判断一个Bean是否是<strong>Bean的后置处理器</strong>很方便，只需看它是否实现了<code>BeanPostProcessor</code>接口即可；那么如何去确定一个Bean是否是@Configuration配置Bean呢？若是，如何区分是Full模式还是Lite模式呢？这便就是本文将要讨论的内容。</p>
<hr>
<h2 id="如何判断一个组件是否是-Configuration配置？"><a href="#如何判断一个组件是否是-Configuration配置？" class="headerlink" title="如何判断一个组件是否是@Configuration配置？"></a>如何判断一个组件是否是@Configuration配置？</h2><p>首先需要明确：<code>@Configuration</code>配置前提必须是IoC管理的一个组件（也就是常说的Bean）。Spring使用<code>BeanDefinitionRegistry</code>注册中心管理着所有的Bean定义信息，那么对于这些Bean信息哪些属于<code>@Configuration</code>配置呢，这是需要甄选出来的。</p>
<p>判断一个Bean是否是<code>@Configuration</code>配置类这个逻辑统一交由<code>ConfigurationClassUtils</code>这个工具类去完成。</p>
<hr>
<h2 id="ConfigurationClassUtils工具类"><a href="#ConfigurationClassUtils工具类" class="headerlink" title="ConfigurationClassUtils工具类"></a>ConfigurationClassUtils工具类</h2><p>见名之意，它是和配置有关的一个工具类，提供几个静态工具方法供以使用。它是<code>Spring 3.1</code>新增，对于它的作用，官方给的解释是：用于标识<code>@Configuration</code>类的实用程序(Utilities)。它主要提供了一个方法：<code>checkConfigurationClassCandidate()</code>用于检查给定的Bean定义是否是配置类的候选对象（或者在配置/组件类中声明的嵌套组件类），<strong>并做相应的标记</strong>。</p>
<hr>
<h3 id="checkConfigurationClassCandidate"><a href="#checkConfigurationClassCandidate" class="headerlink" title="checkConfigurationClassCandidate()"></a>checkConfigurationClassCandidate()</h3><p>它是一个public static工具方法，用于判断某个Bean定义是否是<code>@Configuration</code>配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConfigurationClassUtils：</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkConfigurationClassCandidate</span><span class="params">(BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory)</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 根据Bean定义信息，拿到器对应的注解元数据</span></span><br><span class="line">		AnnotationMetadata metadata = xxx;</span><br><span class="line">		...</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 根据注解元数据判断该Bean定义是否是配置类。若是：那是Full模式还是Lite模式</span></span><br><span class="line">		Map&lt;String, Object&gt; config = metadata.getAnnotationAttributes(Configuration<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">		<span class="keyword">if</span> (config != <span class="keyword">null</span> &amp;&amp; !Boolean.FALSE.equals(config.get(<span class="string">"proxyBeanMethods"</span>))) &#123;</span><br><span class="line">			beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (config != <span class="keyword">null</span> || isConfigurationCandidate(metadata)) &#123;</span><br><span class="line">			beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		...</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 到这。它肯定是一个完整配置（Full or Lite） 这里进一步把@Order排序值放上去</span></span><br><span class="line">		Integer order = getOrder(metadata);</span><br><span class="line">		<span class="keyword">if</span> (order != <span class="keyword">null</span>) &#123;</span><br><span class="line">			beanDef.setAttribute(ORDER_ATTRIBUTE, order);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>步骤总结：</p>
<ol>
<li>根据Bean定义信息解析成为一个注解元数据对象<code>AnnotationMetadata metadata</code><ol>
<li>可能是个<code>AnnotatedBeanDefinition</code>，也可能是个<code>StandardAnnotationMetadata</code></li>
</ol>
</li>
<li>根据注解元数据metadata判断是否是个<code>@Configuration</code>配置类，有如下三种可能case：<ol>
<li>标注有<code>@Configuration</code>注解<strong>并且</strong>该注解的<code>proxyBeanMethods = false</code>，那么mark一下它是<strong>Full模式</strong>的配置。否则进入下一步判断</li>
<li>标注有<code>@Configuration</code>注解<strong>或者</strong>符合Lite模式的条件（上文有说一共有5种可能是Lite模式，源码处在<code>isConfigurationCandidate(metadata)</code>这个方法里表述），那么mark一下它是<strong>Lite模式</strong>的配置。否则进入下一步判断</li>
<li>不是配置类，并且返回结果<code>return false</code></li>
</ol>
</li>
<li>能进行到这一步，说明该Bean肯定是个配置类了（Full模式或者Lite模式），那就取出其<code>@Order</code>值（若有的话），然后mark进Bean定义里面去</li>
</ol>
<p><strong>这个mark动作很有意义：后面判断一个配置类是Full模式还是Lite模式，甚至判断它是否是个配置类均可通过<code>beanDef.getAttribute(CONFIGURATION_CLASS_ATTRIBUTE)</code>这样完成判断</strong>。</p>
<hr>
<h4 id="方法使用处"><a href="#方法使用处" class="headerlink" title="方法使用处"></a>方法使用处</h4><p>知晓了<code>checkConfigurationClassCandidate()</code>能够判断一个Bean(定义)是否是一个配置类，那么它在什么时候会被使用呢？通过查找可以发现它被如下两处使用到：</p>
<ul>
<li>使用处：<code>ConfigurationClassPostProcessor.processConfigBeanDefinitions()</code>处理配置Bean定义阶段。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConfigurationClassPostProcessor：</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 拿出当前所有的Bean定义信息，一个个的检查是否是配置类	</span></span><br><span class="line">		String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">		<span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">			BeanDefinition beanDef = registry.getBeanDefinition(beanName);</span><br><span class="line">			<span class="keyword">if</span> (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">				logger.debug(<span class="string">"Bean definition has already been processed as a configuration class: "</span> + beanDef);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 如果该Bean定义不是配置类，那就继续判断一次它是否是配置类，若是就加入结果集合里</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">				configCandidates.add(<span class="keyword">new</span> BeanDefinitionHolder(beanDef, beanName));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<code>ConfigurationClassPostProcessor</code>是个<code>BeanDefinitionRegistryPostProcessor</code>，会在<code>BeanFactory</code> <strong>准备好后</strong>执行生命周期方法。因此自然而然的，<code>checkConfigurationClassCandidate()</code>会在此阶段调用，用于区分出哪些是配置Bean。</li>
</ul>
<p><strong>值得注意的是</strong>：<code>ConfigurationClassPostProcessor</code>的执行时期是非常早期的（<code>BeanFactory</code>准备好后就执行嘛），这个时候容器内的Bean定义<strong>很少</strong>。这个时候只有<strong>主配置类</strong>才被注册了进来，那些想通过<code>@ComponentScan</code>扫进来的配置类都还没到“时间”，这个时间节点很重要，请注意区分。为了方便你理解，我分别把Spring和Spring Boot在此阶段的Bean定义信息截图展示如下：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200516172229283.png#x130" alt=""><br>以上是Spring环境，对应代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://img-blog.csdnimg.cn/20200516172449407.png#x130" alt=""><br>以上是Spring Boot环境，对应代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boot2Demo1Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Boot2Demo1Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>相比之下，Spring Boot里多了<code>internalCachingMetadataReaderFactory</code>这个Bean定义。原因是SB定义了一个<code>CachingMetadataReaderFactoryPostProcessor</code>把它放进去的，由于此Processor也是个<code>BeanDefinitionRegistryPostProcessor</code>并且order值为<code>Ordered.HIGHEST_PRECEDENCE</code>，所以它会优先于<code>ConfigurationClassPostProcessor</code>执行把它注册进去~</p>
</blockquote>
<ul>
<li>使用处：<code>ConfigurationClassParser.doProcessConfigurationClass()</code> <strong>解析</strong> <code>@Configuration</code>配置类阶段。所处的大阶段同上使用处，仍旧是<code>ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry()</code>阶段<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConfigurationClassParser：</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		... <span class="comment">// 先解析nested内部类（内部类会存在@Bean方法嘛~）</span></span><br><span class="line">		... <span class="comment">// 解析@PropertySource资源，加入到environment环境</span></span><br><span class="line">		... <span class="comment">// 解析@ComponentScan注解，把组件扫描进来</span></span><br><span class="line">		scannedBeanDefinitions = ComponentScanAnnotationParser.parse(componentScan, ...);</span><br><span class="line">			<span class="comment">// 把扫描到的Bean定义信息依旧需要一个个的判断，是否是配置类	</span></span><br><span class="line">			<span class="comment">// 若是配置类，就继续当作一个@Configuration配置类来解析parse() 递归嘛</span></span><br><span class="line">			<span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">				...</span><br><span class="line">				<span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">					parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		... <span class="comment">// 解析@Import注解</span></span><br><span class="line">		... <span class="comment">// 解析@ImportResource注解</span></span><br><span class="line">		... <span class="comment">// 解析当前配置里配置的@Bean方法</span></span><br><span class="line">		... <span class="comment">// 解析接口默认方法（因为配置类可能实现接口，然后接口默认方法可能标注有@Bean ）</span></span><br><span class="line">		... <span class="comment">// 处理父类（递归，直到父类为java.打头的为止）</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
这个方法是Spring对配置类解析的<strong>最核心步骤</strong>，通过它顺带也能够解答你的疑惑了吧：为何你仅需在类上标注一个<code>@Configuration</code>注解即可让它成为一个配置类？因为被Scan扫描进去了嘛~</li>
</ul>
<p>通过以上<strong>两个使用处</strong>的分析和对比，对于<code>@Configuration</code>配置类的理解，你至少应该掌握了如下讯息：</p>
<ol>
<li><code>@Configuration</code>配置类肯定是个组件，存在于IoC容器里</li>
<li><code>@Configuration</code>配置类是<strong>有主次之分</strong>的，主配置类是驱动整个程序的入口，可以是一个，也可以是多个（若存在多个，支持使用@Order排序）</li>
<li>我们平时一般只书写<strong>次配置类</strong>（而且一般写多个），它<strong>一般</strong>是借助主配置类的<code>@ComponentScan</code>能力完成加载进而解析的（当然也可能是<code>@Import</code>、又或是被其它次配置类驱动的）</li>
<li>配置类可以存在嵌套（如内部类），继承，实现接口等特性</li>
</ol>
<p>聊完了最为重要的<code>checkConfigurationClassCandidate()</code>方法，当然还有必要看看<code>ConfigurationClassUtils</code>的另一个工具方法<code>isConfigurationCandidate()</code>。</p>
<hr>
<h3 id="isConfigurationCandidate"><a href="#isConfigurationCandidate" class="headerlink" title="isConfigurationCandidate()"></a>isConfigurationCandidate()</h3><p>它是一个public static工具方法，通过给定的注解元数据信息来判断它是否是一个<code>Configuration</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConfigurationClassUtils：</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		candidateIndicators.add(Component<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">		candidateIndicators.add(ComponentScan<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">		candidateIndicators.add(Import<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">		candidateIndicators.add(ImportResource<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isConfigurationCandidate</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 不考虑接口 or 注解 说明：注解的话也是一种“特殊”的接口哦</span></span><br><span class="line">		<span class="keyword">if</span> (metadata.isInterface()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 只要该类上标注有以上4个注解任意一个，都算配置类</span></span><br><span class="line">		<span class="keyword">for</span> (String indicator : candidateIndicators) &#123;</span><br><span class="line">			<span class="keyword">if</span> (metadata.isAnnotated(indicator)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 若一个注解都没标注，那就看有木有@Bean方法 若有那也算配置类</span></span><br><span class="line">		<span class="keyword">return</span> metadata.hasAnnotatedMethods(Bean<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>步骤总结：</p>
<ol>
<li>若是接口类型（含注解类型），直接不予考虑，返回false。否则继续判断</li>
<li>若此类上标注有<code>@Component、@ComponentScan、@Import、@ImportResource</code>任意一个注解，就判断成功返回true。否则继续判断</li>
<li>到此步，就说明<strong>此类上没有标注任何注解</strong>。若存在@Bean方法，返回true，否则返回false。</li>
</ol>
<p><strong>需要特别特别特别注意的是：此方法它的并不考虑<code>@Configuration</code>注解，是“轻量级”判断，这是它和<code>checkConfigurationClassCandidate()</code>方法的最主要区别</strong>。当然，后者依赖于前者，依赖它来根据注解元数据判断是否是Lite模式的配置。</p>
<hr>
<h2 id="Spring-5-2-0版本变化说明"><a href="#Spring-5-2-0版本变化说明" class="headerlink" title="Spring 5.2.0版本变化说明"></a>Spring 5.2.0版本变化说明</h2><p>因为本文的讲解和代码均是基于<code>Spring 5.2.2.RELEASE</code>的，而并不是所有小伙伴都会用到这么新的版本。关于此部分的实现，以Spring 5.2.0版本为分界线实现上有些许差异，所以在此处做出说明。</p>
<hr>
<h3 id="proxyBeanMethods属性的作用"><a href="#proxyBeanMethods属性的作用" class="headerlink" title="proxyBeanMethods属性的作用"></a>proxyBeanMethods属性的作用</h3><p><code>proxyBeanMethods</code>属性是Spring 5.2.0版本为<code>@Configuration</code>注解新增加的一个属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Configuration &#123;</span><br><span class="line">	<span class="meta">@AliasFor</span>(annotation = Component<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">	String value() default "";</span><br><span class="line">	<span class="comment">// @since 5.2</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的作用是：是否允许代理@Bean方法。说白了：决定此配置使用Full模式还是Lite模式。为了保持向下兼容，<code>proxyBeanMethods</code>的默认值是true，使用Full模式配置。</p>
<p>Spring 5.2提出了这个属性项，是期望你在已经了解了它的作用之后，显示的把它置为false的，因为在云原生将要到来的今天，启动速度方面Spring一直在做着努力，也希望你能配合嘛。这不<code>Spring Boot</code>就“配合”得很好，它在2.2.0版本（依赖于Spring 5.2.0）起就把它的所有的自动配置类的此属性改为了false，即<code>@Configuration(proxyBeanMethods = false)</code>。</p>
<hr>
<h3 id="Full模式-Lite模式实现上的差异"><a href="#Full模式-Lite模式实现上的差异" class="headerlink" title="Full模式/Lite模式实现上的差异"></a>Full模式/Lite模式实现上的差异</h3><p>由于Spring 5.2.0新增了<code>proxyBeanMethods</code>属性来控制模式，因此实现上也有些许诧异，请各位注意甄别：</p>
<p>Spring 5.2.0+版本判断实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConfigurationClassUtils：</span><br><span class="line"></span><br><span class="line">		Map&lt;String, Object&gt; config = metadata.getAnnotationAttributes(Configuration<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">		<span class="keyword">if</span> (config != <span class="keyword">null</span> &amp;&amp; !Boolean.FALSE.equals(config.get(<span class="string">"proxyBeanMethods"</span>))) &#123;</span><br><span class="line">			beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (config != <span class="keyword">null</span> || isConfigurationCandidate(metadata)) &#123;</span><br><span class="line">			beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>Spring 5.2.0-版本判断实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConfigurationClassUtils：</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (isFullConfigurationCandidate(metadata)) &#123;</span><br><span class="line">			beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLiteConfigurationCandidate(metadata)) &#123;</span><br><span class="line">			beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="思考题？"><a href="#思考题？" class="headerlink" title="思考题？"></a>思考题？</h2><ol>
<li>既然<code>isConfigurationCandidate()</code>判断方法是为<code>checkConfigurationClassCandidate()</code>服务，那Spring为何也把它设计为public static呢？</li>
<li><code>ConfigurationClassUtils</code>里还存在对<code>@Order</code>顺序的解析方法，不是说Spring的Bean是无序的吗？这又如何理解呢？</li>
</ol>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文作为<a href="https://mp.weixin.qq.com/s/rXy9T3VgWvdl6Kje1mwCZA" target="_blank" rel="noopener">上篇文章</a>的续篇，解释了@Configuration配置的Full模式和Lite模式的判断原理，同时顺带的也介绍了什么叫<strong>主配置配和次配置类</strong>，这个概念（虽然官方并不这么叫）对你理解Spring Framework是非常有帮助的。如果你使用是基于Spring 5.2.0+的版本，在了解了这两篇文章内容的基础上，建议你的配置类均采用Lite模式去做，即显示设置<code>proxyBeanMethods = false</code>。</p>
<p>另外关于此部分内容，有些更为感兴趣的小伙伴问到：为什么Full模式下通过方法调用指向的仍旧是原来的Bean，保证了只会执行一次呢？开启的是Full模式这只是表象原因，想要回答此问题需要<strong>涉及到CGLIB增强实现的深水区</strong>内容，为了满足这些好奇（好学）的娃子，计划会在下篇文章继续再拿一篇专程讲解（预计篇幅不短，万字以上），你可订阅我的公众号持续保持关注。</p>]]></content>
      <categories>
        <category>Spring配置类</category>
      </categories>
      <tags>
        <tag>Spring Framework</tag>
        <tag>@Configuration</tag>
      </tags>
  </entry>
  <entry>
    <title>真懂Spring的@Configuration配置类？你可能自我感觉太良好</title>
    <url>/x2y/e097f687.html</url>
    <content><![CDATA[<blockquote>
<p>当大潮退去，才知道谁在裸泳。<br><strong>作者</strong>：A哥（YourBatman）<br><strong>公众号</strong>：BAT的乌托邦（ID：BAT-utopia）<br><strong>文末是否有彩蛋</strong>：有</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>各位小伙伴大家好，我是A哥。这是一篇“插队”进来的文章，源于我公众号下面的这句评论：<br><img data-src="https://img-blog.csdnimg.cn/20200514195046147.png#x130" alt=""><br>官方管这两种模式分别叫：<code>Full @Configuration</code>和<code>lite @Bean mode</code>，口语上我习惯把它称为Spring配置的Full模式和Lite模式更易沟通。</p>
<p>的确，我很简单的“调研”了一下，知晓Spring配置中<code>Lite模式</code>和<code>Full模式</code>的几乎没有（或者说真的很少吧）。按照我之前的理论，大多人都不知道的技术（知识点）那肯定是不流行的。但是：<strong>不流行不代表不重要，不流行不代表不值钱，毕竟高薪往往只有少数人才能拥有。</strong></p>
<blockquote>
<p>什么OPP、OOP、AOP编程，其实我最喜欢的和推崇的是<strong>面向工资编程</strong>。当然前提是够硬（收回你邪恶的笑容），没有金刚钻，不揽瓷器活。</p>
</blockquote>
<p>听我这么一忽悠，是不是对这块内容还饶有兴味了，这不它来了嘛。</p>
<hr>
<h2 id="版本约定"><a href="#版本约定" class="headerlink" title="版本约定"></a>版本约定</h2><p>本文内容若没做特殊说明，均基于以下版本：</p>
<ul>
<li>JDK：<code>1.8</code></li>
<li>Spring Framework：<code>5.2.2.RELEASE</code></li>
</ul>
<hr>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>最初的Spring只支持xml方式配置Bean，从<code>Spring 3.0</code>起支持了一种更优的方式：基于Java类的配置方式，这一下子让我们Javaer可以从标签语法里解放了出来。毕竟作为Java程序员，我们擅长的是写Java类，而非用标签语言去写xml文件。</p>
<p>我对Spring配置的Full/Lite模式的关注和记忆深刻，源自于一个小小故事：某一年我在看公司的项目时发现，数据源配置类里有如下一段配置代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	...</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"transactionManager"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">transactionManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource());</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为当时还是<strong>Java萌新</strong>的我，非常的费解。自然的对此段代码产生了较大的好奇（其实是质疑）：在准备<code>DataSourceTransactionManager</code>这个Bean时调用了<code>dataSource()</code>方法，根据我“非常扎实”的JavaSE基础知识，它肯定会重新走一遍<code>dataSource()</code>方法，从而产生一个新的数据源实例，那么你的事务管理器管理的不就是一个“全新数据源”麽？谈何事务呢？</p>
<p>为了验证我的猜想，我把断点打到<code>dataSource()</code>方法内部开始调试，但让我“失望”的是：<strong>此方法并没有执行两次</strong>。这在当时是震惊了我的，甚至一度怀疑自己引以为豪的Java基础了。所以我四处询问，希望得到一个“解释”，但奈何，问了好几圈，那会没有一人能给我一个合理的说法，只知道那么用是没有问题的。</p>
<p>很明显，现在再回头来看当时的这个质疑是显得有些“无知”的，这个“难题”困扰了我很久，直到我前2年开始深度研究Spring源码才让此难题迎刃而解，当时那种豁然开朗的感觉真好呀。<br><img data-src="https://img-blog.csdnimg.cn/20200514200833775.jpg#x230" alt=""></p>
<hr>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>关于配置类的核心概念，在这里先予以解释。</p>
<h3 id="Configuration和-Bean"><a href="#Configuration和-Bean" class="headerlink" title="@Configuration和@Bean"></a>@Configuration和@Bean</h3><p>Spring新的配置体系中最为重要的构件是：<code>@Configuration</code>标注的类，<code>@Bean</code>标注的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @since 3.0</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Configuration &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@AliasFor</span>(annotation = Component<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">	String value() default "";</span><br><span class="line">	<span class="comment">// @since 5.2</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用<code>@Configuration</code>注解标注的类表明其主要目的是作为bean定义的<strong>源</strong>。此外，<code>@Configuration</code>类允许通过调用同一类中的其他<code>@Bean</code> method方法来定义bean之间的依赖关系（下有详解）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @since 3.0</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Bean &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@AliasFor</span>(<span class="string">"name"</span>)</span><br><span class="line">	String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">	<span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">	String[] name() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">	<span class="meta">@Deprecated</span></span><br><span class="line">	<span class="function">Autowire <span class="title">autowire</span><span class="params">()</span> <span class="keyword">default</span> Autowire.NO</span>;</span><br><span class="line">	<span class="comment">// @since 5.1</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">autowireCandidate</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">	<span class="function">String <span class="title">initMethod</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">	<span class="function">String <span class="title">destroyMethod</span><span class="params">()</span> <span class="keyword">default</span> AbstractBeanDefinition.INFER_METHOD</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Bean</code>注解标注在方法上，用于指示方法实例化、配置和初始化要由Spring IoC容器管理的新对象。对于熟悉Spring的<code>&lt;beans/&gt;</code>XML配置的人来说，<code>@Bean</code>注解的作用与<code>&lt;bean/&gt;</code>元素相同。您可以对任何Spring的@Component组件使用<code>@Bean</code>注释的方法代替（注意：这是理论上，实际上比如使用@Controller标注的组件就不能直接使用它代替）。</p>
<p>需要注意的是，通常来说，我们均会把<code>@Bean</code>标注的方法写在<code>@Configuration</code>标注的类里面来配合使用。</p>
<blockquote>
<p>简单粗暴理解：<code>@Configuration</code>标注的类等同于一个xml文件，<code>@Bean</code>标注的方法等同于xml文件里的一个<code>&lt;bean/&gt;</code>标签</p>
</blockquote>
<hr>
<h4 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"A哥"</span>);</span><br><span class="line">        user.setAge(<span class="number">18</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        User user = context.getBean(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(user.getClass());</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">yourbatman</span>.<span class="title">fullliteconfig</span>.<span class="title">User</span></span></span><br><span class="line"><span class="class"><span class="title">User</span></span>&#123;name=<span class="string">'A哥'</span>, age=<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Full模式和Lite模式"><a href="#Full模式和Lite模式" class="headerlink" title="Full模式和Lite模式"></a>Full模式和Lite模式</h2><p><strong>Full模式和Lite模式均是针对于Spring配置类而言的</strong>，和xml配置文件无关。值得注意的是：判断是Full模式 or Lite模式的前提是，首先你得是个容器组件。至于一个实例是如何“晋升”成为容器组件的，可以用注解也可以没有注解，本文就不展开讨论了，这属于Spring的基础知识。</p>
<hr>
<h2 id="Lite模式"><a href="#Lite模式" class="headerlink" title="Lite模式"></a>Lite模式</h2><p>当<code>@Bean</code>方法在没有使用<code>@Configuration</code>注释的类中声明时，它们被称为<strong>在Lite模式下处理</strong>。它包括：在<code>@Component</code>中声明的<code>@Bean</code>方法，甚至只是在一个非常普通的类中声明的Bean方法，都被认为是Lite版的配置类。<code>@Bean</code>方法是一种通用的工厂方法（<code>factory-method</code>）机制。</p>
<p>和Full模式的<code>@Configuration</code>不同，Lite模式的<code>@Bean</code>方法<strong>不能声明Bean之间的依赖关系</strong>。因此，这样的<code>@Bean</code>方法<strong>不应该调用其他@Bean方法</strong>。每个这样的方法实际上<strong>只是一个特定Bean引用的工厂方法(factory-method)</strong>，没有任何特殊的运行时语义。</p>
<hr>
<h3 id="何时为Lite模式"><a href="#何时为Lite模式" class="headerlink" title="何时为Lite模式"></a>何时为Lite模式</h3><p>官方定义为：在没有标注<code>@Configuration</code>的类里面有<code>@Bean</code>方法就称为Lite模式的配置。透过源码再看这个定义是不完全正确的，而应该是有如下case均认为是Lite模式的配置类：</p>
<ol>
<li>类上标注有<code>@Component</code>注解</li>
<li>类上标注有<code>@ComponentScan</code>注解</li>
<li>类上标注有<code>@Import</code>注解</li>
<li>类上标注有<code>@ImportResource</code>注解</li>
<li><strong>若类上没有任何注解</strong>，但类内存在@Bean方法</li>
</ol>
<p>以上case的前提均是类上没有被标注<code>@Configuration</code>，在<strong>Spring 5.2之后</strong>新增了一种case也算作Lite模式：</p>
<ol start="6">
<li>标注有<code>@Configuration(proxyBeanMethods = false)</code>，注意：此值默认是true哦，需要显示改为false才算是Lite模式</li>
</ol>
<p>细心的你会发现，自Spring5.2（对应Spring Boot 2.2.0）开始，内置的几乎所有的<code>@Configuration</code>配置类都被修改为了<code>@Configuration(proxyBeanMethods = false)</code>，目的何为？答：以此来降低启动时间，为Cloud Native继续做准备。</p>
<hr>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点</strong>：</p>
<ul>
<li>运行时不再需要给对应类生成CGLIB子类，提高了运行性能，降低了启动时间</li>
<li>可以该配置类当作一个普通类使用喽：也就是说@Bean方法 <strong>可以是private、可以是final</strong></li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>不能声明@Bean之间的依赖，也就是说不能通过方法调用来依赖其它Bean</li>
<li>（其实这个缺点还好，很容易用其它方式“弥补”，比如：把依赖Bean放进方法入参里即可）</li>
</ul>
<hr>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>主配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.yourbatman.fullliteconfig.liteconfig"</span>)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>准备一个Lite模式的配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">// @Configuration(proxyBeanMethods = false) // 这样也是Lite模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiteConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"A哥-lite"</span>);</span><br><span class="line">        user.setAge(<span class="number">18</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> User <span class="title">user2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"A哥-lite2"</span>);</span><br><span class="line">        user.setAge(<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟依赖于user实例  看看是否是同一实例</span></span><br><span class="line">        System.out.println(System.identityHashCode(user()));</span><br><span class="line">        System.out.println(System.identityHashCode(user()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="comment">// private final User userInner() &#123; // 只在lite模式下才好使</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">userInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            User user = <span class="keyword">new</span> User();</span><br><span class="line">            user.setName(<span class="string">"A哥-lite-inner"</span>);</span><br><span class="line">            user.setAge(<span class="number">18</span>);</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置类情况</span></span><br><span class="line">        System.out.println(context.getBean(LiteConfig<span class="class">.<span class="keyword">class</span>).<span class="title">getClass</span>())</span>;</span><br><span class="line">        System.out.println(context.getBean(LiteConfig.InnerConfig<span class="class">.<span class="keyword">class</span>).<span class="title">getClass</span>())</span>;</span><br><span class="line"></span><br><span class="line">        String[] beanNames = context.getBeanNamesForType(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">            User user = context.getBean(beanName, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            System.out.println(<span class="string">"beanName:"</span> + beanName);</span><br><span class="line">            System.out.println(user.getClass());</span><br><span class="line">            System.out.println(user);</span><br><span class="line">            System.out.println(<span class="string">"------------------------"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1100767002</span></span><br><span class="line"><span class="number">313540687</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">yourbatman</span>.<span class="title">fullliteconfig</span>.<span class="title">liteconfig</span>.<span class="title">LiteConfig</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">com</span>.<span class="title">yourbatman</span>.<span class="title">fullliteconfig</span>.<span class="title">liteconfig</span>.<span class="title">LiteConfig</span>$<span class="title">InnerConfig</span></span></span><br><span class="line">beanName:userInner</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">yourbatman</span>.<span class="title">fullliteconfig</span>.<span class="title">User</span></span></span><br><span class="line"><span class="class"><span class="title">User</span></span>&#123;name=<span class="string">'A哥-lite-inner'</span>, age=<span class="number">18</span>&#125;</span><br><span class="line">------------------------</span><br><span class="line">beanName:user</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">yourbatman</span>.<span class="title">fullliteconfig</span>.<span class="title">User</span></span></span><br><span class="line"><span class="class"><span class="title">User</span></span>&#123;name=<span class="string">'A哥-lite'</span>, age=<span class="number">18</span>&#125;</span><br><span class="line">------------------------</span><br><span class="line">beanName:user2</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">yourbatman</span>.<span class="title">fullliteconfig</span>.<span class="title">User</span></span></span><br><span class="line"><span class="class"><span class="title">User</span></span>&#123;name=<span class="string">'A哥-lite2'</span>, age=<span class="number">18</span>&#125;</span><br><span class="line">------------------------</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><ul>
<li>该模式下，配置类本身不会被CGLIB增强，放进IoC容器内的就是本尊</li>
<li>该模式下，对于内部类是没有限制的：可以是Full模式或者Lite模式</li>
<li>该模式下，配置类内部<strong>不能通过方法调用</strong>来处理依赖，否则每次生成的都是一个新实例而并非IoC容器内的单例</li>
<li>该模式下，配置类就是一普通类嘛，所以@Bean方法可以使用<code>private/final</code>等进行修饰（static自然也是阔仪的）</li>
</ul>
<hr>
<h2 id="Full模式"><a href="#Full模式" class="headerlink" title="Full模式"></a>Full模式</h2><p>在常见的场景中，<code>@Bean</code>方法都会在标注有<code>@Configuration</code>的类中声明，以确保总是使用“Full模式”，这么一来，交叉方法引用会被重定向到容器的生命周期管理，所以就可以更方便的管理Bean依赖。</p>
<hr>
<h3 id="何时为Full模式"><a href="#何时为Full模式" class="headerlink" title="何时为Full模式"></a>何时为Full模式</h3><p>标注有<code>@Configuration</code>注解的类被称为full模式的配置类。自Spring5.2后这句话改为下面这样我觉得更为精确些：</p>
<ul>
<li>标注有<code>@Configuration</code>或者<code>@Configuration(proxyBeanMethods = true)</code>的类被称为Full模式的配置类</li>
<li>（当然喽，proxyBeanMethods属性的默认值是true，所以一般需要Full模式我们只需要标个注解即可）</li>
</ul>
<hr>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点</strong>：</p>
<ul>
<li>可以支持通过常规Java调用相同类的@Bean方法而保证是容器内的Bean，这有效规避了在“Lite模式”下操作时难以跟踪的细微错误。特别对于萌新程序员，这个特点很有意义</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>运行时会给该类生成一个CGLIB子类放进容器，有一定的性能、时间开销（这个开销在Spring Boot这种拥有大量配置类的情况下是不容忽视的，这也是为何Spring 5.2新增了<code>proxyBeanMethods</code>属性的最直接原因）</li>
<li>正因为被代理了，所以@Bean方法 <strong>不可以是private、不可以是final</strong></li>
</ul>
<hr>
<h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><p>主配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.yourbatman.fullliteconfig.fullconfig"</span>)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>准备一个Full模式的配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FullConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"A哥-lite"</span>);</span><br><span class="line">        user.setAge(<span class="number">18</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> User <span class="title">user2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"A哥-lite2"</span>);</span><br><span class="line">        user.setAge(<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟依赖于user实例  看看是否是同一实例</span></span><br><span class="line">        System.out.println(System.identityHashCode(user()));</span><br><span class="line">        System.out.println(System.identityHashCode(user()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="comment">// private final User userInner() &#123; // 只在lite模式下才好使</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">userInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            User user = <span class="keyword">new</span> User();</span><br><span class="line">            user.setName(<span class="string">"A哥-lite-inner"</span>);</span><br><span class="line">            user.setAge(<span class="number">18</span>);</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置类情况</span></span><br><span class="line">        System.out.println(context.getBean(FullConfig<span class="class">.<span class="keyword">class</span>).<span class="title">getClass</span>())</span>;</span><br><span class="line">        System.out.println(context.getBean(FullConfig.InnerConfig<span class="class">.<span class="keyword">class</span>).<span class="title">getClass</span>())</span>;</span><br><span class="line"></span><br><span class="line">        String[] beanNames = context.getBeanNamesForType(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">            User user = context.getBean(beanName, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            System.out.println(<span class="string">"beanName:"</span> + beanName);</span><br><span class="line">            System.out.println(user.getClass());</span><br><span class="line">            System.out.println(user);</span><br><span class="line">            System.out.println(<span class="string">"------------------------"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">550668305</span></span><br><span class="line"><span class="number">550668305</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">yourbatman</span>.<span class="title">fullliteconfig</span>.<span class="title">fullconfig</span>.<span class="title">FullConfig</span>$$<span class="title">EnhancerBySpringCGLIB</span>$$70<span class="title">a94a63</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">com</span>.<span class="title">yourbatman</span>.<span class="title">fullliteconfig</span>.<span class="title">fullconfig</span>.<span class="title">FullConfig</span>$<span class="title">InnerConfig</span></span></span><br><span class="line">beanName:userInner</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">yourbatman</span>.<span class="title">fullliteconfig</span>.<span class="title">User</span></span></span><br><span class="line"><span class="class"><span class="title">User</span></span>&#123;name=<span class="string">'A哥-lite-inner'</span>, age=<span class="number">18</span>&#125;</span><br><span class="line">------------------------</span><br><span class="line">beanName:user</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">yourbatman</span>.<span class="title">fullliteconfig</span>.<span class="title">User</span></span></span><br><span class="line"><span class="class"><span class="title">User</span></span>&#123;name=<span class="string">'A哥-lite'</span>, age=<span class="number">18</span>&#125;</span><br><span class="line">------------------------</span><br><span class="line">beanName:user2</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">yourbatman</span>.<span class="title">fullliteconfig</span>.<span class="title">User</span></span></span><br><span class="line"><span class="class"><span class="title">User</span></span>&#123;name=<span class="string">'A哥-lite2'</span>, age=<span class="number">18</span>&#125;</span><br><span class="line">------------------------</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h3><ul>
<li>该模式下，配置类会被CGLIB增强(生成代理对象)，放进IoC容器内的是代理</li>
<li>该模式下，对于内部类是没有限制的：可以是Full模式或者Lite模式</li>
<li>该模式下，配置类内部<strong>可以通过方法调用</strong>来处理依赖，并且能够保证是同一个实例，都指向IoC内的那个单例</li>
<li>该模式下，@Bean方法不能被<code>private/final</code>等进行修饰（很简单，因为方法需要被复写嘛，所以不能私有和final。defualt/protected/public都可以哦），否则启动报错（其实IDEA编译器在编译器就提示可以提示你了）：</li>
</ul>
<p><img data-src="https://img-blog.csdnimg.cn/20200515083438511.png#x110" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> org.springframework.beans.factory.parsing.BeanDefinitionParsingException: Configuration problem: <span class="meta">@Bean</span> method <span class="string">'user2'</span> must not be <span class="keyword">private</span> or <span class="keyword">final</span>; change the method<span class="string">'s modifiers to continue</span></span><br><span class="line"><span class="string">Offending resource: class path resource [com/yourbatman/fullliteconfig/fullconfig/FullConfig.class]</span></span><br><span class="line"><span class="string">	at org.springframework.beans.factory.parsing.FailFastProblemReporter.error(FailFastProblemReporter.java:72)</span></span><br><span class="line"><span class="string">	at org.springframework.context.annotation.BeanMethod.validate(BeanMethod.java:50)</span></span><br><span class="line"><span class="string">	at org.springframework.context.annotation.ConfigurationClass.validate(ConfigurationClass.java:220)</span></span><br><span class="line"><span class="string">	at org.springframework.context.annotation.ConfigurationClassParser.validate(ConfigurationClassParser.java:211)</span></span><br><span class="line"><span class="string">	at org.springframework.context.annotation.ConfigurationClassPostProcessor.processConfigBeanDefinitions(ConfigurationClassPostProcessor.java:326)</span></span><br><span class="line"><span class="string">	at org.springframework.context.annotation.ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(ConfigurationClassPostProcessor.java:242)</span></span><br><span class="line"><span class="string">	at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(PostProcessorRegistrationDelegate.java:275)</span></span><br><span class="line"><span class="string">	at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(PostProcessorRegistrationDelegate.java:95)</span></span><br><span class="line"><span class="string">	at org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors(AbstractApplicationContext.java:706)</span></span><br><span class="line"><span class="string">	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:532)</span></span><br><span class="line"><span class="string">	at org.springframework.context.annotation.AnnotationConfigApplicationContext.&lt;init&gt;(AnnotationConfigApplicationContext.java:89)</span></span><br><span class="line"><span class="string">	at com.yourbatman.fullliteconfig.Application.main(Application.java:11)</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><p>了解了Spring配置类的Full模式和Lite模式，那么在工作中我该如何使用呢？这里A哥给出使用建议，仅供参考：</p>
<ul>
<li>如果是在公司的业务功能/服务上做开发，使用Full模式</li>
<li>如果你是个容器开发者，或者你在开发中间件、通用组件等，那么使用Lite模式是一种更被推荐的方式，它对Cloud Native更为友好</li>
</ul>
<hr>
<h2 id="思考题？"><a href="#思考题？" class="headerlink" title="思考题？"></a>思考题？</h2><p>通过<code>new AnnotationConfigApplicationContext(AppConfig.class)</code>直接放进去的类，它会成为一个IoC的组件吗？若会，那么它是Full模式 or Lite模式呢？是个固定的结果还是也和其标注的注解有关呢？</p>
<p>本思考题不难，自己试验一把便知，建议多动手~</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文结合代码示例阐述了Spring配置中Full模式和Lite模式，以及各自的定义和优缺点。对于一般的小伙伴，掌握本文就够用了，并且足够你面试中吹x。但A哥系列文章一般不止于“表面”嘛，<strong>下篇文章</strong>将从原理层面告诉你Spring是如何来巧妙的处理这两种模式的，特别是会结合<code>Spring 5.2.0</code>新特性，以及对比<code>Spring 5.2.0</code>的实现和<strong>之前版本</strong>有何不同，你课订阅我的公众号保持关注。</p>]]></content>
      <categories>
        <category>Spring配置类</category>
      </categories>
      <tags>
        <tag>Spring Framework</tag>
        <tag>@Configuration</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-4-17群福利：腾讯云+社区公仔寄送公示</title>
    <url>/x2y/tencent+.html</url>
    <content><![CDATA[<p>2020-4-17群福利，本次群福利，我通过问卷一共收集到200个左右的报名，最后大大小小共送出80个腾讯公仔。公仔有大有小，随机发送，<code>全免费的公益寄送</code>，就当是A哥帮大家争取到的一点小小小小福利喽，小小礼物不成敬意~</p>
<h3 id="筛选规则"><a href="#筛选规则" class="headerlink" title="筛选规则"></a>筛选规则</h3><ul>
<li>去除掉没填电话的</li>
<li>去除掉没填地址的</li>
<li>去除掉电话、地址不完整，没法完成发货的</li>
<li>去除掉没填写微信昵称的</li>
</ul>
<p>最终剩下的，采用随机方式生成序号，生成代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>);</span><br><span class="line">        result.add(index);</span><br><span class="line">        <span class="keyword">if</span> (result.size() &gt;= <span class="number">80</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"获奖序号："</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>腾讯公仔小礼物在五一期间寄出。名单公示如下（只展示微信昵称）：</p>
<table>
<thead>
<tr>
<th>微信昵称</th>
</tr>
</thead>
<tbody><tr>
<td>xdonex</td>
</tr>
<tr>
<td>thpend</td>
</tr>
<tr>
<td>Neverland</td>
</tr>
<tr>
<td>王波波。????</td>
</tr>
<tr>
<td>全全</td>
</tr>
<tr>
<td>大牛</td>
</tr>
<tr>
<td>猫咪老师</td>
</tr>
<tr>
<td>Zouch</td>
</tr>
<tr>
<td>sunxin</td>
</tr>
<tr>
<td>陈倚刚</td>
</tr>
<tr>
<td>飙尘</td>
</tr>
<tr>
<td>Mr.冯</td>
</tr>
<tr>
<td>Lee.c</td>
</tr>
<tr>
<td>MinK@$~Z&amp;$NY</td>
</tr>
<tr>
<td>LuckyStar</td>
</tr>
<tr>
<td>二狗</td>
</tr>
<tr>
<td>lyz</td>
</tr>
<tr>
<td>Lion King????</td>
</tr>
<tr>
<td>Planet</td>
</tr>
<tr>
<td>章章</td>
</tr>
<tr>
<td>张勇</td>
</tr>
<tr>
<td>奋斗中的老年人</td>
</tr>
<tr>
<td>何相意</td>
</tr>
<tr>
<td>pekey</td>
</tr>
<tr>
<td>L</td>
</tr>
<tr>
<td>木偶先生</td>
</tr>
<tr>
<td>甜甜圈丶不甜</td>
</tr>
<tr>
<td>无痕</td>
</tr>
<tr>
<td>Menco</td>
</tr>
<tr>
<td>卫群</td>
</tr>
<tr>
<td>Gerald</td>
</tr>
<tr>
<td>Eric  yan</td>
</tr>
<tr>
<td>小剑</td>
</tr>
<tr>
<td>阿涛</td>
</tr>
<tr>
<td>LossingDawn</td>
</tr>
<tr>
<td>ZHOU</td>
</tr>
<tr>
<td>不知道取什么名</td>
</tr>
<tr>
<td>吉宝</td>
</tr>
<tr>
<td>莯莯爸</td>
</tr>
<tr>
<td>稚</td>
</tr>
<tr>
<td>歸去如風</td>
</tr>
<tr>
<td>勿忘我～hyy</td>
</tr>
<tr>
<td>Rfiy</td>
</tr>
<tr>
<td>梦暖初心</td>
</tr>
<tr>
<td>????</td>
</tr>
<tr>
<td>排骨</td>
</tr>
<tr>
<td>阿丰.陳</td>
</tr>
<tr>
<td>blue king</td>
</tr>
<tr>
<td>Jack·Liang</td>
</tr>
<tr>
<td>啦啦啦JBL</td>
</tr>
<tr>
<td>loner</td>
</tr>
<tr>
<td>远</td>
</tr>
<tr>
<td>晨雨橙歌</td>
</tr>
<tr>
<td>思想的芦苇</td>
</tr>
<tr>
<td>袁斌</td>
</tr>
<tr>
<td></td>
</tr>
<tr>
<td>笑也要笑疯狂</td>
</tr>
<tr>
<td>驰</td>
</tr>
<tr>
<td>此情天涯朝暮深丿</td>
</tr>
<tr>
<td>马、山</td>
</tr>
<tr>
<td>試毅-思伟</td>
</tr>
<tr>
<td>mt</td>
</tr>
<tr>
<td>Skyhawk</td>
</tr>
<tr>
<td>张小凡Remi</td>
</tr>
<tr>
<td>赵元</td>
</tr>
<tr>
<td>孺子韫</td>
</tr>
<tr>
<td>萬鵬</td>
</tr>
<tr>
<td>123456</td>
</tr>
<tr>
<td>VV</td>
</tr>
<tr>
<td>明镜止水</td>
</tr>
<tr>
<td>KoTsing</td>
</tr>
<tr>
<td>????</td>
</tr>
<tr>
<td>刘灏</td>
</tr>
<tr>
<td>[爱心]郭先森</td>
</tr>
<tr>
<td>why</td>
</tr>
</tbody></table>
<p>相较于小公仔，其实更值钱的是那些课程，我看了2个，讲得确实不错，毕竟都是各公司的扛把子嘛~</p>
<h3 id="更多活动福利"><a href="#更多活动福利" class="headerlink" title="更多活动福利"></a>更多活动福利</h3><p>欢迎关注A哥的公众号，解锁更多知识<br><img data-src="https://img-blog.csdnimg.cn/20200504103543841.png"  height="300"></p>]]></content>
      <categories>
        <category>缺省</category>
      </categories>
      <tags>
        <tag>缺省</tag>
      </tags>
  </entry>
  <entry>
    <title>程序人生 | 春风得意马蹄疾，一日看尽长安花</title>
    <url>/x2y/f3891d18.html</url>
    <content><![CDATA[<blockquote>
<p>当大潮退去，才知道谁在裸泳。<br><strong>作者</strong>：A哥（YourBatman）<br><strong>公众号</strong>：BAT的乌托邦（ID：BAT-utopia）<br><strong>文末是否有彩蛋</strong>：有</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>各位小伙伴大家好，我是A哥，一个前25年还不会写Hallo World的半残程序猿。也许你看到这个介绍心里一阵美滋滋：<strong>卧槽，终于有一个不是大佬（话外音：并不优秀）的人可以关注了</strong>，一下子阳光了起来有木有。</p>
<blockquote>
<p>啊，问我多大了？反正是大龄程序员一枚没跑了😁 </p>
</blockquote>
<p>近期，在我朋友圈看了不下5篇的“个人介绍”文章，看完之后我每每只能附上本就匮乏的赞美之词：666、牛逼牛逼、大佬带带我……每看完一篇，我的心是这样的：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200501112754274.gif#x200" alt=""><br>24岁买房，25岁年薪50万+，26岁孩子可以帮忙打酱油……有些人过着开挂式人生，而有些人也过着“开挂式人生”~</p>
<blockquote>
<p>画外音：我们同样都有腰间盘，为何大佬们如此突出呢？得看看医生了呀😄</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20200501152235624.gif#x200" alt=""><br>这就是强者的世界，大多数人（那必须包括我啊）所向往的世界。人生是一个漫长的过程，我们怀有太多的期望，亦会遇到太多的失望，但请记住：<strong>烧不死的鸟才是火凤凰，烧死的都成烤乳鸽了</strong>。爱因斯坦告诉我们：成功 = 99%汗水 + 1%天赋，但是你活到现在或许才发现，那1%的天赋才是至关重要的。所以不要一味地模仿，因为大多数的“成功”并不可复制。</p>
<p>我曲折的人生经验告诉我：听马云如何解决问题，如何应对困难对你不会有任何帮助，因为级别差得太多，不具备效仿的意义。只有身边的人和事，说白了就是和你Level等级相差无几的人才能促使你进步。如果你觉得那些开挂人生的大佬给你压力，那么就关注我吧，看完我的个人介绍，会发现我是来给你送安慰的，<strong>因为你大概率比我优秀得多得多</strong>。</p>
<p>人生已经很艰难，对自己好点，别压力过大，<strong>毕竟活得长，胜算才最大</strong>，比如想想司马懿。所以呀，咱们一起做个技术人，产生共鸣；一起做个俗人，贪财好色。</p>
<hr>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>我的人生比较曲折，总体上分为三个阶段介绍：</p>
<ul>
<li><strong>1、贫苦大众 游戏人生</strong></li>
<li><strong>2、迷茫大学 似梦年华</strong></li>
<li><strong>3、凤凰涅槃 程序生涯</strong></li>
</ul>
<hr>
<h3 id="1、贫苦大众-游戏人生"><a href="#1、贫苦大众-游戏人生" class="headerlink" title="1、贫苦大众 游戏人生"></a>1、贫苦大众 游戏人生</h3><h4 id="1-1-家徒四壁-呱呱坠地"><a href="#1-1-家徒四壁-呱呱坠地" class="headerlink" title="1.1 家徒四壁 呱呱坠地"></a>1.1 家徒四壁 呱呱坠地</h4><p><img data-src="https://img-blog.csdnimg.cn/20200501153842562.png#x200" alt=""><br>这是我2019年春节爬到山顶拍摄的我家乡县城全景图：<strong>湖北省通山县</strong>。对你没看错，属于这次全国疫情最严重的地区湖北省的一个县。通山二字含义为：通通是山。环视整个中华大地，凡是这种地貌的省市/地区，一般都会这么形容他：远离闹市喧嚣，尽享静谧人生。</p>
<blockquote>
<p>话外音：你那山多树木多，空气非常的好呀，适合养身。经济嘛，不好意思，我有事先走了</p>
</blockquote>
<p>层层叠叠的山峰自然地“阻断”了交通，所以同样的一瓶可乐，在武汉市（平原地区）卖3块钱，但在我们县买就是要贵5毛钱，你说气不气。好在去年（2019年），我们县脱贫啦，在政策帮助下顺利“摘帽”（此处应有掌声）：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200503075759424.png#x200" alt=""></p>
<p>至于我的出生嘛，建议携带纸巾阅读（皮一下~）。我出生在通山县一个地地道道的农村家庭，怎么形容家境呢？当时也不可能有照片嘛，费好大力气找来一张2004年的老照片（分辨率低，不清晰），便可大概逆推出来当时喽：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200501235156545.png#x240" alt=""><br>说到了这，我把一个深藏已久的小秘密也公布了哈：<strong>我是一个早产儿，还不满8个月</strong>便因为我妈妈挺着大肚子还坚持下田干农活，然后，然后，我就意外的提前出来了。</p>
<blockquote>
<p>你可能会好奇：怀孕7个多月还下农田干粗活？？？如果不是生活所迫，谁愿默默承受！</p>
</blockquote>
<p>早产其实并不可怕，只是在当时的条件下，提前这么长时间早产的，只会有一个结果：孩子没了。可别想着说去医院生，没有的事，因为那里只属于有钱人。最终呢，在几乎没人看好的情况下，我以小强般顽强的生命力挺了过来，这不，现在还坐在电脑前写公众号着嘛。</p>
<p>这么算来，我也是<strong>度过生死劫</strong>的人哈，会不会大难不死必有后福呢？这我不知道，但我知道没什么能比健康活着更重要的事了，若用这种心态去生活，岂不处处皆阳光麽。</p>
<blockquote>
<p>Tips：若后福已至，那当属我已娶得娇妻一枚喽</p>
</blockquote>
<hr>
<h4 id="1-2-被耽误的高中-回不去的青春"><a href="#1-2-被耽误的高中-回不去的青春" class="headerlink" title="1.2 被耽误的高中 回不去的青春"></a>1.2 被耽误的高中 回不去的青春</h4><p><img data-src="https://img-blog.csdnimg.cn/20200501163855811.png#x140" alt=""><br><img data-src="https://img-blog.csdnimg.cn/20200501163456824.png#x190" alt=""><br>听着《长寿村》这个背乐敲打这段文字，单曲循环，泪水打湿了眼眶，<strong>像青春致敬，还有几个人会像我这样怀念梦幻吗</strong>？</p>
<p>上高中，来到了县城上学，开始了住校生活。第一次接触电脑，第一次知道网吧长啥样，第一次知道了上网和电网是有区别的……<br>可能和你们不一样，我的上网不是从学着使用word、excel、ppt开始的，而是一切起源于<strong>看片</strong>（懂的自然懂，不懂的不用懂），所以上高中后我也就有了第一次（别想歪了）……</p>
<p>到县城上学因为是住校，所以每周有60元生活费（人生首次有如此多自由支配的钱）。但因为迷恋上了网络游戏，所以高中生活很长一段时间每天只吃1-2餐。原因很简单嘛，钱是固定的，上网多了，吃饭自然就少了。高中阶段是我长身体的最关键时期，但由于经常“废寝忘食”，所以导致了我现在身高并不高，成了我最痛的回忆。</p>
<blockquote>
<p>别光顾吃瓜哈，我还是没拉男性平均身高的后退滴​</p>
</blockquote>
<p>很快，接触到<strong>梦幻西游</strong>这款游戏：申请一个号，从0开始。<strong>人物角色：龙太子，门派：龙宫</strong>。没错，就是他：</p>
<p><img data-src="https://img-blog.csdnimg.cn/2020050116575085.png#x200" alt=""><br>首次接触游戏并无经验，所以昵称取名为<strong>光能英雄</strong>，在那个非主流文化盛行的年代，这个名字简直土到掉渣。正因为这个名字，被玩伴们硬生生的“嘲笑”好几年，哪怕现在聊起来还不忘调侃我的这个取名处女秀。</p>
<blockquote>
<p>其实我本意是想取名为：<strong>光能使者</strong>（发现没，这个名字还是蛮高大上的嘛）。但是使者二字属于固定NPC，官方不让用，所以……</p>
</blockquote>
<p>还记得当时游戏没点了就偷家里钱去充点卡，明知会挨打的，还偏要去偷。花了30多块买了个<strong>将军令</strong>，别在裤腰带里每天带着，感觉非常吊的样子。梦幻西游可以窗口化、双开，所以每次通宵都是一边游戏一边看片（别想歪了，是正常电影），偶尔也挂机，挂着挂着就睡着了。如今再来回忆过去，时间真的过得太快了，好想停留在当初，不想长大！</p>
<p>记忆很深是当时拜了一个师傅，我15级，她75级。那会没有微信更没有手机，每次只能中午偷跑出去网吧通过QQ跟师傅约个晚上通宵的时间，好让她带我做剧情任务、副本任务、整宿整宿的扫大雁塔、抓鬼……她带我的话自己经验是非常少的，基本属于纯帮忙的那种，那时候的人真好，真纯粹。印象特别深的是我过40级剧情的时候，师傅她刚满90级，带我过了3次都还没过去，并且她自己因打不赢还死了2次（死亡是有掉装备风险的），本以为当晚是没戏了。但让我特别惊喜的是：她半夜打电话把朋友叫醒，把朋友125级的登上来帮我过了，这件事现在回想起来好暖</p>
<p>后来，我满60级了，师傅领着我去长安城国子监祭酒处，我出师了…….<br>再后来，我90级了，我也收了徒弟。师傅125级了，但是我俩一起做任务的机会越来越少了，偶尔在龙宫里能碰见就唠几句……<br>再再后来，师傅把她的号送给了我，而我也已经没有再继续玩下去的欲望了……</p>
<p>虽十几年过去了，现在回味起来别有滋味。今天听着《长寿村》，泡了一会吧，看着吧友们的回复，感触良多。<strong>作为曾经国内最为流行的游戏</strong>，相信感同身受的人是可以蛮多的，因此顺道也分享一些吧友话给你吧：</p>
<ul>
<li>每周日：12门派闯关、守军之争、英雄大会、长安保卫战、挑战首席大弟子，这些活动你都还熟悉吗？</li>
<li>十几年前，那时候刚入梦幻，0级，到处跑，看到发光的圈圈（传送点），觉得好神奇，不知不觉就走到了沉船底下，进去后，竟不知道怎么走出来，后来是被海毛虫和巨蛙打死了，才回到建邺城的，因为等级太低，那时候不会自动升级，要手动升级。爱上梦幻，就是从那一刻开始的，但是现在太商业了，已经失去了当年的味道</li>
<li>感觉好多回忆，现在已经是孩子妈了，还是很怀念</li>
<li>长寿的配乐是最缠绵伤感的，十年前那时经常通宵抓鬼或者押镖累了过来长寿听着背乐站一站，遐想、发呆</li>
<li>2012年之后就再也没玩过梦幻。之前玩了近八年。现在听着这音乐心里有种说不出的感觉</li>
<li>……</li>
</ul>
<p>被耽误的高中，回不去的青春。当初介绍我玩梦幻西游的小伙伴，我是该谢谢你呢，还是谢谢你呢？</p>
<hr>
<h3 id="2、迷茫大学-似梦年华"><a href="#2、迷茫大学-似梦年华" class="headerlink" title="2、迷茫大学 似梦年华"></a>2、迷茫大学 似梦年华</h3><h4 id="2-1-疲于奔命的大学四年"><a href="#2-1-疲于奔命的大学四年" class="headerlink" title="2.1 疲于奔命的大学四年"></a>2.1 疲于奔命的大学四年</h4><p><img data-src="https://img-blog.csdnimg.cn/20200502162941843.png#x200" alt=""></p>
<p>还记得当时轰动中国、获得<strong>2009感动中国人物特别奖</strong>荣誉的“长江大学1024人链”感人事件吗？是的，它就出自这所英雄大学。</p>
<p>整个高中阶段都被<strong>梦幻西游</strong>“耽误”了，自然就没有个好大学上喽。从全国排名上看，它绝对算不上一个很好的大学。和大学时期的你一样，在校时候没少骂过母校，但现在不会了，因为人生最美好的四年，都在这里度过。母校是什么？母校是我可以一天骂他一百次，但是不允许别人骂他一次的地方。</p>
<blockquote>
<p>话外音：耳边可容不得别人骂它，否则就拔刀吧</p>
</blockquote>
<p>我的大学生涯，不可谓不“丰富多彩”：</p>
<ul>
<li>协会、社团、学生会</li>
<li>创意设计大赛</li>
<li>校园销售团队</li>
<li>商学院招聘</li>
<li>开餐馆</li>
<li>全市最大圣诞节校园苹果鲜花销售</li>
<li>全市最大暑期家教团（名校高分）</li>
<li>……<br><img data-src="https://img-blog.csdnimg.cn/20200502083058268.jpg#x240" alt=""><br><img data-src="https://img-blog.csdnimg.cn/20200502083201660.png#x240" alt=""><br><img data-src="https://img-blog.csdnimg.cn/20200502084107913.png#x240" alt=""></li>
</ul>
<p>因为有了一群志同道合的伙伴，实现了很多学生时代的“梦想”：在大桥底下过夜、下雪天光膀子沿操场跑50圈、通宵KTV、以及在学校隔壁的四星级酒店开party……<strong>再多各自牛逼的时光，也比不上一起傻逼的岁月</strong>。</p>
<hr>
<h4 id="2-2-跌落深渊的毕业答辩"><a href="#2-2-跌落深渊的毕业答辩" class="headerlink" title="2.2 跌落深渊的毕业答辩"></a>2.2 跌落深渊的毕业答辩</h4><p>上面列出的很多条目，没有一条与学习/专业有关。我似乎是一个最分不清主次的学生，忘乎了学生最主要的职责其实是学业，大学期间我做了几乎你所有想干的事，<strong>除了学习</strong>。补考成为了我每年必做的事，60元一个学分，补考费在当时来说也算天价，每次缴得让我心痛。</p>
<blockquote>
<p>没有补考过的大学，不算完整的大学。我tm现在想问了：这是谁说的哪门子歪理论呢？尽霍霍我了😭</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20200502085016530.png#x120" alt=""><br>但这还不是最痛的，和我的毕业比起来，补考只是小儿科。大四下学期准备毕业论文，我在某宝花了120块钱买了一篇，包售后的那种，结果首次答辩没有通过，参加二次答辩，结果。。。还是没给过</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200502090138416.png#x140" alt=""><br>面临着<strong>延迟毕业</strong>的危险，眼瞅着其他同学陆陆续续离开学校参加工作去了，心里暗自神伤，悔不当初。炎炎夏日，所有寝室里只剩下我和同班的另外一位“难友”。拿不到毕业证不能正常毕业，对人生的影响是极大的，那会承受的心里负担、压力乃至到现在拿来比较，都还没有什么事情可与之比拟。作为好学生的你，可能是永远无法体会到我当时的那种恐慌，这种gap就像：法海与爱。</p>
<p>当然喽，庆幸的是结局是好的：没有延迟毕业，我如期毕业了。这底下的一波操作实在感人，这段黑历史这里就不公开了哈，有兴趣可以底部给我留言咱们促膝单聊~</p>
<hr>
<h4 id="2-3-百无一成的初出茅庐"><a href="#2-3-百无一成的初出茅庐" class="headerlink" title="2.3 百无一成的初出茅庐"></a>2.3 百无一成的初出茅庐</h4><p><img data-src="https://img-blog.csdnimg.cn/20200502090045791.png#x140" alt=""><br>这段路程，是我毕业之后的两年经历，最难的两年。期间大小换过5次工作，且都是那种被认为门槛最低，无技术含量的，如你所见：</p>
<p><strong>大智慧炒股</strong>：北京。是的，你当时如果正在使用它看股票，看涨跌，或许你就接听过我给你打的电话</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200502092317430.png#x180" alt=""><br><strong>兴麟房产</strong>：宁夏银川。是的，就是你现在常常骂的“黑中介”中的一员。这份工作是我做的时间最长的，干了有近一年的时间。最让我值得回味的并非那些对大叔大妈的“忽悠”，也并非工作本身。而是在宁夏银川结识的一些朋友，那种豪气，那种爽快，那种喝大酒，非我们一般南方人所能比，期待我找个机会回去银川时再相聚。</p>
<p><img data-src="https://img-blog.csdnimg.cn/2020050209263857.png#x180" alt=""><br><strong>奶茶店</strong>：湖北荆州。和朋友一起在荆州呆了一个多月，目的是在学校旁边盘个奶茶店，谈了几个并且考察了相关流程，但最后也搁浅了。这段时间一直蜗居在宾馆里，好在学校附近嘛，房费并不算贵</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200502093634269.png#x180" alt=""><br><strong>百度糯米</strong>：湖北武汉。公司听起来还不错，但干的就是最底层最累的LBS的活。说白了：打电话、陌拜、地推邀请商户入驻百度糯米提供团购。在这里我知道了餐饮利润没过50%就不要干餐饮、各行各业的毛利率水平、当然也见证了Robbin李老板当时说投资200亿到百度糯米到现在的啪啪啪打脸……</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200502094312405.png#x180" alt=""><br><strong>豪大大香鸡排</strong>：湖北武汉。加盟豪大大，我的鸡排梦</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200502094615186.png#x220" alt=""><br>以上，就是我毕业后整整2年的艰辛之路，用一事无成来形容都高估了自己。人在江湖飘，哪有不挨刀，这个阶段的我真可谓满目疮痍，被压死仅需最后一根稻草。</p>
<hr>
<h3 id="3、凤凰涅槃-程序生涯"><a href="#3、凤凰涅槃-程序生涯" class="headerlink" title="3、凤凰涅槃 程序生涯"></a>3、凤凰涅槃 程序生涯</h3><p><img data-src="https://img-blog.csdnimg.cn/20200502095427946.gif#x200" alt=""></p>
<p>时间到了毕业已2年了，审视现在的自己：何止是“三无产品”，竟连一件可以拿出来絮叨的事儿都没有。最为致命的是，自己仍旧啥技能都没不会。想回去“继承父业”（家里有农田可耕嘛），但自己却又<strong>肩不能扛手不能提</strong>，有着一堆“公子病”。如何破局？在这个节骨眼上，相信作为读者的你都能感受到我当时是有多么的迷茫，无力感是有多么的强，此时，没有人比我更需要改变。</p>
<hr>
<h4 id="3-1-欲练此功-必先闭关"><a href="#3-1-欲练此功-必先闭关" class="headerlink" title="3.1 欲练此功 必先闭关"></a>3.1 欲练此功 必先闭关</h4><p><img data-src="https://img-blog.csdnimg.cn/20200501213536411.png#x130" alt=""><br>当自己没有退路可选的时候，只能毕其功于一役。经过了很长时间挣扎和重择业，最终决定选择回到我曾经在大学期间<strong>最畏惧</strong>的行业：程序员。依稀记得，大四时我多次在公开场合说到：毕业后一定以及肯定不会从事编程行业。现在回头再看，这脸打得……挺痛</p>
<blockquote>
<p>人性的弱点：越缺什么，就越强调什么。我本人其实十分羡慕IT行业，只奈何当初完全不上道……</p>
</blockquote>
<p>所以喽，痛定思痛，我开始了我的<strong>100天闭关学习计划</strong>：切断一切外界联系，从0开始，每天保证至少12小时+的高效学习时间，足不出户。这期间陪伴我时间最长的就是这两套视频：<br><img data-src="https://img-blog.csdnimg.cn/20200501212324861.png#x70" alt=""><br>现在依旧记得风清扬老师那磁性的声音和他心目中的女神：林青霞（东方不败）；崔希凡老师操着一口东北话和赐予的三尺白绫。您们幽默风趣的教学风格，给我闭关枯燥的学习增添了不少乐趣，这才让我坚持了下来，真心的感谢二位老师。</p>
<blockquote>
<p>感谢二位老师，后来我也联系到了二位老师加微信表示了感谢，祝福传智播客越来越好</p>
</blockquote>
<p>说句题外话：我收到过一些小伙伴咨询问我要不要报名去培训机构锻造，对此我一直持<strong>中立态度</strong>。中立是因为它收费（一般价格还不菲），如果撇开收费这个关键要素（比如收费没有那么的贵），是非常有价值的，因为不吹不黑，大多数机构的老师都是非常有水平的。</p>
<p>伴随着这100个日日夜夜，我完成了基础的学习，但实在还是手生，打代码还得看键盘。还好当时的互联网环境欣欣向荣，所以我才敢硬着头皮上：海投。</p>
<blockquote>
<p>这100天的意外收获：把驾驶证拿到手了（可见我大学是多么的“忙”，在校期间竟连驾照都没考）。</p>
</blockquote>
<hr>
<h4 id="3-2-崭新篇章-程序人生"><a href="#3-2-崭新篇章-程序人生" class="headerlink" title="3.2 崭新篇章 程序人生"></a>3.2 崭新篇章 程序人生</h4><p><img data-src="https://img-blog.csdnimg.cn/20200501214929958.png#x200" alt=""><br>100天的闭关结束后，自然而然的开始了我的程序员生涯。但这条路开始走得并不顺利……</p>
<p>为了第一份工作，我<strong>连续的天天面试，每天1-2家</strong>，持续足足两周共计面了20+家公司，才在最后一个周末拿到了唯一一个offer：外包公司，<strong>月薪试用期3500</strong>。伙计，北京耶，我还得吃饭还得住宿呀，那会可都5102年了，回忆一下你那会大学生活费是不是都破2000了？</p>
<p>虽然非常的窘迫，开的条件也很“简陋”，但我心里还是高兴的。因为终于有公司愿意接收我了，从此成为了一个真正的技术人，有一技之长啦。进入这个公司后的我丝毫不敢懈怠，那会给自己定的唯一目标是：<strong>努力转正，不要被开除</strong>。毕竟作为一个打代码还得靠一指禅、看键盘的我，真的很担心露馅。</p>
<blockquote>
<p>科班出生vs非科班的明显差异：其它条件都一致情况下，科班4年大学学习折算成实际经验值至少能高出非科班2年甚至更多。也就说1年经验的科班生，是远比1年非科班生的基础、技术熟练度要好非常多的。</p>
</blockquote>
<p>好在自己小有“天赋”（主要靠努力、靠死撑），在不断的努力下，得到的回馈也比较乐观，小开挂了一波：提前转正、年度优秀、职位升级、<strong>破格涨薪</strong>。仅7个月时间，我的薪水从3.5k涨到了12k，这种“速度”公司里是没有前例可寻的，所以需要特批~</p>
<p>跟第一个东家没过太久就分手了，虽然让领导觉得可惜甚至失望（毕竟对我这么好嘛），但分手还算和平。我离开的原因也很冰冷：外包公司嘛，呆久了对职业生涯没多大好处，俺对技术是有追求滴，追求可持续发展。</p>
<p>从此，我不再是空中飘着的云，随风而逝。脚踏实地的感觉真好，有一件事可以让自己当作事业来做，全情投入的感觉是很妙的。我的人生前半部分算是正式宣告翻篇了，开启了崭新的篇章。</p>
<hr>
<h3 id="笔耕不辍-钟情翰墨"><a href="#笔耕不辍-钟情翰墨" class="headerlink" title="笔耕不辍 钟情翰墨"></a>笔耕不辍 钟情翰墨</h3><p>眼瞅着当码农快3年了，3年是一个典型从业年限数字。看看那些招聘信息，大都写着工作经验要求3-5年，并且这一条似乎是HR筛选简历的硬核条件，因此需要好好把握这个时间节点。</p>
<blockquote>
<p>话外音：倘若你从业满了3年，可视区域可就大了很多</p>
</blockquote>
<p>一路走来，默默的把自己和身边（普通）同事compare以自省，渐渐的自己把逝去的那些时间补回来了，挺起腰板正式入编到“正规科班”行列。</p>
<p>积累了知识，多了些经验，但总感觉还是不够扎实，知识不成体系，而且很容易捡了芝麻忘了西瓜，因此我选择采用写下来的方式，把它持久化掉。起初，我仅仅只想找一个<strong>云笔记本</strong>记录下我关心的技术关键点，以便日后自己“复习”使用，所以我最初使用的是有道云笔记（很low有木有，不过够用就行嘛）：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200501194859280.png#x200" alt=""></p>
<hr>
<h4 id="2018年：CSDN"><a href="#2018年：CSDN" class="headerlink" title="2018年：CSDN"></a>2018年：CSDN</h4><p>用有道云笔记持续记录了有一段时间，直到有一次我给团队做分享时，有个同事看到我收录了不少技术内容，然后他就建议我可以把这些内容整理到博客里，显得更专业些。这不，我选择了<strong>CSDN平台</strong>，并在2018-5-17发了第一篇文章：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200501191907957.png#x60" alt=""><br>虽然期间也接触过其它技术社区平台，但文章首发均在CSDN。时至现在，坚持了有近2年之久，可以为自己鼓个掌喽。</p>
<p>这2年间以CSDN作为创作平台，坚持<strong>只输出技术文章</strong>（确切的说只输出Java相关技术文），收获到了一些志同道合的粉丝，这些给与了我程序生涯非常大的鼓励，坚定了信心。同时，也得到过CSDN官方的认可：CSDN官网首页顶部轮播图首位、CSDN官方公众号推文首文、2019年度博客之星评选……当然还有我这些花花绿绿的勋章，这是对自己“成绩”的最好官方证明：</p>
<blockquote>
<p>整整两排勋章，有点收集癖哈哈。有木有比我多的？亮出来呗</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20200501200208879.png#x140" alt=""><br>相较于官方给与的肯定，对于我而言，这些匿名好友的评价和鼓励更能给我带来刺激感，赋予动力。让我觉得当初的再择业时选择程序员这条路并没有错，谢谢你们：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200502170253871.png#x240" alt=""><br><img data-src="https://img-blog.csdnimg.cn/20200502170423795.png#x160" alt=""><br><img data-src="https://img-blog.csdnimg.cn/20200502170525951.png#x160" alt=""><br>此处顺便再声明一下：A哥跟享学课堂、享学科技什么的真的没有半毛钱关系，纯名字撞了而已：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200502170617912.png#x160" alt=""><br>通过CSDN平台能收获到这些好友的共鸣声，属于我意外的收获。起初仅仅只想把它作为自己的一个markdown笔记本来用，无心插柳柳成荫，后来慢慢的有读者给我反馈，给我打气加油，这才决定坚持写下去，并且更加用心了。</p>
<p>关于我的CSDN阅读量说句题外话：纯技术文章的阅读量一般都不会很高（当然不排除也有高手能把技术讲得生动有趣的），况且我还不会标题党（我只会直抒胸臆），所以即使写了2年，我的博客总阅读量也并不算高，粉丝量也不很多（但我相信都是爱技术的真爱粉），关键我还没有渠道导流不是。“水文”相对来说较容易抓人眼球获得阅读量，因为读起来确实有意思，我也蛮喜欢读的。我曾经尝试过写了几篇，但发现自己真不是那块料，告辞了。所以痛定思痛，还是把精力花在力所能及的事上吧：<strong>我只会写纯技术文，找到属于自己的一片小众空间心满意足</strong>，至于流量文那些，我玩不来。</p>
<blockquote>
<p>话外音：我内心深处其实很想写出流量文，但奈何文笔确实不行，所以还是乖乖的做个技术人吧，别瞎折腾了</p>
</blockquote>
<p>开始写公众号并不代表不再维护CSDN了，because我的伙食费还需要它的支援勒😄。仍旧会同现在一样，持续保持更新哒~</p>
<blockquote>
<p>CSDN平台永不停更，但更新的速度一般会滞后于公众号1-2天，欢迎CSDN的粉丝关注我的公众号哟</p>
</blockquote>
<hr>
<h4 id="2020年：微信公众号"><a href="#2020年：微信公众号" class="headerlink" title="2020年：微信公众号"></a>2020年：微信公众号</h4><p>都2020年了你才开始搞公众号？是的，这还是我的第一篇文章呢。有些人做公众号是出于兴趣，有些人做公众号是为了发展副业，而我又不一样了：<strong>我是为了把技术分享切换到一个大家更易接受、更喜欢的平台上，仅此而已</strong>。我的粉丝是小众的，我写不出流量文章，所以流量红利我是享受不到喽，依旧保持CSDN平台一样的初心就好：不忘初心，砥砺前行。</p>
<p>其实早在2018年末，就有大佬建议我切换到公众号平台去分享，我当时也听进去了建议，申请了帐号。只是后来我觉得在公众号里发技术文太麻烦了（不支持Markdown还得自己转换），并且手机里看示例代码效果实在太差，所以公号仅运营了一周就彻底搁浅了。因为我当时对于技术分享，心里只有一个想法：<strong>同样是内容，放哪都一样</strong>，所以我更倾向于可以大屏观看的CSDN平台。</p>
<p>但为何今年我却动摇了呢？并不是初心变了，而是不止一个大佬建议我搞个公众号，因为有些很现实的问题：CSDN已是过去时了，如果你还在用CSDN推文，很多技术好友他们是心存抵触心里的，而且使用体验上也不如公众号。我品，我细品一番确实是这么个道理：<strong>大家都使用IPhone X用微信语音聊天了，而你还在使用诺基亚打电话吗？</strong><br><img data-src="https://img-blog.csdnimg.cn/20200502202004133.jpg#x160" alt=""></p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>过去的这些年，我的人生是非常曲折的，是具有教育意义的人生轨迹，简直就是负面教材嘛。这不现在过年我回去，还有村民让我给他家孩子上思想政治课呢，让我教育教育他孩子要好好读书少玩游戏，不要走弯路。咋地，我这“名声”都传村里去了？用脚丫子想都知道这是我妈的“功劳”~</p>
<p>截止到现在，我的漫漫人生中，即使只从高中算起，<strong>我有小10年的路是完全走歪的</strong>，偏离了主航道。不敢说这些路对我一丁点帮助都没有，但从客观上来说错就是错，是无法回避的事实。现在回味起来，一声叹息，毕竟人生有几个10年呢？</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200502153624653.png#x200" alt=""><br>人生就像一场马拉松，获胜的关键不在于瞬间的爆发，而在于途中的坚持。你纵有千百个理由放弃，也要给自己一个坚持下去的理由。很多时候，成功就是多坚持一分钟，这一分钟不放弃，下一分钟就会有希望。漫漫人生途中，有的人跑的是上半场，有的人会在下半场爆发，每个人都是24h，充满希望的生活才会更有意义。</p>
<p><strong>截止到今天，我还差几个月就在北京缴纳社保满5年了，祝愿自己在小汽车摇号时，一发中第。</strong></p>]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>职业生涯</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java高工、架构师】系列群群规</title>
    <url>/x2y/wechat-gauge.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>久旱逢甘雨，一滴；<br>他乡遇故知，债主；<br>洞房花烛夜，隔壁；<br>金榜题名时，重名。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<p><img data-src="https://img-blog.csdnimg.cn/20200613101159736.png" alt=""></p>
<div style="margin-top: 50px; margin-bottom: 50px; text-align: center; font-weight: bolder; color: grey; font-size: 20px;">
😄本系列群是由A哥搭建起的纯技术交流平台，无任何商业属性。秉承着做技术我们是认真的态度，有一些规则需要你遵守😄
</div>
<div class="tabs" id="唯一名称(写上，不然有warn警告)"><ul class="nav-tabs"><li class="tab active"><a href="#唯一名称(写上，不然有warn警告)-1">关于推文</a></li><li class="tab"><a href="#唯一名称(写上，不然有warn警告)-2">关于广告</a></li><li class="tab"><a href="#唯一名称(写上，不然有warn警告)-3">关于群</a></li><li class="tab"><a href="#唯一名称(写上，不然有warn警告)-4">群福利</a></li></ul><div class="tab-content"><div class="tab-pane active" id="唯一名称(写上，不然有warn警告)-1"><div style="text-align: center; color: red; font-weight: bolder; font-size: 18px; }" class="note danger">
禁止一切未经允许的推文
</div>

<p>目的：避免沦为推文群、僵尸群，同时提高文章质量，旨在帮群友筛选出真正的干货。因此需要对推文方面作出一些限制：</p>
<div class="note warning">
            <ol><li>禁止一切未经允许的推文</li><li>目前【仅】10群开放自由推文限制（但也不能是广告文、太水的文），若你是号主or你希望看到更多“不一样”的文章，可私聊A哥邀请你进入10群</li><li>除了10群外，其它群推文采用【申请授权】方式，A哥已组件好了小团队会定期进行审核，通过后会通知到你便可在指定群推文了。<a href="https://shimo.im/sheets/QtqXwKgCVJxJjhtJ/MODOC" target="_blank" rel="noopener">申请登记地址</a></li><li>为了避免信息爆炸，每个群允许通过授权的数量目前定在【5个】，后期会根据实际情况加以调整</li></ol>
          </div></div><div class="tab-pane" id="唯一名称(写上，不然有warn警告)-2"><div style="text-align: center; color: red; font-weight: bolder; font-size: 18px; }" class="note danger">
所有群禁止一切未经允许的广告
</div>
目的：你懂的，咱们是纯净版技术群，是有B格的。广告最容易让一个群死翘翘了，所以禁止它无需多言：
<div class="note warning">
            <ol><li>所有群禁止一切未经允许的广告（包括但不限于：商业广告、推广、拼单、拉票、招聘广告…）</li><li>禁止一切发送二维码的广告行为，且严令禁止</li><li>为了照顾有些群友确实在找工作，所以会定期允许几个【招聘广告】发出，但是这是有前提的：<ol><li>请务必先发给群主“审核”允许后，才允许发出</li><li>群并不独属于群主，因此广告发出需要配额一定数量红包（金额10元起步，数量最大30个）</li></ol></li><li>需要注意的是：目前仅规则性允许招聘广告，其它广告类型一律拒绝</li></ol>
          </div></div><div class="tab-pane" id="唯一名称(写上，不然有warn警告)-3"><div style="text-align: center; color: red; font-weight: bolder; font-size: 18px; }" class="note danger">
禁止群内私加好友行为，欢迎举报
</div>
目的：例举一些基本规则，希望你能遵守
<div class="note info">
            <ol><li>禁止群内私加好友行为，欢迎举报</li><li>禁聊政治敏感话题</li><li>文明聊天，拒绝黄赌毒。那些总是喜欢开车的小伙伴们啊，请低速驾驶，超速者将吊销你的驾驶证</li><li>为了避免人员重复，原则上每个人【只允许】呆在本系列群一个群内（10群除外），管理员会定期检测T出重复人员</li><li>群内问问题小技巧：<ol><li>请把你的问题描述完整再问，因为程序运行都要有context，何况人呢？</li><li>代码尽量用截图形式发出，这样能保持格式，以及也方便你对敏感信息打码</li><li>帮你是情分，不帮你是本分。若你很希望此问题有人可以帮你，发个小小红包以示感谢效果会更好</li></ol></li></ol>
          </div></div><div class="tab-pane" id="唯一名称(写上，不然有warn警告)-4"><p>😄你造的，目前单单【公益】（意思就是你一分钱不用花，快递费都不用出呢）活动，A哥就已经送出了超200个公仔了，这对于本就贫穷的我，不是个小数目了😄，相较于一般的群还是不错的哈。</p>
<table>
<thead>
<tr>
<th align="left"><img data-src="https://img-blog.csdnimg.cn/20200612225136939.png" alt="A哥私人微信"></th>
<th align="left"><img data-src="https://img-blog.csdnimg.cn/20200613092818287.gif" alt="A哥私人公众号"></th>
</tr>
</thead>
</table>
<p>关于A哥的介绍，你可以<a href="/about">点击这里</a>。除了这些，你还可以：</p>
<div class="note info">
            <ol><li>扫码加A哥好友，和一个很有技术范的coder做朋友（如果已经是群友，建议你务必添加好友，方便我做群管理）</li><li>如果你是个对技术有研究热情的，就扫码关注我的公众号吧（BAT的乌托邦：只做有深度的文章分享，拒绝浅尝辄止）</li><li>近期正在筹划线下面基，扩大下朋友圈。当然地点只是北京，若你有兴趣可下面留言</li></ol>
          </div></div></div></div>

<p>公众号转载开白，请在<a href="/x2y/wechat-white-list.html">此处登记</a><br>公众号转载开白，请在<a href="/x2y/wechat-white-list.html">此处登记</a><br>公众号转载开白，请在<a href="/x2y/wechat-white-list.html">此处登记</a></p>
<div style="margin-top: 50px; margin-bottom: 50px; text-align: center; font-weight: bolder; color: grey; font-size: 20px;">
😄希望大家遵守群规，群内不求能大富大贵。但可以聚集在一起做个俗人：贪财好色，岂不更快乐些不是😄
</div>]]></content>
      <categories>
        <category>公众号</category>
      </categories>
      <tags>
        <tag>公众号</tag>
      </tags>
  </entry>
  <entry>
    <title>【BAT的乌托邦】公众号开白申请</title>
    <url>/x2y/wechat-white-list.html</url>
    <content><![CDATA[<div class="note primary">
            <ul><li>公众号：BAT的乌托邦</li><li>作者：A哥<ul><li>A哥的介绍：<ul><li><a href="/about">PC版</a></li><li><a href="https://mp.weixin.qq.com/s/PGIFtpI7aZaxY7es0F6C6Q" target="_blank" rel="noopener">手机版</a></li></ul></li><li>示例文章：<a href="https://mp.weixin.qq.com/s/PYVD8BvT7Nux0jiSomSG0A" target="_blank" rel="noopener">点击这里</a></li></ul></li><li>定位：专注Java领域，只做有深度的专栏文章分享，拒绝浅尝辄止</li><li>首篇文章时间：2020-05-03   <a href="https://mp.weixin.qq.com/s/PGIFtpI7aZaxY7es0F6C6Q" target="_blank" rel="noopener">查看首篇文章</a></li></ul>
          </div>

<h3 id="转载请著名出处，示例（文首-文末）："><a href="#转载请著名出处，示例（文首-文末）：" class="headerlink" title="转载请著名出处，示例（文首 + 文末）："></a>转载请著名出处，示例（文首 + 文末）：</h3><p><img data-src="https://img-blog.csdnimg.cn/20200616122117470.png" alt="文首"><br><img data-src="https://img-blog.csdnimg.cn/20200616122910584.png" alt="文末"></p>
<div style="text-align: center;color: #8c8888;font-size: 8px;margin-top: -10px;">文案请从此处复制：本文转载自公众号【BAT的乌托邦】，专注Java领域，只做有深度的专栏文章分享，拒绝浅尝辄止。</div>

<div style="margin-top: 50px; margin-bottom: 50px; text-align: center; font-weight: bolder; color: grey; font-size: 20px;">
😄申请【开长白】请在本文下面留言，开白成功后我会登记入下表，谢谢合作😄
</div>
<div style="text-align: center; font-weight: bolder; color: #7d7d7d; font-size: 11px;margin-top: -50px;margin-bottom: 20px;">
(留言时请输入正确邮箱号，这样开白成功会给你发邮件提醒)
</div>
<div class="table-container"><table>
    <thead>
        <tr>
            <th align="center">公众号</th>
            <th align="center">操作时间</th>
            <th align="center">是否长白</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td align="center">学习Java的小姐姐</td>
            <td align="center">2020.06.24</td>
            <td align="center">是</td>
        </tr>
        <tr>
            <td align="center">自由程序人</td>
            <td align="center">2020.06.16</td>
            <td align="center">是</td>
        </tr>
        <tr>
            <td align="center">softech华山论剑</td>
            <td align="center">2020.06.14</td>
            <td align="center">是</td>
        </tr>
        <tr>
            <td align="center">石杉的架构笔记</td>
            <td align="center">2020.06.09</td>
            <td align="center">是</td>
        </tr>
        <tr>
            <td align="center">源码笔记</td>
            <td align="center">2020.06.04</td>
            <td align="center">是</td>
        </tr>
    </tbody>
</table></div>]]></content>
      <categories>
        <category>公众号</category>
      </categories>
      <tags>
        <tag>公众号</tag>
        <tag>白名单</tag>
      </tags>
  </entry>
  <entry>
    <title>使用@AutoConfigureBefore调整配置顺序竟没生效？</title>
    <url>/x2y/3aa2234d.html</url>
    <content><![CDATA[<blockquote>
<p>一个人的价值体现在能够帮助多少人。自己编码好，价值能得到很好的体现。若你做出来的东西能够帮助别人开发，大大减少开发的时间，那就功德无量。<br><strong>作者</strong>：A哥（YourBatman）<br><strong>公众号</strong>：BAT的乌托邦（ID：BAT-utopia）<br><strong>文末是否有彩蛋</strong>：有</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>各位小伙伴大家好，我是A哥。<code>Spring Boot</code>是Spring家族具有划时代意义的一款产品，它发展自<code>Spring Framework</code>却又高于它，这种高于主要表现在其最重要的<strong>三大特性</strong>，而相较于这三大特性中更为重要的便是<strong>Spring Boot的自动配置</strong>（<code>AutoConfiguration</code>）。与其说是自动，倒不如说是“智能”，该框架看起来好像“更聪明”了。因此它也顺理成章的成为了构建微服务的基础设施，稳坐第一宝座。</p>
<p>生活之道，在于取舍。编程何尝不是，任何决定都会是一把双刃剑，<code>Spring Boot</code>的自动配置解决了Spring Framework使用起来的众多痛点，让开发效率可以得到<strong>指数级提升</strong>（想一想，这不就是功德无量吗？）。成也萧何败也萧何，也正是因为它的太智能，倘若出了问题就会让程序员两眼一抹黑，无从下手。</p>
<blockquote>
<p>瑕不掩瑜，Spring Boot前进的步伐浩浩荡荡，学就完了</p>
</blockquote>
<p>这不，我就在前几天收到一个“求助”，希望使用<code>@AutoConfigureBefore</code>来<strong>控制配置的顺序</strong>，但并未能如愿。本文就针对这个场景case稍作展开，讨论下使用<code>@AutoConfigureBefore、@AutoConfigureAfter、@AutoConfigureOrder</code>三大注解控制自动配置执行顺序的<strong>正确姿势</strong>。</p>
<blockquote>
<p>提示：Spring Boot的自动配置是通过@EnableAutoConfiguration注解驱动的，默认是开启状态。你也可以通过<code>spring.boot.enableautoconfiguration = false</code>来关闭它，回退到Spring Framework时代。显然这不是本文需要讨论的内容~</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/2020050916181352.png#x200" alt=""></p>
<hr>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>本文将要聊的重点是Spring Boot自动配置 + 顺序控制，自动配置大家都耳熟能详，那么“首当其冲”就是知晓这个问题：配置类的执行为何需要控制顺序？</p>
<hr>
<h2 id="配置类为何需要顺序？"><a href="#配置类为何需要顺序？" class="headerlink" title="配置类为何需要顺序？"></a>配置类为何需要顺序？</h2><p>我们已经知道Spring容器它对Bean的初始化是<strong>无序</strong>的，我们并不能想当然的通过<code>@Order</code>注解来控制其执行顺序。一般来说，对于容器内普通的Bean我们只需要关注依赖关系即可，而并不需要关心其绝对的顺序，而依赖关系的管理Spring的是做得很好的，这不连<strong>循环依赖</strong>它都可以搞定麽。</p>
<p><code>@Configuration</code>配置类它也是一个Bean，但对于配置类来说，某些场景下的执行顺序是<strong>必须的</strong>，是需要得到保证的。比如很典型的一个非A即B的case：若容器内已经存在A了，就不要再把B放进来。这种case即使用中文理解，就能知道对A的“判断”必须要放在B的前面，否则可能导致程序出问题。</p>
<p>那么针对于配置的执行顺序，传统Spring和Spring Boot下各自是如何处理的，表现如何呢？</p>
<hr>
<h3 id="Spring下控制配置执行顺序"><a href="#Spring下控制配置执行顺序" class="headerlink" title="Spring下控制配置执行顺序"></a>Spring下控制配置执行顺序</h3><p>在传统的<code>Spring Framework</code>里，一个<code>@Configuration</code>注解标注的类就代表一个配置类，当存在多个<code>@Configuration</code>时，他们的<strong>执行顺序</strong>是由使用者靠手动指定的，就像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 手动控制Config1 Config2的顺序</span></span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(Config1<span class="class">.<span class="keyword">class</span>, <span class="title">Config2</span>.<span class="title">class</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>当然，你可能就疑问了说：即使在传统Spirng里，我也从没有自己使用过<code>AnnotationConfigApplicationContext</code>来显示加载配置啊，都是使用<code>@Configuration</code>定义好配置类后，点击<code>Run</code>一把唆的。没错，那是因为你是在web环境下使用Spring，IoC容器是借助web容器（如Tomcat等）来驱动的，Spring对此部分封装得非常好，所以做到了对使用者几乎无感知。</p>
<p>关于这部分的内容，此处就不深究了，毕竟本文重点不在这嘛。但可以给出给小结论：<code>@Configuration</code>配置被加载进容器的方式大体上可分为两种：</p>
<ol>
<li>手动。构建<code>ApplicationContext</code>时由构建者手动传入，可手动控制顺序</li>
<li>自动。被<code>@ComponentScan</code>自动扫描进去，无法控制顺序</li>
</ol>
<p>绝大多数情况下我们都是使用<strong>自动</strong>的方式，所以在Spring下对配置的顺序并无感知。其实这也是需求驱使，因为在传统Spring下我们并无此需求，所以对它无感是合乎逻辑的。另说一句，虽然我们并不能控制Bean的顺序，但是我们是可以干涉它的，比如：控制依赖关系、提升优先级、“间接”控制执行顺序…当然喽这是后面文章的内容，敬请关注。</p>
<hr>
<h3 id="Spring-Boot下控制配置执行顺序"><a href="#Spring-Boot下控制配置执行顺序" class="headerlink" title="Spring Boot下控制配置执行顺序"></a>Spring Boot下控制配置执行顺序</h3><p><code>Spring Boot</code>下对<strong>自动配置</strong>的管理对比于Spring它就是黑盒，它会根据当前容器内的情况来<strong>动态的</strong>判断自动配置类的加载与否、以及加载的顺序，所以可以说：Spring Boot的自动配置它对顺序是有<strong>强要求</strong>的。需求驱使，Spring Boot给我们提供了<code>@AutoConfigureBefore、@AutoConfigureAfter、@AutoConfigureOrder</code>（下面统称这三个注解为“三大注解”）这三个注解来帮我们解决这种诉求。</p>
<p>需要注意的是：三大注解是Spring Boot提供的而非Spring Framework。其中前两个是1.0.0就有了，<code>@AutoConfigureOrder</code>属于1.3.0版本新增，表示绝对顺序（数字越小，优先级越高）。另外，这几个注解<strong>并不互斥</strong>，可以同时标注在同一个<code>@Configuration</code>自动配置类上。</p>
<hr>
<h2 id="Spring-Boot内置的控制配置顺序举例"><a href="#Spring-Boot内置的控制配置顺序举例" class="headerlink" title="Spring Boot内置的控制配置顺序举例"></a>Spring Boot内置的控制配置顺序举例</h2><p>为方便大家理解，我列出一个Spring Boot它自己的使用作为示例学一学。以大家最为熟悉的WebMvc的自动配置场景为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@AutoConfigureOrder</span>(Ordered.HIGHEST_PRECEDENCE + <span class="number">10</span>)</span><br><span class="line"><span class="meta">@AutoConfigureAfter</span>(&#123; DispatcherServletAutoConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">TaskExecutionAutoConfiguration</span>.<span class="title">class</span>, <span class="title">ValidationAutoConfiguration</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">WebMvcAutoConfiguration</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@AutoConfigureOrder</span>(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="meta">@AutoConfigureAfter</span>(ServletWebServerFactoryAutoConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">DispatcherServletAutoConfiguration</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@AutoConfigureOrder</span>(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletWebServerFactoryAutoConfiguration</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>这几个配置是WebMVC的核心配置，他们之间是有顺序关系的：</p>
<ul>
<li><code>WebMvcAutoConfiguration</code>被加载的前提是：<code>DispatcherServletAutoConfiguration、TaskExecutionAutoConfiguration、ValidationAutoConfiguration</code>这三个哥们都已经完成初始化</li>
<li><code>DispatcherServletAutoConfiguration</code>被加载的前提是：<code>ServletWebServerFactoryAutoConfiguration</code>已经完成初始化</li>
<li><code>ServletWebServerFactoryAutoConfiguration</code>被加载的前提是：<code>@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)</code>最高优先级，也就是说它无其它依赖，<strong>希望自己是最先被初始化的</strong><ul>
<li>当碰到多个配置都是最高优先级的时候，且互相之前没有关系的话，顺序也是不定的。但若互相之间存在依赖关系（如本利的<code>DispatcherServletAutoConfiguration</code>和<code>ServletWebServerFactoryAutoConfiguration</code>），那就按照相对顺序走</li>
</ul>
</li>
</ul>
<p><img data-src="https://img-blog.csdnimg.cn/20200418160820903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Y2NDEzODU3MTI=,size_16,color_FFFFFF,t_70#x330" alt=""></p>
<p>在<code>WebMvcAutoConfiguration</code>加载<strong>后</strong>，在它<strong>之后</strong>其实还有很多配置会尝试执行，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfigureAfter</span>(WebMvcAutoConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">FreeMarkerServletWebConfiguration</span> <span class="keyword">extends</span> <span class="title">AbstractFreeMarkerConfiguration</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AutoConfigureAfter</span>(WebMvcAutoConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">GroovyTemplateAutoConfiguration</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AutoConfigureAfter</span>(&#123; WebMvcAutoConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">WebFluxAutoConfiguration</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ThymeleafAutoConfiguration</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AutoConfigureAfter</span>(WebMvcAutoConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">LifecycleMvcEndpointAutoConfiguration</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>这些都很容易理解：如果都不是Web环境，加载一些模版引擎的并无必要嘛。</p>
<hr>
<h2 id="三大注解使用的误区（重要）"><a href="#三大注解使用的误区（重要）" class="headerlink" title="三大注解使用的误区（重要）"></a>三大注解使用的误区（重要）</h2><p>根据我的切身体会，针对这三大注解，实在有太多人把它<strong>误用</strong>了，想用但是用了却又不生效，于是就容易触发一波“骂街”操作，其实这也是我书写本文的最大动力所在：纠正你的错误使用，告诉你正确姿势。</p>
<hr>
<h3 id="错误使用示例"><a href="#错误使用示例" class="headerlink" title="错误使用示例"></a>错误使用示例</h3><p>我见到的非常多的小伙伴这么来使用三大注解：我这里使用“伪代码”进行模拟</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B_ParentConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    B_ParentConfig() &#123;</span><br><span class="line">        System.out.println(<span class="string">"配置类ParentConfig构造器被执行..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A_SonConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    A_SonConfig() &#123;</span><br><span class="line">        System.out.println(<span class="string">"配置类SonConfig构造器被执行..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C_DemoConfig</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">C_DemoConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是被自动扫描的配置，初始化啦...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>).<span class="title">close</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过名称能知道我想要的达到的效果是：<strong>ParentConfig先加载，SonConfig后加载</strong>。（DemoConfig作为一个参考配置，作为日志参考使用即可）</p>
<p>启动应用，控制台打印：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">配置类SonConfig构造器被执行...</span><br><span class="line">配置类ParentConfig构造器被执行...</span><br><span class="line">我是被自动扫描的配置，初始化啦....</span><br></pre></td></tr></table></figure>
<p>Son优先于Parent被加载了，这明显<strong>不符合要求</strong>。因此，我看到很多小伙伴就这么干：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfigureBefore</span>(A_SonConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Configuration</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">B_ParentConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    B_ParentConfig() &#123;</span><br><span class="line">        System.out.println(<span class="string">"配置类ParentConfig构造器被执行..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>@AutoConfigureBefore</code>控制，表示在<code>A_SonConfig</code>之前执行此配置。语义层面上看，貌似没有任何问题，再次启动应用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">配置类SonConfig构造器被执行...</span><br><span class="line">配置类ParentConfig构造器被执行...</span><br><span class="line">我是被自动扫描的配置，初始化啦....</span><br></pre></td></tr></table></figure>
<p>what a fuck。看到没，我没骗你吧，骂街了骂街了</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200509163634888.png#x200" alt=""><br>竟然没生效？代码不会骗人，<code>@AutoConfigureBefore</code>的语义也没有问题，而是你使用的姿势不对，下面我会给你正确姿势。</p>
<hr>
<h2 id="三大注解使用的正确姿势"><a href="#三大注解使用的正确姿势" class="headerlink" title="三大注解使用的正确姿势"></a>三大注解使用的正确姿势</h2><p>针对以上case，要想达到预期效果，正确姿势只需要下面两步：</p>
<ol>
<li>把<code>A_SonConfig</code>和<code>B_ParentConfig</code>挪动到Application<strong>扫描不到</strong>的包内，切记：一定且必须是扫描不到的包内</li>
<li>当前工程里增加配置<code>META-INF/spring.factories</code>，内容为(配置里Son和Parent前后顺序对结果无影响)：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.fsx.autoconfig.A_SonConfig,com.fsx.autoconfig.B_ParentConfig</span><br></pre></td></tr></table></figure>
再次启动应用看看，打印输出：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我是被自动扫描的配置，初始化啦....</span><br><span class="line">配置类ParentConfig构造器被执行...</span><br><span class="line">配置类SonConfig构造器被执行...</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>完美</strong>。符合预期，Parent终于在Son之前完成了初始化，也就是说我们的<code>@AutoConfigureBefore</code>注解生效了。</p>
<hr>
<h3 id="使用细节注意事项"><a href="#使用细节注意事项" class="headerlink" title="使用细节注意事项"></a>使用细节注意事项</h3><p>针对此使用姿势，虽然很正确，并不是完全没有“副作用”的，有如下细节平时也需要引起注意：</p>
<ul>
<li>若你不用<code>@AutoConfigureBefore</code>这个注解，单单就想依赖于spring.factories里的先后顺序的来控制实际的加载顺序，答案是<strong>不可以</strong>，控制不了</li>
<li>例子中有个小细节：我每次都故意输出了<code>我是被自动扫描的配置，初始化啦....</code>这句话，可以发现被扫描进去配置实例化是在它前面（见错误示例），而通过<code>spring.factories</code>方式进去是在它的后面（见正确姿势）</li>
<li>从这个小细节可以衍生得到结论：<code>Spring Boot</code>的自动配置均是通过<code>spring.factories</code>来指定的，它的优先级最低（执行时机是最晚的）；通过扫描进来的一般都是你自己自定义的配置类，所以优先级是最高的，<strong>肯定在自动配置之前加载</strong><ul>
<li>从这你应该学到：若你要指定扫描的包名，请千万不要扫描到形如<code>org.springframework</code>这种包名，否则“天下大乱”（当然喽为了防止这种情况出现，Spring Boot做了容错的。它有一个类专门检测这个case防止你配置错了，具体参见<code>ComponentScanPackageCheck</code>默认实现）</li>
</ul>
</li>
<li>请尽量不要让自动配置类既被扫描到了，又放在<code>spring.factories</code>配置了，否则后者会覆盖前者，很容易造成莫名其妙的错误</li>
</ul>
<p>小总结，对于三大注解的正确使用姿势是应该是：请使用在你的<strong>自动配置</strong>里（一般是你自定义starter时使用），而不是使用在你业务工程中的<code>@Configuration</code>里，因为那会毫无效果。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200509165554902.jpg#x200" alt=""></p>
<h2 id="三大注解解析时机浅析"><a href="#三大注解解析时机浅析" class="headerlink" title="三大注解解析时机浅析"></a>三大注解解析时机浅析</h2><p>为了更好的辅助理解，加强记忆，本文将这三大注解解析时机<strong>简要的</strong>絮叨一下，知道了它被解析的时机，自然就很好解释为何你那么写是无效的喽。</p>
<p>这三个注解的解析都是交给<code>AutoConfigurationSorter</code>来排序、处理的，做法类似于<code>AnnotationAwareOrderComparator</code>去解析排序<code>@Order</code>注解。核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoConfigurationSorter</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 唯一给外部调用的方法：返回排序好的Names，因此返回的是个List嘛（ArrayList）</span></span><br><span class="line">	<span class="function">List&lt;String&gt; <span class="title">getInPriorityOrder</span><span class="params">(Collection&lt;String&gt; classNames)</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 先按照自然顺序排一波</span></span><br><span class="line">		Collections.sort(orderedClassNames);</span><br><span class="line">		<span class="comment">// 在按照@AutoConfigureBefore这三个注解排一波</span></span><br><span class="line">		orderedClassNames = sortByAnnotation(classes, orderedClassNames);</span><br><span class="line">		<span class="keyword">return</span> orderedClassNames;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此排序器被两个地方使用到：</p>
<ul>
<li><code>AutoConfigurationImportSelector</code>：Spring自动配置处理器，用于加载所有的自动配置类。它实现了<code>DeferredImportSelector</code>接口：这也顺便解释了为何自动配置是最后执行的原因~</li>
<li><code>AutoConfigurations</code>：表示自动配置@Configuration类。</li>
</ul>
<p>这个排序的“解析/排序”过程还是比较复杂的，本文点到为止，观其大意即可。你可以简单粗暴的记住结论：<code>@AutoConfigureBefore、@AutoConfigureAfter、@AutoConfigureOrder</code>这三个注解只能作用于<strong>自动配置类</strong>，而不能是自定义的@Configuration配置类。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于Spring Boot自动配置顺序相关的三大注解<code>@AutoConfigureBefore、@AutoConfigureAfter、@AutoConfigureOrder</code>就先介绍到这了，本文主要用意是为了帮助大家规范此些“常用注解”的使用，规避一些误区，端正使用姿势，避免犯错时又丈二和尚。</p>
<p>我看到不少文章、生产上的代码都使用错了（估计有没有效果自己的都不知道，又或者刚好歪打正着确实是在xxx后面执行而以为生效了），希望本文能帮助到你。</p>]]></content>
      <categories>
        <category>Spring配置类</category>
      </categories>
      <tags>
        <tag>@Configuration</tag>
        <tag>Spring Boot</tag>
        <tag>@AutoConfigureBefore</tag>
      </tags>
  </entry>
  <entry>
    <title>不懂SpringApplication生命周期事件？那就等于不会Spring Boot嘛</title>
    <url>/x2y/78afedd2.html</url>
    <content><![CDATA[<blockquote>
<p>学习方法之少废话：吹牛、装逼、叫大哥。<br><strong>作者</strong>：A哥（YourBatman）<br><strong>公众号</strong>：BAT的乌托邦（ID：BAT-utopia）<br><strong>文末是否有彩蛋</strong>：有</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>各位小伙伴大家好，我是A哥。本文属总结性文章，对总览<code>Spring Boot</code>生命周期<strong>很是重要</strong>，建议点在看、转发“造福”更多小伙伴。</p>
<p>我最近不是在写Spring Cloud深度剖析的相关专栏麽，最近有收到小伙伴发过来一些问题，通过这段时间收集到的反馈，总结了一下有一个问题非常集中：那便是对Spring Boot应用<code>SpringApplication</code>的生命周期、事件的理解。有句话我不是经常挂嘴边说的麽，你对Spring Framework有多了解决定了你对Spring Boot有多了解，你对Spring Boot的了解深度又会制约你去了解Spring Cloud，一环扣一环。因此此问题反馈比较集中是在清理之中的~</p>
<p>为何在Spring Boot中生命周期事件机制如此重要？缘由很简单：Spring Cloud父容器是由该生命周期事件机制来驱动的，而它仅仅是一个典型代表。<strong>Spring Cloud构建在Spring Boot之上</strong>，它在此基础上构建并添加了一些“Cloud”功能。应用程序事件<code>ApplicationEvent</code>以及监听<code>ApplicationListener</code>是Spring Framework提供的扩展点，Spring Boot对此扩展点利用得非常充分和深入，并且还衍生出了非常多“子”事件类型，甚至<strong>自成体系</strong>。从<code>ApplicationEvent</code>衍生出来的子事件类型非常多，例如<code>JobExecutionEvent、RSocketServerInitializedEvent、AuditApplicationEvent...</code></p>
<p>本文并不会对每个子事件分别介绍（也并无必要），而是集中火力主攻Spring Boot最为重要的一套事件机制：<strong>SpringApplication生命周期的事件体系</strong>。<br><img data-src="https://img-blog.csdnimg.cn/20200426082403185.png#x240" alt="学习去..."></p>
<hr>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本文将以<code>SpringApplication</code>的启动流程/生命周期各时期发出的Event事件为主线，结合每个生命周期内<strong>完成的大事记</strong>介绍，真正实现一文让你总览Spring Boot的全貌，这对你<strong>深入理解Spring Boot，以及整合进Spring Cloud都将非常重要</strong>。</p>
<p>为表诚意，本文一开始便把<code>SpringApplication</code>生命周期事件流程图附上，然后再精细化讲解各个事件的详情。</p>
<blockquote>
<p>话外音：赶时间的小伙伴可以拿图走人😁，但不建议白嫖哟</p>
</blockquote>
<hr>
<h3 id="生命周期事件流程图"><a href="#生命周期事件流程图" class="headerlink" title="生命周期事件流程图"></a>生命周期事件流程图</h3><p><img data-src="https://img-blog.csdnimg.cn/2020042709145967.png#x500" alt=""></p>
<hr>
<h4 id="版本说明："><a href="#版本说明：" class="headerlink" title="版本说明："></a>版本说明：</h4><p>由于不同版本、类路径下存在不同包时结果会存在差异，不指明版本的文章都是不够负责任的。因此对导包/版本情况作出如下说明：</p>
<ul>
<li><code>Spring Boot</code>：2.2.2.RELEASE。有且仅导入<code>spring-boot-starter-web</code>和<code>spring-boot-starter-actuator</code></li>
<li><code>Spring Cloud</code>：Hoxton.SR1。有且仅导入<code>spring-cloud-context</code>（注意：并非spring-cloud-starter，并不含有spring-cloud-commons哦）</li>
</ul>
<p>总的来说：本例导包是非常非常“干净”的，这样在流程上才更有说服力嘛~</p>
<hr>
<h3 id="SpringApplicationEvent"><a href="#SpringApplicationEvent" class="headerlink" title="SpringApplicationEvent"></a>SpringApplicationEvent</h3><p>它是和<code>SpringApplication</code>生命周期有关的<strong>所有事件</strong>的父类，@since 1.0.0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringApplicationEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String[] args;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SpringApplicationEvent</span><span class="params">(SpringApplication application, String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(application);</span><br><span class="line">		<span class="keyword">this</span>.args = args;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> SpringApplication <span class="title">getSpringApplication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (SpringApplication) getSource();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> String[] getArgs() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.args;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它是抽象类，扩展自Spring Framwork的<code>ApplicationEvent</code>，确保了事件和应用实体<code>SpringApplication</code>产生关联（当然还有<code>String[] args</code>）。它有如下实现子类（7个）：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200426105441685.png#x140" alt=""><br>每个事件都代表着SpringApplication不同生命周期所处的位置，下面分别进行讲解。</p>
<hr>
<hr>
<hr>
<h4 id="ApplicationStartingEvent：开始启动中"><a href="#ApplicationStartingEvent：开始启动中" class="headerlink" title="ApplicationStartingEvent：开始启动中"></a>ApplicationStartingEvent：开始启动中</h4><p>@since 1.5.0，并非1.0.0就有的哦。不过现在几乎没有人用1.5以下的版本了，所以可当它是标准事件。</p>
<hr>
<h5 id="完成的大事记"><a href="#完成的大事记" class="headerlink" title="完成的大事记"></a>完成的大事记</h5><ul>
<li><p><code>SpringApplication</code>实例已实例化：<code>new SpringApplication(primarySources)</code></p>
<ul>
<li><p>它在实例化阶段完成了如下几件“大”事：</p>
<ul>
<li>推断出应用类型<code>webApplicationType</code>、main方法所在类</li>
<li>给字段initializers赋值：拿到SPI方式配置的<code>ApplicationContextInitializer</code>上下文初始化器<br><img data-src="https://img-blog.csdnimg.cn/20200426113340172.png#x140" alt=""></li>
<li>给字段listeners赋值：拿到SPI方式配置的<code>ApplicationListener</code>应用监听器<br><img data-src="https://img-blog.csdnimg.cn/2020042611345757.png#x240" alt=""></li>
</ul>
</li>
<li><p>注意：在此阶段(早期阶段)不要过多地使用它的内部状态，因为它可能在生命周期的后期被修改（话外音：使用时需谨慎）</p>
</li>
</ul>
</li>
<li><p>此时，<code>SpringApplicationRunListener</code>已实例化：它通过SPI方式指定<code>org.springframework.boot.SpringApplicationRunListener=org.springframework.boot.context.event.EventPublishingRunListener</code>。</p>
<ul>
<li>若你有自己的运行时应用监听器，使用相同方式配置上即可，均会生效</li>
</ul>
</li>
<li><p>由于<code>EventPublishingRunListener</code>已经实例化了，因此在后续的事件发送中，均能够触发对应的监听器的执行</p>
</li>
<li><p>==发送ApplicationStartingEvent事件，触发对应的监听器的执行==</p>
</li>
</ul>
<hr>
<h5 id="监听此事件的监听器们"><a href="#监听此事件的监听器们" class="headerlink" title="监听此事件的监听器们"></a>监听此事件的监听器们</h5><p>默认情况下，有4个监听器监听<code>ApplicationStartingEvent</code>事件：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200426114311648.png#x100" alt=""></p>
<ol>
<li><code>LoggingApplicationListener</code>：@since 2.0.0。对日志系统抽象<code>LoggingSystem</code>执行实例化以及初始化之前的操作，默认使用的是基于Logback的<code>LogbackLoggingSystem</code></li>
<li><code>BackgroundPreinitializer</code>：启动一个后台进行对一些类进行<strong>预热</strong>。如<code>ValidationInitializer、JacksonInitializer...</code>，因为这些组件有第一次惩罚的特点（并且首次初始化均还比较耗时），所以使用后台线程先预热效果更佳</li>
<li><code>DelegatingApplicationListener</code>：它监听的是<code>ApplicationEvent</code>，而实际上只会<code>ApplicationEnvironmentPreparedEvent</code>到达时生效，所以此处忽略</li>
<li><code>LiquibaseServiceLocatorApplicationListener</code>：略</li>
</ol>
<p>总结：此事件节点结束时，<code>SpringApplication</code>完成了一些实例化相关的动作：本实例实例化、本实例属性赋值、日志系统实例化等。</p>
<hr>
<h4 id="ApplicationEnvironmentPreparedEvent：环境已准备好"><a href="#ApplicationEnvironmentPreparedEvent：环境已准备好" class="headerlink" title="ApplicationEnvironmentPreparedEvent：环境已准备好"></a>ApplicationEnvironmentPreparedEvent：环境已准备好</h4><p>@since 1.0.0。该事件节点是最为重要的一个节点之一，因为对于Spring应用来说，环境抽象<code>Enviroment</code>简直太重要了，它是最为基础的<strong>元数据</strong>，决定着程序的构建和走向，所以构建的时机是比较早的。</p>
<hr>
<h5 id="完成的大事记-1"><a href="#完成的大事记-1" class="headerlink" title="完成的大事记"></a>完成的大事记</h5><ul>
<li>封装命令行参数（main方法的args）到<code>ApplicationArguments</code>里面</li>
<li>创建出一个环境抽象实例<code>ConfigurableEnvironment</code>的实现类，并且填入值：Profiles配置和Properties属性，默认内容如下（注意，这只是初始状态，后面还会改变、添加属性源，实际见最后的截图）：<br><img data-src="https://img-blog.csdnimg.cn/20200426164107130.png#x160" alt=""></li>
<li>==发送ApplicationEnvironmentPreparedEvent事件，触发对应的监听器的执行==<ul>
<li>对环境抽象Enviroment的<strong>填值</strong>，均是由监听此事件的监听器去完成，见下面的监听器详解</li>
</ul>
</li>
<li></li>
<li><code>bindToSpringApplication(environment)</code>：把环境属性中<code>spring.main.xxx = xxx</code>绑定到当前的SpringApplication实例属性上，如常用的<code>spring.main.allow-bean-definition-overriding=true</code>会被绑定到当前<code>SpringApplication</code>实例的对应属性上</li>
</ul>
<hr>
<h5 id="监听此事件的监听器们-1"><a href="#监听此事件的监听器们-1" class="headerlink" title="监听此事件的监听器们"></a>监听此事件的监听器们</h5><p>默认情况下，有9个监听器监听<code>ApplicationEnvironmentPreparedEvent</code>事件：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200426165334573.png#x200" alt=""></p>
<ol>
<li><code>BootstrapApplicationListener</code>：来自SC。优先级最高，用于启动/创建Spring Cloud的应用上下文。需要注意的是：到此时SB的上下文<code>ApplicationContext</code>还并没有创建哦。这个流程“嵌套”特别像Bean初始化流程：初始化Bean A时，遇到了Bean B，就需要先去完成Bean B的初始化，<strong>再回头来</strong>继续完成Bean A的步骤。<ul>
<li>说明：在创建SC的应用的时候，使用的也是<code>SpringApplication#run()</code>完成的（非web），因此也会走下一整套SpringApplication的生命周期逻辑，所以请你务必区分。<ul>
<li>特别是这种case会让“绝大多数”初始化器、监听器等执行多次，若你有那种只需要执行一次的需求（比如只想让SB容器生命周期内执行，SC生命周期不执行），<strong>请务必自行处理</strong>，否则会被执行多次而带来不可预知的结果</li>
</ul>
</li>
<li>SC应用上下文读取的外部化配置文件名默认是：<code>bootstrap</code>，使用的也是<code>ConfigFileApplicationListener</code>完成的加载/解析</li>
</ul>
</li>
<li><code>LoggingSystemShutdownListener</code>：来自SC。对<code>LogbackLoggingSystem</code>先清理，再重新初始化一次，效果同上个事件，相当于重新来了一次，毕竟现在有Enviroment环境里嘛</li>
<li><code>ConfigFileApplicationListener</code>：@since 1.0.0。<strong>它也许是最重要的一个监听器</strong>。做了如下事情：<ul>
<li>加载SPI配置的所有的<code>EnvironmentPostProcessor</code>实例，并且排好序。需要注意的是：<code>ConfigFileApplicationListener</code>也是个<code>EnvironmentPostProcessor</code>，会参与排序哦<br><img data-src="https://img-blog.csdnimg.cn/20200426172309831.png#x130" alt=""></li>
<li><strong>排好序后</strong>，分别一个个的执行<code>EnvironmentPostProcessor</code>（@since 1.3.0，并非一开始就有），介绍如下：<ul>
<li><code>SystemEnvironmentPropertySourceEnvironmentPostProcessor</code>：@since 2.0.0。把<code>SystemEnvironmentPropertySource</code>替换为其子类<code>OriginAwareSystemEnvironmentPropertySource</code>（属性值带有Origin来源），仅此而已</li>
<li><code>SpringApplicationJsonEnvironmentPostProcessor</code>：@since 1.3.0。把环境中<code>spring.application.json=xxx</code>值解析成为一个<code>MapPropertySource</code>属性源，然后放进环境里面去（属性源的位置是做了处理的，一般不用太关心）<ul>
<li>可以看到，SB是直接支持JSON串配置的哦。Json解析参见：<code>JsonParser</code></li>
</ul>
</li>
<li><code>CloudFoundryVcapEnvironmentPostProcessor</code>：@since 1.3.0。略</li>
<li><code>ConfigFileApplicationListener</code>：@since 1.0.0（它比EnvironmentPostProcessor先出现的哦）。加载<code>application.properties/yaml</code>等外部化配置，解析好后放进环境里（这应该是最为重要的）。<ul>
<li>外部化配置默认的优先级为：<code>&quot;classpath:/,classpath:/config/,file:./,file:./config/&quot;</code>。当前工程下的config目录里的application.properties优先级最高，当前工程类路径下的application.properties优先级最低</li>
<li>值得强调的是：bootstrap.xxx也是由它负责加载的，处理规则一样</li>
</ul>
</li>
<li><code>DebugAgentEnvironmentPostProcessor</code>：@since 2.2.0。处理和<code>reactor</code>测试相关，略</li>
</ul>
</li>
</ul>
</li>
<li><code>AnsiOutputApplicationListener</code>：@since 1.2.0。让你的终端（可以是控制台、可以是日志文件）支持Ansi彩色输出，使其更具可读性。当然前提是你的终端支持ANSI显示。参考类：<code>AnsiOutput</code>。你可通过<code>spring.output.ansi.enabled = xxx</code>配置，可选值是：<code>DETECT/ALWAYS/NEVER</code>，一般不动即可。另外，针对控制台可以单独配置：<code>spring.output.ansi.console-available = true/false</code></li>
<li><code>LoggingApplicationListener</code>：@since 2.0.0。根据Enviroment环境完成<code>initialize()</code>初始化动作：日志等级、日志格式模版等<ul>
<li>值得注意的是：它这步相当于在ApplicationStartingEvent事件基础上进一步完成了初始化（上一步只是实例化）</li>
</ul>
</li>
<li><code>ClasspathLoggingApplicationListener</code>：@since 2.0.0。用于把classpath路径以<code>log.debug()</code>输出，略<ol>
<li>值得注意的是：classpath类路径是有N多个的<code>Arrays.toString(((URLClassLoader) classLoader).getURLs())</code>，也就是说每个.jar里都属于classpath的范畴</li>
<li>当然喽，你需要注意Spring在处理类路径时：<strong>classpath和classpath*的区别</strong>~，这属于基础知识</li>
</ol>
</li>
<li><code>BackgroundPreinitializer</code>：本事件达到时无动作</li>
<li><code>DelegatingApplicationListener</code>：执行通过外部化配置<code>context.listener.classes = xxx,xxx</code>的监听器们，然后把该事件广播给他们，关心此事件的监听器执行<ul>
<li>这麽做的好处：可以通过属性文件外部化配置监听器，而不一定必须写在<code>spring.factories</code>里，更具弹性</li>
<li>外部化配置的执行优先级，还是相对较低的，到这里才给与执行嘛</li>
</ul>
</li>
<li><code>FileEncodingApplicationListener</code>：检测当前系统环境的file.encoding和spring.mandatory-file-encoding设置的值是否一样,如果不一样则抛出异常如果不配置spring.mandatory-file-encoding则不检查</li>
</ol>
<p>总结：此事件节点结束时，Spring Boot的环境抽象Enviroment已经准备完毕，但此时其上下文<code>ApplicationContext</code>还<strong>没有创建</strong>，但是Spring Cloud的应用上下文（引导上下文）已经<strong>全部初始化完毕哦</strong>，所以SC管理的外部化配置也应该都进入到了SB里面。如下图所示（这是基本上算是Enviroment的最终态了）：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200426175307644.png#x180" alt=""><br>小提示：SC配置的优先级是高于SB管理的外部化配置的。例如针对<code>spring.application.name</code>这个属性，若bootstrap里已配置了值，再在application.yaml里配置其实就无效了，因此生产上建议不要写两处。</p>
<hr>
<h4 id="ApplicationContextInitializedEvent：上下文已实例化"><a href="#ApplicationContextInitializedEvent：上下文已实例化" class="headerlink" title="ApplicationContextInitializedEvent：上下文已实例化"></a>ApplicationContextInitializedEvent：上下文已实例化</h4><p>@since 2.1.0，非常新的一个事件。当SpringApplication的上下文<code>ApplicationContext</code>准备好<strong>后</strong>，对单例Bean们实例化之<strong>前</strong>，发送此事件。所以此事件又可称为：<code>contextPrepared</code>事件。</p>
<hr>
<h5 id="完成的大事记-2"><a href="#完成的大事记-2" class="headerlink" title="完成的大事记"></a>完成的大事记</h5><ul>
<li><p><code>printBanner(environment)</code>：打印Banner图，默认打印的是Spring Boot字样</p>
<ul>
<li><code>spring.main.banner-mode = xxx</code>来控制Banner的输出，可选值为<code>CONSOLE/LOG/OFF</code>，一般默认就好</li>
<li>默认在类路径下放置一个<code>banner.txt</code>文件，可实现自定义Banner。关于更多自定义方式，如使用图片、gif等，本处不做过多介绍<ul>
<li>小建议：别花里胡哨搞个佛祖在那。让它能自动打印输出<strong>当前应用名</strong>，这样才是最为实用，最高级的（但需要你定制化开发，并且支持可配置，最好对使用者无感，属于一个common组件）</li>
</ul>
</li>
</ul>
</li>
<li><p>根据是否是web环境、是否是REACTIVE等，用<strong>空构造器</strong>创建出一个<code>ConfigurableApplicationContext</code>上下文实例（因为使用的是空构造器，所以不会立马“启动”上下文）</p>
<ul>
<li>SERVLET -&gt; AnnotationConfigServletWebServerApplicationContext</li>
<li>REACTIVE -&gt; AnnotationConfigReactiveWebServerApplicationContext</li>
<li>非web环境 -&gt; AnnotationConfigApplicationContext（SC应用的容器就是使用的它）</li>
</ul>
</li>
<li><p>既然上下文实例已经有了，那么就开始对它进行一些参数的设置：</p>
<ul>
<li>首先<strong>最重要的</strong>便是把已经准备好的环境Enviroment环境设置给它</li>
<li>设置些beanNameGenerator、resourceLoader、ConversionService等组件</li>
<li>实例化所有的<code>ApplicationContextInitializer</code>上下文初始化器，并且排序好后挨个执行它（这个很重要），默认有如下截图这些初始化器此时要执行：<br><img data-src="https://img-blog.csdnimg.cn/20200426203418279.png#x260" alt=""><br>下面对这些初始化器分别做出简单介绍：<ol>
<li><code>BootstrapApplicationListener.AncestorInitializer</code>：来自SC。用于把SC容器设置为SB容器的父容器。当然实际操作委托给了此方法：<code>new ParentContextApplicationContextInitializer(this.parent).initialize(context)</code>去完成</li>
<li><code>BootstrapApplicationListener.DelegatingEnvironmentDecryptApplicationInitializer</code>：来自SC。代理了下面会提到的<code>EnvironmentDecryptApplicationInitializer</code>，也就是说在此处就会先执行，用于提前解密Enviroment环境里面的属性，如相关URL等</li>
<li><code>PropertySourceBootstrapConfiguration</code>：来自SC。重要，和配置中心相关，<strong>若想自定义配置中心必须了解它</strong>。主要作用是<code>PropertySourceLocator</code>属性源定位器，我会把它放在配置中心章节详解</li>
<li><code>EnvironmentDecryptApplicationInitializer</code>：来自SC。属性源头通过上面加载回来了，通过它来实现解密<ul>
<li>值得注意的是：它被执行了两次哦~</li>
</ul>
</li>
<li><code>DelegatingApplicationContextInitializer</code>：和上面的<code>DelegatingApplicationListener</code>功能类似，支持外部化配置<code>context.initializer.classes = xxx,xxx</code></li>
<li><code>SharedMetadataReaderFactoryContextInitializer</code>：略</li>
<li><code>ContextIdApplicationContextInitializer</code>：@since 1.0.0。设置应用ID -&gt; <code>applicationContext.setId()</code>。默认取值为<code>spring.application.name</code>，再为application，再为自动生成</li>
<li><code>ConfigurationWarningsApplicationContextInitializer</code>：@since 1.2.0。对错误的配置进行<strong>警告</strong>（不会终止程序），以warn()日志输出在控制台。默认内置的只有对包名的检查：若你扫包含有<code>&quot;org.springframework&quot;/&quot;org&quot;</code>这种包名就警告<ul>
<li>若你想自定义检查规则，请实现<code>Check</code>接口，然后…</li>
</ul>
</li>
<li><code>RSocketPortInfoApplicationContextInitializer</code>：@since 2.2.0。暂略</li>
<li><code>ServerPortInfoApplicationContextInitializer</code>：@since 2.0.0。将自己作为一个监听器注册到上下文<code>ConfigurableApplicationContext</code>里，专门用于监听<code>WebServerInitializedEvent</code>事件（非SpringApplication的生命周期事件）<ul>
<li>该事件有两个实现类：<code>ServletWebServerInitializedEvent</code>和<code>ReactiveWebServerInitializedEvent</code>。发送此事件的时机是<code>WebServer</code>已启动完成，所以已经有了监听的端口号</li>
<li>该监听器做的事有两个：<ul>
<li><code>&quot;local.&quot; + getName(context.getServerNamespace()) + &quot;.port&quot;</code>作为key（默认值是<code>local.server.port</code>），value是端口值。这样可以通过@Value来获取到本机端口了（但貌似端口写0的时候，SB在显示上有个小bug）</li>
<li>作为一个属性源<code>MapPropertySource</code>放进环境里，属性源名称为：<code>server.ports</code>（因为一个server是可以监听多个端口的，所以这里用复数）</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><code>ConditionEvaluationReportLoggingListener</code>：将<code>ConditionEvaluationReport</code>报告（自动配置中哪些匹配了，哪些没匹配上）写入日志，当然只有<code>LogLevel#DEBUG</code>时才会输出（注意：这不是日志级别哦，应该叫报告级别）。如你配置<code>debug=true</code>就开启了此自动配置类报告<ul>
<li>槽点：它明明是个初始化器，为毛命名为Listener？</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>==发送ApplicationContextInitializedEvent事件，触发对应的监听器的执行==</p>
</li>
</ul>
<hr>
<h5 id="监听此事件的监听器们-2"><a href="#监听此事件的监听器们-2" class="headerlink" title="监听此事件的监听器们"></a>监听此事件的监听器们</h5><p>默认情况下，有2个监听器监听<code>ApplicationContextInitializedEvent</code>事件：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200426212435270.png#x80" alt=""></p>
<ol>
<li><code>BackgroundPreinitializer</code>：本事件达到时无动作</li>
<li><code>DelegatingApplicationListener</code>：本事件达到时无动作</li>
</ol>
<p>总结：此事件节点结束时，完成了应用上下文ApplicationContext的准备工作，<strong>并且执行所有注册的上下文初始化器<code>ApplicationContextInitializer</code></strong>。但是此时，单例Bean是仍旧还没有初始化，并且WebServer也还没有启动</p>
<hr>
<h4 id="ApplicationPreparedEvent：上下文已准备好"><a href="#ApplicationPreparedEvent：上下文已准备好" class="headerlink" title="ApplicationPreparedEvent：上下文已准备好"></a>ApplicationPreparedEvent：上下文已准备好</h4><p>@since 1.0.0。截止到上个事件<code>ApplicationContextInitializedEvent</code>，应用上下文ApplicationContext充其量叫<strong>实例化</strong>好了，但是还剩下很重要的事没做，这便是本周期的内容。</p>
<hr>
<h5 id="完成的大事记-3"><a href="#完成的大事记-3" class="headerlink" title="完成的大事记"></a>完成的大事记</h5><ul>
<li>把applicationArguments、printedBanner等都作为一个Bean放进Bean工厂里（因此你就可以@Autowired注入的哦）<ul>
<li>比如：有了Banner这个Bean，你可以在你任何想要输出的地方输出一个Banner，而不仅仅是启动时只会输出一次了</li>
</ul>
</li>
<li>若<code>lazyInitialization = true</code>延迟初始化，那就向Bean工厂放一个：<code>new LazyInitializationBeanFactoryPostProcessor()</code><ul>
<li>该处理器@since 2.2.0。该处理器的作用是：对所有的Bean（通过<code>LazyInitializationExcludeFilter</code>接口指定的排除在外）全部<code>.setLazyInit(true);</code>延迟初始化</li>
</ul>
</li>
<li>根据primarySources和allSources，交给<code>BeanDefinitionLoader</code>（SB提供的实现）实现加载<strong>Bean的定义信息</strong>，它支持4种加载方式（4种源）：<ul>
<li><code>AnnotatedBeanDefinitionReader</code> -&gt; 基于注解</li>
<li><code>XmlBeanDefinitionReader</code> -&gt; 基于xml配置</li>
<li><code>GroovyBeanDefinitionReader</code> -&gt; Groovy文件</li>
<li><code>ClassPathBeanDefinitionScanner</code> -&gt; classpath中加载</li>
<li>(不同的源使用了不同的load加载方式)</li>
</ul>
</li>
<li>==发送ApplicationPreparedEvent事件，触发对应的监听器的执行==</li>
</ul>
<hr>
<h5 id="监听此事件的监听器们-3"><a href="#监听此事件的监听器们-3" class="headerlink" title="监听此事件的监听器们"></a>监听此事件的监听器们</h5><p>默认情况下，有6个监听器监听<code>ApplicationContextInitializedEvent</code>事件：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200426222617526.png#x130" alt=""></p>
<ol>
<li><code>CloudFoundryVcapEnvironmentPostProcessor</code>：略</li>
<li><code>ConfigFileApplicationListener</code>：向上下文注册一个<code>new PropertySourceOrderingPostProcessor(context)</code>。它的作用是：Bean工厂结束后对环境里的属性源进行重排序 -&gt; 把名字叫<code>defaultProperties</code>的属性源放在最末位<ul>
<li>该属性源是通过<code>SpringApplication#setDefaultProperties</code> API方式放进来的，一般不会使用到，留个印象即可</li>
</ul>
</li>
<li><code>LoggingApplicationListener</code>：因为这时已经有Bean工厂了嘛，所以它做的事是：向工厂内放入Bean<ul>
<li>“springBootLoggingSystem” -&gt; loggingSystem</li>
<li>“springBootLogFile” -&gt; logFile</li>
<li>“springBootLoggerGroups” -&gt; loggerGroups</li>
</ul>
</li>
<li><code>BackgroundPreinitializer</code>：本事件达到时无动作</li>
<li><code>RestartListener</code>：SC提供。把当前最新的上下文缓存起来而已，目前并未发现有实质性作用，可忽略</li>
<li><code>DelegatingApplicationListener</code>：本事件达到时无动作</li>
</ol>
<p>总结：此事件节点结束时，应用上下文ApplicationContext<strong>初始化</strong>完成，该赋值的赋值了，Bean定义信息也已全部加载完成。但是，单例Bean还没有被实例化，web容器依旧还没启动。</p>
<hr>
<h4 id="ApplicationStartedEvent：应用成功启动"><a href="#ApplicationStartedEvent：应用成功启动" class="headerlink" title="ApplicationStartedEvent：应用成功启动"></a>ApplicationStartedEvent：应用成功启动</h4><p>@since 2.0.0。截止到此，应用已经<strong>准备就绪</strong>，并且通过监听器、初始化器等完成了非常多的工作了，但仍旧剩下<strong>被认为最为重要的</strong>初始化单例Bean动作还没做、web容器（如Tomcat）还没启动，这便是这个周期所要做的事。</p>
<hr>
<h5 id="完成的大事记-4"><a href="#完成的大事记-4" class="headerlink" title="完成的大事记"></a>完成的大事记</h5><ul>
<li>启动Spring容器：<code>AbstractApplicationContext#refresh()</code>，这个步骤会做很多事，比如会<strong>实例化单例Bean</strong><ul>
<li>该步骤属于Spring Framework的核心内容范畴，做了很多事，请参考Spring核心技术内容章节</li>
<li>在Spring容器refresh()启动完成后，<code>WebServer</code>也随之完成启动，<strong>成功监听到对应端口(们)</strong></li>
</ul>
</li>
<li>输出启动成功的日志：<code>Started Application in xxx seconds (JVM running for xxx)</code></li>
<li>==发送ApplicationStartedEvent事件，触发对应的监听器的执行==</li>
<li></li>
<li><code>callRunners()</code>：依次执行容器内配置的<code>ApplicationRunner/CommandLineRunner</code>的Bean实现类，支持sort排序<ul>
<li><code>ApplicationRunner</code>：@since 1.3.0，入参是<code>ApplicationArguments</code>，先执行（推荐使用）</li>
<li><code>CommandLineRunner</code>：@since 1.0.0，入参是<code>String... args</code>，后执行（不推荐使用）</li>
</ul>
</li>
</ul>
<hr>
<h5 id="监听此事件的监听器们-4"><a href="#监听此事件的监听器们-4" class="headerlink" title="监听此事件的监听器们"></a>监听此事件的监听器们</h5><p>默认情况下，有3个监听器监听<code>ApplicationStartedEvent</code>事件：</p>
<p><img data-src="https://img-blog.csdnimg.cn/2020042623300532.png#x80" alt=""></p>
<ol>
<li>前两个不用再解释了吧：本事件达到时无动作</li>
<li><code>TomcatMetricsBinder</code>：@since 2.1.0。和监控相关：将你的tomcat指标信息<code>TomcatMetrics</code>绑定到<code>MeterRegistry</code>，从而就能收集到相关指标了</li>
</ol>
<p>总结：此事件节点结束时，<code>SpringApplication</code>的生命周期到这一步，<strong>正常的启动流程</strong>就全部完成了。也就说Spring Boot应用可以正常对对外提供服务了。</p>
<hr>
<h4 id="ApplicationReadyEvent：应用已准备好"><a href="#ApplicationReadyEvent：应用已准备好" class="headerlink" title="ApplicationReadyEvent：应用已准备好"></a>ApplicationReadyEvent：应用已准备好</h4><p>@since 1.3.0。该事件所处的生命周期可认为基本同<code>ApplicationStartedEvent</code>，仅是在其后执行而已，两者中间并无其它特别的动作，但是监听此事件的监听器们还是<strong>蛮重要的</strong>。</p>
<hr>
<h5 id="完成的大事记-5"><a href="#完成的大事记-5" class="headerlink" title="完成的大事记"></a>完成的大事记</h5><p>同上。</p>
<hr>
<h5 id="监听此事件的监听器们-5"><a href="#监听此事件的监听器们-5" class="headerlink" title="监听此事件的监听器们"></a>监听此事件的监听器们</h5><p>默认情况下，有4个监听器监听<code>ApplicationStartedEvent</code>事件：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200427105742674.png#x100" alt=""></p>
<ol>
<li><code>SpringApplicationAdminMXBeanRegistrar</code>：当此事件到达时，告诉Admin Spring应用已经ready，可以使用啦。</li>
<li>中间这两个不用再解释了吧：本事件达到时无动作</li>
<li><code>RefreshEventListener</code>：当此事件到达时，告诉Spring应用已经ready了，接下来便可以执行<code>ContextRefresher.refresh()</code>喽</li>
</ol>
<p>总结：此事件节点结束时，应用已经完完全全的准备好了，并且也已经完成了相关组件的周知工作。</p>
<hr>
<hr>
<h4 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h4><p><code>SpringApplication</code>是有可能在启动的时候失败（如端口号已被占用），当然任何一步骤遇到异常时交给<code>SpringApplication#handleRunFailure()</code>方法来处理，这时候也会有对应的事件发出。</p>
<hr>
<h5 id="ApplicationFailedEvent：应用启动失败"><a href="#ApplicationFailedEvent：应用启动失败" class="headerlink" title="ApplicationFailedEvent：应用启动失败"></a>ApplicationFailedEvent：应用启动失败</h5><p>当<code>SpringApplication</code>在启动时抛出异常：可能是端口绑定、也可能是你自定义的监听器你写了个bug等，就会“可能”发送此事件。</p>
<hr>
<h6 id="完成的大事记-6"><a href="#完成的大事记-6" class="headerlink" title="完成的大事记"></a>完成的大事记</h6><ul>
<li>得到异常的退出码ExitCode，然后发送<code>ExitCodeEvent</code>事件（非生命周期事件）</li>
<li>发送<code>ApplicationFailedEvent</code>事件，触发对应的监听器的执行</li>
</ul>
<hr>
<h6 id="监听此事件的监听器们-6"><a href="#监听此事件的监听器们-6" class="headerlink" title="监听此事件的监听器们"></a>监听此事件的监听器们</h6><p>默认情况下，有6个监听器监听<code>ApplicationStartedEvent</code>事件：<br><img data-src="https://img-blog.csdnimg.cn/20200426235823365.png#x140" alt=""></p>
<ol>
<li><code>LoggingApplicationListener</code>：执行<code>loggingSystem.cleanUp()</code>清理资源</li>
<li><code>ClasspathLoggingApplicationListener</code>：输出一句debug日志：<code>Application failed to start with classpath:  ...</code></li>
<li>中间这两个不用再解释了吧：本事件达到时无动作</li>
<li><code>ConditionEvaluationReportLoggingListener</code>：自动配置输出报告，输出错误日志呗：特别方便你查看和错误定位<ul>
<li>不得不夸：SB对错误定位这块才真叫智能，比Spring Framework好用太多了</li>
</ul>
</li>
<li><code>BootstrapApplicationListener.CloseContextOnFailureApplicationListener</code>：执行context.close()</li>
</ol>
<p>总结：此事件节点结束时，会做一些释放资源的操作。一般情况下：我们并不需要监听到此事件</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于<code>SpringApplication</code>的生命周期体系的介绍就到这了，相信通过此“万字长文”你能体会到A哥的用心。翻了翻市面上的相关文章，本文Almost可以保证是总结得最到位的，让你通过一文便可从大的方面基本掌握Spring Boot，这不管是你使用SB，还是后续自行扩展、精雕细琢SB，以及去深入了解Spring Cloud均由非常重要的意义，希望对你有帮助，谢谢你的三连。</p>]]></content>
      <categories>
        <category>享学Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>SpringApplication</tag>
      </tags>
  </entry>
  <entry>
    <title>广告位招租</title>
    <url>/x2y/552c674f.html</url>
    <content><![CDATA[<h3 id="请加A哥微信聊-备注：商务合作"><a href="#请加A哥微信聊-备注：商务合作" class="headerlink" title="请加A哥微信聊(备注：商务合作)"></a>请加A哥微信聊(备注：商务合作)</h3><img data-src="https://img-blog.csdnimg.cn/20200608214500399.png"  height="300">

<h3 id="目前开放广告位："><a href="#目前开放广告位：" class="headerlink" title="目前开放广告位："></a>目前开放广告位：</h3><ol>
<li>个人博客（首页轮播图、文章底部广告位…）</li>
<li>CSDN</li>
<li>微信公众号</li>
</ol>]]></content>
      <categories>
        <category>缺省</category>
      </categories>
      <tags>
        <tag>缺省</tag>
      </tags>
  </entry>
  <entry>
    <title>A哥感悟到的2019关键词：裁员、技术驱动、分享精神、能力边界</title>
    <url>/x2y/e1bcb9c1.html</url>
    <content><![CDATA[<blockquote>
<p>2019很艰难，2020更艰难？</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/2019123115480260.png#x200" alt=""><br><img data-src="https://img-blog.csdnimg.cn/20191231155031257.png#x270" alt=""></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2019年注定会在历史的长河里被记下来，因为不仅对互联网而且对各行各业来说对它都是极不平静的一年，有喜事如京张高铁的顺利通行、北京大兴国际机场的落成，当然更多的是那些不平坦：中国男篮家门口折戟世锦赛、经济形势下滑、暴力裁员…</p>
<p>作为一个遵纪守法的四有好公民，我不敢更没能力去对如上一些宏观现象评头品足，而自己仅作为一个折转多次最终进入了 <strong>IT行业</strong> 并且作为从业4年有加的“老兵”，跟行业内人士分享一下这一年 <strong>我本人</strong> 感悟较深的几个关键字，顺便尝试解读解读。</p>
<blockquote>
<p>说明：本篇文章所有内容纯属一家之言，没有任何偏向和针对性</p>
</blockquote>
<hr>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>如上所说，做为一个职场老兵，同时也作为一个专业技术人员，我关注的焦点自然和 <strong>IT圈子</strong> 分不开，所以看问题的角度避免不了存在偏见，不喜勿喷，不喜勿喷，不喜勿喷。<br>下面主要分为：<code>裁员、技术驱动、分享精神、能力边界</code>这四个关键词（话题）展开：</p>
<hr>
<h3 id="裁员"><a href="#裁员" class="headerlink" title="裁员"></a>裁员</h3><p>2019年，特别是到了下半年，中国整个互联网圈子用”哀鸿遍野”来形容一点都不夸张。小到初创公司，大到巨头企业几乎无一幸免的进行了裁员，甚至各种暴力裁员新闻层出不穷：从新浪的<strong>现场结账，立马走人</strong>，到网易的<strong>暴力裁掉身患癌症员工</strong>；再到华为<strong>裁员7000人</strong>，以及昨天刚刚发生的<strong>神州优车暴力裁员刷新公众认知</strong>…</p>
<p>一片景象，不可为不“热闹”。空气中弥漫的这种裁员气氛不仅让很多人中枪，更是让那些“幸免者”也忧郁匆匆，人心惶惶。<br>我本人当然没有能力条条是到的去分析为何会大批量出现此现象，我只聊我感悟到的，同时也是和我们切身相关的一个话题：如何才能尽量避免自己被裁。</p>
<h4 id="如何尽量避免自己被裁"><a href="#如何尽量避免自己被裁" class="headerlink" title="如何尽量避免自己被裁"></a>如何尽量避免自己被裁</h4><p>我认为纯由我来说这个话题是有点站不住脚的，毕竟我是只在贵圈呆了4年的”老兵”，资格还不够”老”。所以接下来的内容大都是我和一个工作10年+的从业者聊过几次之后，我收录到的一些观点，供以参考：</p>
<blockquote>
<p>人物背景介绍：他的整个职业生涯总的来说分为了三个阶段 <strong>技术-&gt;管理-&gt;技术</strong>，现在在某一家世界知名互联网公司做技术专家，技术栈为Java</p>
</blockquote>
<h5 id="不要一味的迷恋所谓的管理，把当官作为职场唯一的追求"><a href="#不要一味的迷恋所谓的管理，把当官作为职场唯一的追求" class="headerlink" title="不要一味的迷恋所谓的管理，把当官作为职场唯一的追求"></a>不要一味的迷恋所谓的管理，把当官作为职场唯一的追求</h5><p>中国人自古以来都有“官本位”的思想：在职场上混迹几年，如果不混个一官半职，就感觉挺丢人（无言面对父老乡亲）。<br>有这种想法是完全可以被理解，甚至被普遍接受的。但绝大多数人对此都弄混了一个<strong>概念上的区别</strong>：企业单位or事业单位，体制内or体制外：</p>
<ul>
<li><strong>事业单位</strong>：只要不违法乱纪，不犯大的错误，这辈子就安慰了，乌纱帽是丢不了的</li>
<li><strong>企业单位</strong>（此处只关心私企，央企/国企不讨论）：失去职位（被劝退、开除、优化、裁员…）的“机会”太多了。且不说公司内部的激斗争这方面，就算你总是能不湿鞋且八面玲珑的能应对各种关系，但也控制不了你所在的团队、所在的事业部、或者是所在的行业的衰退（比如说二手车行业不行了，你不能说是因为总监的能力不行），而企业面对这种现象最直接有效的做法就是：裁员。</li>
</ul>
<p>所以迷恋管理本身没错，毕竟下命令的快感是每个人都期望的。但是深处职场的我们，应该看清你处在的工作单位环境或者大环境，然后控制好这个度才能做到游刃有余</p>
<hr>
<h5 id="别误以为裁员只裁一线，不裁管理层"><a href="#别误以为裁员只裁一线，不裁管理层" class="headerlink" title="别误以为裁员只裁一线，不裁管理层"></a>别误以为裁员只裁一线，不裁管理层</h5><p>这一点就又得说了，因为我觉得还蛮有意思的一个话题，并且大家体会还蛮深，能产生共鸣。</p>
<p>各大公司公开裁员新闻时大都会说：主要裁<strong>基础员工、基层管理、中层管理</strong>。为何裁的都是这三大类职位呢？其实这非常容易理解，这三类职位可能占据公司80%的人员。因此站在企业的角度来看在这里做手术动刀，是<strong>最安全和最有效</strong>的方式。所以千万别误以为裁员只裁一线，不裁领导（管理层），毕竟员工都没了，要领导有何用？难道让1个领导只管1名员工？这明显违背了公司的“金字塔结构”嘛~</p>
<p>其实对绝大多数<strong>中级管理职位</strong>来说，无论是个人的价值，还是地位，都严重于依赖他当前所在的组织，以及其中的title。一旦离开这个公司，失去了对应的title，这些管理者一瞬间就会失去所有光环。再加上管理者相对“务虚”，所依赖的往往是大家津津乐道的“软实力”（比如沟通、协调、推动…），而这里面本身是没有问题的，我认为最大的问题就在于这个 “软” 字，因为它不好展现，尤其是你在面试的时候…</p>
<blockquote>
<p>为了避免被喷，此处必须强调说明一点：相信没有任何人敢否定”软实力”的强大作用，我自然也就不是这个意思了</p>
</blockquote>
<p>因为作为管理岗，招聘的需求一般是较少的，所以如果不能运气好很快的碰到生涯中的伯乐，那么中层管理者一旦离开当前的公司，价值一般会出现断崖式下降，跌到谷底后就真正会应了那句名言：<strong>公司有名我无名</strong>。<br>反观技术人员，且不说你肯定是精通技术的，但只要社会还在发展，企业对生产力还有需求，专业技术人员就很难彻底的失业，再就业的概率也是很大、很快的。</p>
<p>对于裁员后面对失业的现状是：管理层往往比普通员工更加悲惨，因为在大环境在向下的时候，<strong>脱了毛的凤凰是还不如鸡的</strong>。并且所谓的<strong>由俭入奢易，由奢入俭难</strong>的思维必然亦会阻碍领导层再就业时的选择。</p>
<hr>
<h5 id="即使你已经步入管理，建议还是不要脱离技术"><a href="#即使你已经步入管理，建议还是不要脱离技术" class="headerlink" title="即使你已经步入管理，建议还是不要脱离技术"></a>即使你已经步入管理，建议还是不要脱离技术</h5><p>行业有一句话：脱离技术，最多只用3年。而一旦脱离，就像断了头，捡起来的难度非常之大。<br>所以即使你已经步入了管理，就不要把这条路走成一条断头路，尤其在现在一日千里的IT行业，变化可谓瞬息万变，所以埋头管理的同时，也得经常抬头看路。</p>
<hr>
<h5 id="即使转产品，也请做一个有扎实技术基础的产品经理"><a href="#即使转产品，也请做一个有扎实技术基础的产品经理" class="headerlink" title="即使转产品，也请做一个有扎实技术基础的产品经理"></a>即使转产品，也请做一个有扎实技术基础的产品经理</h5><p>坊间传闻，阿里现在招聘产品经理，大部分都倾向于从技术流里面转。阿里作为中国互联网企业的翘楚和领军，不客气的说它的某些行为就是标准，就是规范，其它中小企业会慢慢效仿，这获取就是将来的一种趋势~</p>
<blockquote>
<p>各位同仁也可观察观察业界名人（产品经理）：张小龙、雷军、周鸿祎、马化腾…均为技术出生转向的产品</p>
</blockquote>
<p>在我身边，很多程序员是很“羡慕”产品经理的工作的：门槛低、工资高；压力小，不背锅；有假期，加班少…很多小伙伴纷纷觉得这个工种超级棒。<br>确实，从“幸福生活”的角度去这么思考是无可厚非的，我自己本人也十分同意和羡慕。但永远相信：人的选择可能会错，但社会的选择却永远不会有误。就好比前几年移动端Android、IOS超级超级火一样，还是不要只看当下而已~</p>
<p>技术转产品岗我个人认为是非常好的一种归宿，幸福指数很高。在纯技术 or 纯产品都受到了前所未有的挑战的现在，如果你转准备转产品，也请做一个有扎实技术基础的产品经理，而不是仅仅为了逃到舒适区里去，否则就被温水煮青蛙了~</p>
<hr>
<h5 id="平台高和能力强越来越不成正比"><a href="#平台高和能力强越来越不成正比" class="headerlink" title="平台高和能力强越来越不成正比"></a>平台高和能力强越来越不成正比</h5><p>时间往前推5年，从BAT（甚至包括京东）跳出来的人面试是带光环的，自然而然的会高看你一眼。所以那个时候出现了非常多的的去大公司”镀金”现象。也正因为如此并且伴随着互联网的快速发展，现在市场上可谓鱼龙混杂，越来越多的浑水摸鱼的现象出现了（相信你肯定也吐槽过自己身边的前BAT员工：”我操，这水平也太菜了吧”）</p>
<p>那企业招聘怎么办？？？很简单：一刀切呗（<strong>talk is cheap, show me the code</strong>）。时代在变迁，这种思维5年前好用，现在已经过时了。需要保持时俱进，随时纠正自己。只有自己真的是铁，才不怕面试的三位真火，保持自己的核心竞争力才是屹立于市场之王道</p>
<hr>
<h5 id="跳出舒适区，居安思危"><a href="#跳出舒适区，居安思危" class="headerlink" title="跳出舒适区，居安思危"></a>跳出舒适区，居安思危</h5><p>在职场上混，永远没有谁是真正安全的，无论是做技术，还是做管理。<strong>人生已经这么艰难了，没想到越来越难</strong>。本着居安思危，如履薄冰的态度，才能让我们一直保持可靠的竞争力，越过IT人35岁的怪圈~</p>
<hr>
<h3 id="技术驱动"><a href="#技术驱动" class="headerlink" title="技术驱动"></a>技术驱动</h3><p><strong>世界上没有技术驱动型公司</strong>。哪怕强如google，微软，或是国内的阿里、腾讯，都不是技术驱动型公司。道理很简单：技术不是源头，需求才是。而技术只是为了更好的去服务需求的一种工具而已~</p>
<p>一切技术问题，都要服从产品交付和市场反馈，所以客观的说，任何公司都不可能以技术去驱动自身。人可以用技术驱动自身，但公司不行。<br>在市场经济下，以技术为导向的组织只有一个地方：研究院。它的特点是：不需要自己挣钱，所以没有生存压力，国家用纳税人的钱养着就成。</p>
<p>针对IT行业的技术特性，我亦有如下感悟：</p>
<hr>
<h4 id="和IT行业相似度最高的是盖楼房"><a href="#和IT行业相似度最高的是盖楼房" class="headerlink" title="和IT行业相似度最高的是盖楼房"></a>和IT行业相似度最高的是盖楼房</h4><p>IT是工科，不是理科，和IT行业相似度最高的行业是盖楼房，相似度惊人。</p>
<hr>
<h4 id="IT领域最重要的是经验而不是你有多聪明"><a href="#IT领域最重要的是经验而不是你有多聪明" class="headerlink" title="IT领域最重要的是经验而不是你有多聪明"></a>IT领域最重要的是经验而不是你有多聪明</h4><p>作为技术从业者，你需要区分什么是IT领域，什么是科研领域，而本文只讨论现在知识社会生产力中的IT领域。</p>
<p>你可能被大叔大妈这样跨过：做IT计算机的人都好聪明的，膜拜。可千万别被这种“幻觉”带跑偏了，别迷之自信哈。记住我之前分享过的一句非常经典的话：<strong>你做得好不好，不取决于你是否聪明，而取决于你是否愿意不断读书不断学习和不断积累</strong>。经常给自己泼泼冷水，能让自己更加清醒</p>
<hr>
<h5 id="能大规模商用的技术，都不需要智商"><a href="#能大规模商用的技术，都不需要智商" class="headerlink" title="能大规模商用的技术，都不需要智商"></a>能大规模商用的技术，都不需要智商</h5><p>存在即合理：如果一门技术需要智商才能使用，那么它不可能规模化，不可能规模化那就最终就会消失（或者小众到只留在实验室）</p>
<hr>
<h5 id="技术栈，一旦确立了，就几乎改不了"><a href="#技术栈，一旦确立了，就几乎改不了" class="headerlink" title="技术栈，一旦确立了，就几乎改不了"></a>技术栈，一旦确立了，就几乎改不了</h5><p>写代码和盖楼是一样的，一旦地基框架都打好了，只有可能重新建一栋而不可能去重构它。</p>
<blockquote>
<p>在技术层面我记忆最深的是初学编程的时候，很多文章都建议写SQL标准的SQL，因为万一数据库换了呢？现在看来这种，一旦你确立了，就几乎改不了了（存在0.01%改的可能性，但那并不重要）</p>
</blockquote>
<p><strong>这里面有一个看起来很对，其实错误的一个观点</strong>：”只要学会了一门语言，其它语言都差不多的”。这句话最常听见是挂在工作只有几年的从业者身上，也是没有认知自我，迷之自信的表现。稍微深入点了解才知道其实这是非常错误的，因为每一个<strong>技术栈</strong>的size都太深了，你几乎不太可能去精通多个~</p>
<p>正所谓基础不牢，地动山摇，所以选型、确定根基很重要。因此业界有个极端的二八原则：花80%的时间做代码设计、画UML图、画时序图，20%的时间写code和debug~</p>
<hr>
<h3 id="分享精神"><a href="#分享精神" class="headerlink" title="分享精神"></a>分享精神</h3><p>说到分享精神，有必要提及一个代表性人物：罗振宇（同时也是贩卖知识、贩卖焦虑的代表，哈哈）</p>
<blockquote>
<p>小提示：罗振宇2019时间的朋友跨年演讲就在今晚20:30哦，在愛奇艺播出</p>
</blockquote>
<p>它的产品”得到”是一个很大的、有干货的、自媒体分享平台，可以说它是一个当代一个伟大的作品。我觉得你从它里最主要得到的不应该是它分享出来的内容，而是它的这种精神。毕竟即使你天天听逻辑思维，你也变不成罗振宇。这些是需要你自己有这个去实践的过程的~</p>
<hr>
<h4 id="你最大的价值在于你知道那些东西的过程，而不是那些东西本身"><a href="#你最大的价值在于你知道那些东西的过程，而不是那些东西本身" class="headerlink" title="你最大的价值在于你知道那些东西的过程，而不是那些东西本身"></a>你最大的价值在于你知道那些东西的过程，而不是那些东西本身</h4><p>不要担心你知道的东西告诉了别人你就没价值了。在我们IT圈，你愿意和别人分享别人自然也会愿意和你分享，最终达到1+1大于2的效果。不分享，就像一个失去了互联网的程序员，试问N年后你的价值还能被保留多少呢？</p>
<p>持有“我把别人知道的都学会、我把自己知道的都藏起来别让别人学去”想法的人，其实是默认全世界只有你聪明别人都是傻瓜，这样的人，在信息传输成本高的时代，尚且可以活下去，但是在今天这个信息交换极速的时代，这么做的话路会越走越窄最后会自己走入死胡同。</p>
<blockquote>
<p>说明：若你真的知道了了不得的黑科技，请你也注意保护好自己的知识产权，申请专利</p>
</blockquote>
<hr>
<h4 id="工作要有热情"><a href="#工作要有热情" class="headerlink" title="工作要有热情"></a>工作要有热情</h4><p>有一句很熟悉的话语：智商决定了你的起点，情商决定你能走多远。在工作中，你不乏看到过这样的现象：你某个同事技术一般、学历一般、智商也一般，但它就是工作饱有热情，然后它最终成为了你的领导~</p>
<p>对于这种现象，不要怨天尤人，因为所有的被动选择其实都是你当初的主动选择</p>
<hr>
<h3 id="能力边界"><a href="#能力边界" class="headerlink" title="能力边界"></a>能力边界</h3><p>在2019年，这是我本人听到自己的领导们提及最多的一个词语。在过去，专精一个方面是不错的，这是我们说的专注，工匠精神。但是在如今，我们会发现这个领域变化太快了，很多时候不是自己的原因，是<strong>趋势和浪潮</strong>决定了，突然某个时间点，你还在奔跑，但是赛道变了。</p>
<blockquote>
<p>比如你还在闭门造你的燃油车，然而电车出现了并且引领了潮流</p>
</blockquote>
<p>做技术也是一样的，现在越来越流行<strong>弯道超车</strong>（比如DevOps，K8S，Serviceless等等），对于那些”逝去”的技术，很多时候你无需搭理，而应该吧时间放在刀刃上。<br>所以如果我们的专业能力只在一个赛道上，就可能会有类似的风险，so我们应该让自己的能力边界应该越来越宽，更新，拓展，找到新的领域，巩固自己已有护城河时，也别忘了增加自己的护城河。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里，我的2019年感悟的总结就结束了，还是需要说明一句：本文仅仅是一家之言，不代表任何官方和组织，也没有任何偏向，纯自己yy，顺便和同行的你们交换交换意见。</p>
<p>最后，2019年马上结束了，当然要预祝各位新年愉快喽。若有些想法和思考的朋友，可以私信我 or 左边加我好友一起探讨的，祝福2020年一切将变得更加美好~</p>]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>2019</tag>
        <tag>2020</tag>
        <tag>裁员</tag>
        <tag>职业生涯</tag>
      </tags>
  </entry>
  <entry>
    <title>静态代码块、静态变量，构造代码块、实例变量的执行顺序和继承逻辑</title>
    <url>/x2y/1b8d333f.html</url>
    <content><![CDATA[<blockquote>
<p>面试总在懵逼和牛逼之间徘徊。切忌：考官手下留点情，给个机会行不行<br><strong>作者</strong>：A哥（YourBatman）<br><strong>公众号</strong>：BAT的乌托邦（ID：BAT-utopia）<br><strong>文末是否有彩蛋</strong>：有</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>各位小伙伴大家好，我是A哥。如果问：Java的三大特性是什么？你顺口就能答出：封装、继承、多态。如果继续问：你真的了解Java中的继承吗？</p>
<p>或许你本来很懂，但被我这么一问就有点怀疑了。那么，就看看本文吧，保证你会有收获，能让你更好的理解Java中的继承机制。</p>
<h2 id="继承案例"><a href="#继承案例" class="headerlink" title="继承案例"></a>继承案例</h2><h3 id="case1：父类和子类有同名同类型的属性时"><a href="#case1：父类和子类有同名同类型的属性时" class="headerlink" title="case1：父类和子类有同名同类型的属性时"></a>case1：父类和子类有同名同类型的属性时</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用多态</span></span><br><span class="line">        Parent chidParent = <span class="keyword">new</span> Child();</span><br><span class="line">        System.out.println(<span class="string">"Parent:"</span> + chidParent.getAge()); <span class="comment">//40</span></span><br><span class="line">        System.out.println(<span class="string">"Parent:"</span> + chidParent.age); <span class="comment">//18 这个结果你能接受吗？哈哈</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接使用原本类型</span></span><br><span class="line">        Child child = <span class="keyword">new</span> Child();</span><br><span class="line">        System.out.println(<span class="string">"Child:"</span> + child.getAge()); <span class="comment">//40</span></span><br><span class="line">        System.out.println(<span class="string">"Child:"</span> + child.age); <span class="comment">//40</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Integer age = <span class="number">40</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Integer age = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Parent:<span class="number">40</span></span><br><span class="line">Parent:<span class="number">18</span></span><br><span class="line">Child:<span class="number">40</span></span><br><span class="line">Child:<span class="number">40</span></span><br></pre></td></tr></table></figure>
<p>我相信和最初的我一样，对<code>Parent:18</code>这个结果大吃一惊，what？其实这就是Java的继承机制，对此说明如下：</p>
<ol>
<li><strong>属性属于实例自己的</strong>，所以Parent的age属性值是18，这就解释通了</li>
<li>属性不存在覆盖（即使同名），而方法是实实在在的覆盖（复写）。所以你调用<code>getAge()</code>方法返回的100%是40喽<h3 id="case2：父类和子类有同名但不同类型的属性时"><a href="#case2：父类和子类有同名但不同类型的属性时" class="headerlink" title="case2：父类和子类有同名但不同类型的属性时"></a>case2：父类和子类有同名但不同类型的属性时</h3>结论同上。<h3 id="case3：下面代码输出什么？"><a href="#case3：下面代码输出什么？" class="headerlink" title="case3：下面代码输出什么？"></a>case3：下面代码输出什么？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Child();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Child的静态块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Child的构造块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Child() &#123;</span><br><span class="line">        System.out.println(<span class="string">"Child的构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    Integer age = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent的静态块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent的构造块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Parent() &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent的构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
结果输出：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Parent的静态块</span><br><span class="line">Child的静态块</span><br><span class="line">Parent的构造块</span><br><span class="line">Parent的构造方法</span><br><span class="line">Child的构造块</span><br><span class="line">Child的构造方法</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips：构造代码块优先于构造方法执行，<strong>且优先于属性初始化之前执行</strong><br><code>@PostConstruct</code>是对象的属性都初始化ok了<code>之后</code>才去执行的（注意你new的话，<code>@PostConstruct</code>方法是不会执行的，他是Spring给与的支持哦~）</p>
</blockquote>
</li>
</ol>
<p>值得注意的是，此处子类没有<strong>显示调用super()</strong>，但父类的构造还是执行了的。但是，但是，但是，如果构造快为有参构造，请记得显示调用super方法，否则父类是不能被初始化的。<strong>如果子类的构造器没有显示地调用超类的构造器，则将自动调用超类默认（没有参数） 的构造器</strong>。如果超类没有不带参数的构造器，并且在子类的构造器又没有显式地调用超类的其他构造器，则 java 编译器将报告错误~</p>
<hr>
<h4 id="变种面试题"><a href="#变种面试题" class="headerlink" title="变种面试题"></a>变种面试题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        staticFunction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量（有实例化的过程,这就是本题的重点）</span></span><br><span class="line">    <span class="keyword">static</span> StaticTest st = <span class="keyword">new</span> StaticTest();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//System.out.println(b); // 编译报错：因为b在构造代码块后边，此处不能引用。因此Java代码是从上到下的顺序</span></span><br><span class="line">        System.out.println(<span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    StaticTest() &#123;</span><br><span class="line">        System.out.println(<span class="string">"3"</span>);</span><br><span class="line">        System.out.println(<span class="string">"a="</span> + a + <span class="string">",b="</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这两个变量写在最后面</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">110</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">112</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">a=<span class="number">110</span>,b=<span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>答案五花八门，真正能答对这道题的小伙伴<strong>少之又少</strong>。从结果中，这里先给你扔个结论：</p>
<ol>
<li>先初始化静态变量，也就是执行<code>new StaticTest()</code>，从而打印：2</li>
<li>再执行构造函数，打印：3和<code>a=110,b=0</code><ol>
<li>为何a=110，而b却为0呢？<ol>
<li>执行构造函数之前，必须初始化实例属性，所以a=110</li>
<li>静态变量从上到下初始化，而<code>st</code>变量还没初始化完呢，所以b此时值为0</li>
</ol>
</li>
</ol>
</li>
<li>执行紧跟着的静态代码块。打印：1</li>
<li>执行静态方法<code>staticFunction</code>，打印：4</li>
</ol>
<p>从该结果你应该能知道：<strong>static变量可不是100%一定在实例变量之前被赋值（初始化哦~），比如本例的b就在a之后初始化了</strong></p>
<h5 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h5><p>类的生命周期是：<strong>加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载。</strong></p>
<blockquote>
<p>只有在准备阶段和初始化阶段才会涉及<code>类变量的初始化和赋值</code>，因此只针对这两个阶段进行分析；</p>
</blockquote>
<p><code>类的准备阶段</code>：需要做是为类变量（static变量）分配内存并设置<code>默认值</code>（注意此处都是先给默认值），因此类变量st为null、b为0；</p>
<blockquote>
<p>需要注意的是，如果类变量是final的，<strong>编译时</strong>javac就会为它赋上值。因此上面如果我们这样写<code>static final int b=112</code>它哪怕在准备阶段，值就应该是112了</p>
</blockquote>
<p><code>类的初始化阶段</code>：需要做的是执行<code>类构造器</code>（<code>请注意：这里不是指的构造函数</code>）。</p>
<blockquote>
<p>类构造器：<code>编译器</code>收集所有<code>静态语句块</code>和<code>类变量</code>的<code>赋值语句</code>，按语句在源码中的<strong>顺序（请注意这三者是有序的）</strong>合并生成类构造器</p>
</blockquote>
<p>因此现在执行：<code>st = new StaticTest()</code>.此时我们发现，就会进行对象的初始化了（看到没，这个时候b变量的赋值语句还没有执行哦<del>~</del>）</p>
<p><strong>而对象初始化的顺序为：成员变量 -&gt; 普通代码块 -&gt; 构造函数</strong>，因此这一波过后：a=110了。<br>输出为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">a=<span class="number">110</span>,b=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，此时b仍然为0，并没有被赋值哦~</p>
</blockquote>
<p>到此<code>st = new StaticTest()</code>这句就执行结束了。继续执行<code>类构造器</code>，显然就会执行static语句块了<del>输出1，最后调用静态方法，就输出4了   完美</del></p>
<h4 id="冷知识"><a href="#冷知识" class="headerlink" title="冷知识"></a>冷知识</h4><p>通过结果看，有点颠覆我们之前的认知。其实这是一个冷知识：</p>
<blockquote>
<p>它的关键在于：<code>static StaticTest st = new StaticTest()</code>这句代码，内嵌的这个变量<code>恰好是个静态成员</code>，而且是<code>本类的实例</code>  这就导致了这个有趣的现象：<code>“实例初始化竟然出现在静态初始化之前”。</code></p>
</blockquote>
<p>这里面我只做一小步变化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> StaticTest st = <span class="keyword">new</span> StaticTest()</span><br><span class="line">改成</span><br><span class="line">StaticTest st = <span class="keyword">new</span> StaticTest()</span><br><span class="line">或者改成：</span><br><span class="line"><span class="keyword">static</span> Object st = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>
<p>最终输出结果就为（符合我们常识了吧，啊哈哈哈哈）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="case4：子类和父类有同名同类型的静态变量的时候"><a href="#case4：子类和父类有同名同类型的静态变量的时候" class="headerlink" title="case4：子类和父类有同名同类型的静态变量的时候"></a>case4：子类和父类有<code>同名同类型</code>的<code>静态</code>变量的时候</h3><p>结论就不用解释了：静态变量属于类的，和继承无关。</p>
<h3 id="case5：静态代码块属于类的，并且优先于main方法执行（有难度）"><a href="#case5：静态代码块属于类的，并且优先于main方法执行（有难度）" class="headerlink" title="case5：静态代码块属于类的，并且优先于main方法执行（有难度）"></a>case5：静态代码块属于类的，并且优先于main方法执行（有难度）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        speak();</span><br><span class="line">        <span class="comment">//StaticDemo1 t1 = new StaticDemo1();</span></span><br><span class="line">        <span class="comment">//System.out.println(t1.i);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"a"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = i + <span class="number">3</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticDemo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i = i + <span class="number">5</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<p>4在a之前输出，证明：毕竟mian方法属于<code>StaticDemo1</code>类的方法，所以会先执行此类的静态变量 + 静态代码块。</p>
<p>其它不变，改为这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    StaticDemo1 t1 = <span class="keyword">new</span> StaticDemo1();</span><br><span class="line">    System.out.println(t1.i);</span><br><span class="line">    speak();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<ol>
<li>执行静态代码块：打印4</li>
<li>执行构造方法：打印9</li>
<li><code>System.out.println(t1.i)</code>直接输出，打印9（此时i的值是9）</li>
<li>执行speak()：打印1</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    speak();</span><br><span class="line">    StaticDemo1 t1 = <span class="keyword">new</span> StaticDemo1();</span><br><span class="line">    System.out.println(t1.i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4</span></span><br><span class="line">a</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>这个输出，在意料之中，不再解释喽。</p>
<p>这是一道面试题，考察的是：<strong>static块真正的执行时机</strong>。若想真正了解类的装载，请去了解JVM吧~</p>
<h2 id="注解对执行顺序的影响"><a href="#注解对执行顺序的影响" class="headerlink" title="注解对执行顺序的影响"></a>注解对执行顺序的影响</h2><p>特别的，这里我介绍一下各种注解影响的执行顺序，如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitBeanTest</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>,<span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt; </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DemoService demoService;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InitBeanTest</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">       System.err.println(<span class="string">"----&gt; InitSequenceBean: constructor: "</span>+demoService);     </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@PostConstruct</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postConstruct</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.err.println(<span class="string">"----&gt; InitSequenceBean: @PostConstruct: "</span>+demoService);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        System.err.println(<span class="string">"----&gt; InitSequenceBean: afterPropertiesSet: "</span>+demoService);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent arg0)</span> </span>&#123;  </span><br><span class="line">        System.err.println(<span class="string">"----&gt; InitSequenceBean: onApplicationEvent"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line">----&gt; InitSequenceBean: constructor: <span class="keyword">null</span></span><br><span class="line">----&gt; InitSequenceBean: <span class="meta">@PostConstruct</span>: com.xxx.service.impl.DemoServiceImpl@<span class="number">40f</span>e544</span><br><span class="line">----&gt; InitSequenceBean: afterPropertiesSet: com.xxx.service.impl.DemoServiceImpl@<span class="number">40f</span>e544</span><br><span class="line">----&gt; InitSequenceBean: onApplicationEvent</span><br></pre></td></tr></table></figure>
<p>根据代码演示，得出文字版结论：</p>
<ul>
<li>构造函数是每个类<strong>最先执行</strong>的，这个时候，bean属性还没有被注入</li>
<li><strong>@PostConstruct优先于afterPropertiesSet执行</strong>：在这执行，属性已经完成了赋值（注入）</li>
</ul>
<hr>
<h2 id="继续补充：子类默认调用父类构造函数问题"><a href="#继续补充：子类默认调用父类构造函数问题" class="headerlink" title="继续补充：子类默认调用父类构造函数问题"></a>继续补充：子类默认调用<code>父类构造函数</code>问题</h2><p>Java有个很有趣的现象：父类有N多个构造函数，子类如果只写一个的话那么子类最终就只有一个构造函数可用，因此子类在这方面要特别的注意喽。<br>默认情况下，子类在使用构造函数初始化时（不管是子类使用有参构造还是无参构造），<strong>默认情况下都会调用父类的无参构造函数（相当于调用了<code>super()</code>）</strong>。看看下面几个变种如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类木有空的构造  只有一个有参构造</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is parent cons..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时候我们发现发现如下三问题：<br>1、子类Child<strong>必须</strong>有对应的有参构造<br><img data-src="https://img-blog.csdnimg.cn/20190617171950547.png" alt=""><br>2、super(id)必须显示的写出，否则编译不通过<br><img data-src="https://img-blog.csdnimg.cn/20190617172039187.png" alt=""><br>3、原则上，子类的构造函数不能<strong>多于</strong>父类的<br><img data-src="https://img-blog.csdnimg.cn/20190617172208443.png" alt=""><br>4、子类构造函数若多余父类（或者类型啥的和父类不匹配），需要显示的调用父类构造函数<br><img data-src="https://img-blog.csdnimg.cn/20190625141710640.png" alt=""><br>结论：</p>
<ul>
<li>1、子类构造器执行之前<strong>必须</strong>能够<code>先执行</code>父类的构造函数（super(xxx)必须放在第一行代码）</li>
<li>2、若父类有空构造，子类构造默认都会调用<code>super()</code>。若父类木有空构造，子类所有构造都必须<strong>显示</strong>调用<code>super(xxx)·</code><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>据反馈，看了此篇文章后，很多小伙伴感觉自己学的是另外一个Java，其实这就是JavaSE，很多架构师认为，Java基础才是精华中的精华（一流），Spring才属于应用级别的技术（二流）。</li>
</ul>]]></content>
      <categories>
        <category>A哥学Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>静态类、静态方法、内部类、匿名内部类、非静态类的一些实践</title>
    <url>/x2y/889a54a1.html</url>
    <content><![CDATA[<blockquote>
<p>只要干不死，就往死里干。累吗，累就对了，证明你还活着。<br><strong>作者</strong>：A哥（YourBatman）<br><strong>公众号</strong>：BAT的乌托邦（ID：BAT-utopia）<br><strong>文末是否有彩蛋</strong>：有</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>各位小伙伴大家好，我是A哥。如题，在实际开发中，关于静态类、静态方法、内部类、匿名内部类、非静态类一般都会遇到，特别是你在研究开源框架源码的时候很是常见，它是内聚性的体现。本文针对这些“概念”的实战，做些总结。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>首先介绍静态类和非静态类内部类。<strong>先普及一个常识</strong>：一个文件里可以有多个类，但public的类只能有一个且必须和文件名一样。public final class可以这样写，但不能这样写：public static class A。但如果这个类是内部类，是可以这样写的：public static class A</p>
<h2 id="静态内部类-vs-内部类"><a href="#静态内部类-vs-内部类" class="headerlink" title="静态内部类 vs 内部类"></a>静态内部类 vs 内部类</h2><p>静态内部类：只是为了降低包的深度，方便类的使用，实现高内聚。静态内部类适用于不依赖于外部类，不用使用外在类的<strong>非静态属性</strong>和方法，只是为了方便管理类结构而定义。在创建静态内部类的时候，不需要外部类对象的引用。</p>
<p>非静态内部类：它有一个很大的优点：<strong>可以自由使用外部类的所有变量和方法</strong>，对其外部类有个引用<br>有了这两个区别，各位看官应该知道什么时候使用什么样的类了吧</p>
<hr>
<h2 id="静态方法-vs-非静态方法"><a href="#静态方法-vs-非静态方法" class="headerlink" title="静态方法 vs 非静态方法"></a>静态方法 vs 非静态方法</h2><p>静态方法（Static Method）与静态成员变量一样，<strong>属于类本身</strong>，在类装载的时候被装载到内存，不自动进行销毁，会一直存在于内存中，直到JVM关闭。静态方法的使用效率比非静态方法的效率高。静态方法是共享代码段，静态变量是共享数据段。既然是“共享”就有并发（Concurrence）的问题。</p>
<p>非静态方法（Non-Static Method）又叫实例化方法，属于实例对象，实例化后才会分配内存，必须通过类的实例来引用。不会常驻内存，当实例对象被JVM 回收之后，也跟着消失。是针对确定的一个对象的，所以不会存在线程安全的问题</p>
<p><strong><em>静态方法和实例方法是一样的，在类型第一次被使用时加载。调用的速度基本上没有差别</em></strong>。针对静态方法有一些最佳实践给你参考：</p>
<ul>
<li>适当地使用static方法本身并没有什么，当一个人从来不懂使用多态、接口设计时，很自然地会滥用static方法。</li>
<li>通常通用的类中一些常用的方法可以设计为静态的</li>
<li>只要是没有用到类的状态信息，只从参数获取信息的都可以为静态的</li>
<li>静态方法可以实现某些特殊的设计模式：如Singleton</li>
<li>由于没有this指针，可以把某些系统API的回调函数以静态函数的形式封装到类的内部</li>
</ul>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>那么，匿名内部类有什么好处呢？除了只能使用一次，其实还有其他用处哦~</p>
<p>当你想使用一个类的<strong>protected 方法时</strong>，但是目前你的类又和他<strong>不同包</strong>且也不能继承他，这时候匿名类就派上用场了，你可以声明一个<em>匿名类继承该类</em>，并定义一个方法然后调用父类方法即可</p>
<p>其实，这个做法，我是在<code>spring-boot</code>中的<code>HttpMessageConverters</code>类中看到的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpMessageConverters：</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> List&lt;HttpMessageConverter&lt;?&gt;&gt; getDefaultConverters() &#123;</span><br><span class="line">	    List&lt;HttpMessageConverter&lt;?&gt;&gt; converters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">if</span> (ClassUtils.isPresent(<span class="string">"org.springframework.web.servlet.config.annotation."</span> + <span class="string">"WebMvcConfigurationSupport"</span>, <span class="keyword">null</span>)) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 匿名内部类的实现</span></span><br><span class="line">			converters.addAll(<span class="keyword">new</span> WebMvcConfigurationSupport() &#123;</span><br><span class="line">				<span class="keyword">public</span> List&lt;HttpMessageConverter&lt;?&gt;&gt; defaultMessageConverters() &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">super</span>.getMessageConverters();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;.defaultMessageConverters());</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			converters.addAll(<span class="keyword">new</span> RestTemplate().getMessageConverters());</span><br><span class="line">		&#125;</span><br><span class="line">		reorderXmlConvertersToEnd(converters);</span><br><span class="line">		<span class="keyword">return</span> converters;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>所以，spring都这么干了，你还有什么理由不学习麽？</p>
<h1 id="内部类和静态内部类的区别"><a href="#内部类和静态内部类的区别" class="headerlink" title="内部类和静态内部类的区别"></a>内部类和静态内部类的区别</h1><h3 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h3><ol>
<li>只能在内部类中定义静态类 </li>
<li>静态内部类不依赖于外部类，即使外部类没有创建对象，静态类也可以new对象</li>
<li>静态类的方法可以是静态的方法也可以是非静态的方法，静态的方法可以在外层通过静态类调用，而非静态的方法必须要创建类的对象之后才能调用。 </li>
<li>静态类<strong>只能引用外部类的s</strong>tatic成员变量（变量或者方法）（也就是类变量）。 </li>
<li>如果一个内部类不是被定义成静态内部类，那么在定义成员变量或者成员方法的时候，是不能够被定义成静态的。（静态成员只能定义在静态内部类里）<h3 id="和普通内部类的区别"><a href="#和普通内部类的区别" class="headerlink" title="和普通内部类的区别"></a>和普通内部类的区别</h3></li>
<li>是否能拥有静态成员<br>静态内部类可以有静态成员(方法，属性)，而非静态内部类则不能有静态成员(方法，属性)。 </li>
<li>访问外部类的成员<br>静态内部类只能够访问外部类的静态成员,而非静态内部类则可以访问外部类的所有成员(方法，属性)。 </li>
<li>静态内部类和非静态内部类在创建时有区别<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设类A有静态内部类B和非静态内部类C，创建B和C的区别为： </span></span><br><span class="line">A a=<span class="keyword">new</span> A(); </span><br><span class="line"><span class="comment">//创建B</span></span><br><span class="line">A.B b=<span class="keyword">new</span> A.B(); </span><br><span class="line"><span class="comment">//创建C</span></span><br><span class="line">A.C c=a.<span class="keyword">new</span> C();</span><br></pre></td></tr></table></figure>
<h2 id="内部类的面试题"><a href="#内部类的面试题" class="headerlink" title="内部类的面试题"></a>内部类的面试题</h2>送一道匿名内部类的面试题：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">按照要求，补齐代码</span><br><span class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">Inter</span> </span>&#123; </span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123; </span><br><span class="line">		<span class="comment">//补齐代码 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">OuterDemo</span> </span>&#123;</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		      Outer.method().show();</span><br><span class="line">		  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">要求在控制台输出”HelloWorld”。</span><br></pre></td></tr></table></figure>
答案如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Inter <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Inter()&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Outer.method().show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>说说内部类的好处吧</li>
</ol>
<ul>
<li>内部类可以很好的实现隐藏(一般的非内部类，是不允许有 private 与protected权限的，但内部类可以)</li>
<li>内部类拥有外围类的所有元素的访问权限</li>
<li>可以实现多重继承</li>
<li>可以避免修改接口而实现同一个类中<strong><em>两种同名方法</em></strong>的调用</li>
</ul>
<p>java的设计旨在简单，所以初学者十分好入门并且上手工作，但作为一门火了这么多年的语言，肯定还是有些硬骨头的，而这些，算是一些脆骨了。我们会发现java的设计者在设计内部类的时候用心良苦，学会使用内部类，是掌握java高级编程的一部分，它可以让你更优雅的设计你的程序结构。</p>]]></content>
      <categories>
        <category>A哥学Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
</search>
